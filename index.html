<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>글씨 요정 - 바른 글씨 연습</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 20px;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            padding: 30px;
            animation: slideUp 0.6s ease-out 0.2s both;
            transition: box-shadow 0.3s ease;
        }

        .container:hover {
            box-shadow: 0 15px 40px rgba(0,0,0,0.15);
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .header {
            text-align: center;
            margin-bottom: 8px;
            position: relative;
        }





        .title {
            color: #1a1a1a;
            font-size: clamp(1.8rem, 5vw, 3rem);
            font-weight: 800;
            margin-bottom: 15px;
            word-break: keep-all;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            animation: titleGlow 0.8s ease-out 0.4s both;
            position: relative;
            letter-spacing: 0.8px;
            text-align: center;
            background: linear-gradient(45deg, #1a1a1a 25%, #4a5568 50%, #1a1a1a 75%);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 0.8s ease-out 0.4s both, shimmerText 6s ease-in-out infinite;
        }

        @keyframes shimmerText {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .title::before {
            content: '';
            position: absolute;
            top: -12px;
            left: -20px;
            right: -20px;
            bottom: -12px;
            background: transparent;
            border-radius: 25px;
            z-index: -2;
            opacity: 0;
            animation: titleBackgroundGlow 1.2s ease-out 0.6s both;
        }

        .title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            width: 0;
            height: 5px;
            background: linear-gradient(90deg, #2d3748, #4a5568, #2d3748);
            border-radius: 4px;
            transform: translateX(-50%);
            animation: underlineExpand 1.2s ease-out 0.8s both;
            box-shadow: 
                0 2px 8px rgba(0, 0, 0, 0.15),
                0 4px 16px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        @keyframes titleGlow {
            from { 
                opacity: 0; 
                transform: translateY(-15px) scale(0.95); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0) scale(1); 
            }
        }

        @keyframes titleBackgroundGlow {
            from { 
                opacity: 0; 
                transform: scale(0.8); 
            }
            to { 
                opacity: 1; 
                transform: scale(1); 
            }
        }

        @keyframes underlineExpand {
            from { 
                width: 0; 
                opacity: 0;
            }
            to { 
                width: 80px; 
                opacity: 1;
            }
        }

        .subtitle {
            color: #64748b;
            font-size: clamp(1rem, 2.5vw, 1.3rem);
            font-weight: 500;
            word-break: keep-all;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            animation: fadeInUp 0.6s ease-out 0.6s both;
            position: relative;
            margin-bottom: 5px;
            text-align: center;
        }

        .subtitle::before {
            content: '✨';
            margin-right: 8px;
            font-size: 1.1em;
            animation: sparkle 2s ease-in-out infinite;
        }

        .subtitle::after {
            content: '✨';
            margin-left: 8px;
            font-size: 1.1em;
            animation: sparkle 2s ease-in-out infinite 1s;
        }

        @keyframes sparkle {
            0%, 100% { 
                opacity: 0.6; 
                transform: scale(1); 
            }
            50% { 
                opacity: 1; 
                transform: scale(1.1); 
            }
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(15px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .mode-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            animation: fadeInScale 0.6s ease-out 0.8s both;
        }

        @keyframes fadeInScale {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        .teacher-only-notice {
            text-align: center;
            background: linear-gradient(135deg, #e6fffa 0%, #b2f5ea 100%);
            border: 2px solid #4fd1c7;
            border-radius: 15px;
            padding: 15px;
            color: #234e52;
            animation: slideInFromTop 0.6s ease-out 1s both;
            position: relative;
            overflow: hidden;
        }

        .teacher-only-notice::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent);
            transform: rotate(45deg);
            animation: shimmer 2s infinite;
        }

        @keyframes slideInFromTop {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }

        .teacher-only-notice p {
            margin: 0;
            font-size: 1rem;
            font-weight: 500;
        }

        .mode-btn {
            padding: 15px 30px;
            font-size: 1.2rem;
            border: 3px solid #e2e8f0;
            border-radius: 15px;
            background: white;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: bold;
            position: relative;
            overflow: hidden;
        }

        .mode-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.5s;
        }

        .mode-btn:hover::before {
            left: 100%;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .mode-btn:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .mode-btn:active {
            transform: translateY(-1px) scale(0.98);
        }

        .screen {
            display: none;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.4s ease-out;
        }

        .screen.active {
            display: block;
            animation: screenFadeIn 0.5s ease-out forwards;
        }

        @keyframes screenFadeIn {
            from { 
                opacity: 0; 
                transform: translateY(20px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }

        .input-section {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            animation: slideInFromBottom 0.6s ease-out 0.3s both;
        }

        @keyframes slideInFromBottom {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .text-input {
            padding: 15px 25px;
            font-size: 1.4rem;
            border: 3px solid #e2e8f0;
            border-radius: 15px;
            outline: none;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 500px;
            width: 100%;
            max-width: 600px;
            position: relative;
            background: white;
        }

        .text-input:focus {
            border-color: #4299e1;
            box-shadow: 0 0 0 4px rgba(66, 153, 225, 0.1), 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }

        .text-input:hover:not(:focus) {
            border-color: #cbd5e0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .btn {
            padding: 15px 30px;
            font-size: 1.2rem;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: bold;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:active::before {
            width: 300px;
            height: 300px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.2);
        }

        .btn-primary:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
            background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
        }

        .btn-primary:active {
            transform: translateY(-1px) scale(0.98);
        }

        .btn-secondary {
            background: white;
            color: #48bb78;
            border: 2px solid #48bb78;
            box-shadow: 0 2px 8px rgba(72, 187, 120, 0.1);
        }

        .btn-secondary:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 25px rgba(72, 187, 120, 0.3);
            background: #f0fff4;
            border-color: #38a169;
            color: #38a169;
        }

        .btn-secondary:active {
            transform: translateY(-1px) scale(0.98);
        }

        .btn-evaluate {
            background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
            color: white;
            border: none;
            box-shadow: 0 4px 15px rgba(237, 137, 54, 0.3);
        }

        .btn-evaluate:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 25px rgba(237, 137, 54, 0.4);
            background: linear-gradient(135deg, #dd6b20 0%, #c05621 100%);
        }

        .btn-evaluate:active {
            transform: translateY(-1px) scale(0.98);
        }

        .btn-success {
            background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%);
            color: #2d5016;
            box-shadow: 0 4px 15px rgba(132, 250, 176, 0.3);
        }

        .btn-success:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 25px rgba(132, 250, 176, 0.5);
            background: linear-gradient(135deg, #68d391 0%, #4fd1c7 100%);
        }

        .btn-success:active {
            transform: translateY(-1px) scale(0.98);
        }

        .assignment-link {
            background: #f7fafc;
            border: 2px dashed #cbd5e0;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            animation: slideInFromRight 0.6s ease-out;
            position: relative;
            overflow: hidden;
        }

        .assignment-link::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(203, 213, 224, 0.3), transparent);
            animation: linkShimmer 2s infinite;
        }

        @keyframes slideInFromRight {
            from { opacity: 0; transform: translateX(30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        @keyframes linkShimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .link-display {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 1.1rem;
            word-break: break-all;
        }

        .display-text {
            text-align: center;
            font-size: clamp(1rem, 3vw, 1.8rem);
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 20px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px;
            word-wrap: break-word;
            word-break: break-word;
            line-height: 1.3;
            overflow-wrap: break-word;
            hyphens: auto;
            white-space: pre-wrap;
            overflow: hidden;
            box-sizing: border-box;
            transition: all 0.3s ease;
            position: relative;
        }

        .display-text::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            width: 0;
            height: 2px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transform: translateX(-50%);
            transition: width 0.5s ease;
        }

        .display-text:not(:empty)::after {
            width: 80%;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 500px;
            border: 3px dashed #cbd5e0;
            border-radius: 15px;
            background: #f7fafc;
            margin-bottom: 20px;
            overflow: hidden;
            transition: all 0.3s ease;
            animation: containerFadeIn 0.6s ease-out 0.5s both;
        }

        .canvas-container:hover {
            border-color: #a0aec0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        @keyframes containerFadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        .guide-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8rem;
            font-weight: bold;
            color: #888;
            opacity: 0.3;
            pointer-events: none;
            z-index: 1;
            white-space: nowrap;
            letter-spacing: 0.2em;
        }

        #drawingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            z-index: 2;
        }

        .character-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            justify-content: center;
            align-items: center;
            padding: 20px;
            min-height: 500px;
        }

        .character-box {
            position: relative;
            width: 200px;
            height: 200px;
            border: 3px solid #cbd5e0;
            border-radius: 10px;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 120px;
        }

        .character-guide {
            position: absolute;
            font-size: 160px;
            font-weight: 300;
            color: #d1d5db;
            opacity: 0.6;
            pointer-events: none;
            z-index: 1;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .character-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            z-index: 2;
            touch-action: none; /* 터치 스크롤 및 줌 방지 */
        }

        .crosshair-guide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .crosshair-guide::before,
        .crosshair-guide::after {
            content: '';
            position: absolute;
            background: #cbd5e0;
            opacity: 0.3;
        }

        .crosshair-guide::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            border-top: 1px dashed #cbd5e0;
        }

        .crosshair-guide::after {
            top: 0;
            left: 50%;
            width: 1px;
            height: 100%;
            border-left: 1px dashed #cbd5e0;
        }

        .status-indicator {
            position: absolute;
            bottom: -50px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: auto;
            padding: 0;
            border: none;
            background: none;
            box-shadow: none;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .status-indicator.red {
            color: #000;
        }

        .status-indicator.green {
            color: #000;
        }

        .status-indicator.yellow {
            color: #000;
        }

        .character-index {
            position: absolute;
            top: -25px;
            left: 5px;
            font-size: 14px;
            color: #718096;
            font-weight: bold;
        }



        .tool-controls {
            display: flex;
            justify-content: space-between;
            gap: 15px;
            margin: 20px 0;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }

        .tool-controls .btn {
            flex: 1;
            padding: 12px 20px;
            font-size: 1.1rem;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: nowrap;
            margin-bottom: 20px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .instructions {
            text-align: center;
            color: #718096;
            font-size: clamp(1rem, 2.5vw, 1.2rem);
            margin-bottom: 20px;
            padding: 20px;
            background: #edf2f7;
            border-radius: 10px;
            word-break: keep-all;
            line-height: 1.5;
        }

        /* 동적 폰트 크기 조정을 위한 클래스들 */
        .dynamic-text {
            transition: font-size 0.2s ease;
        }

        .auto-resize-text {
            display: inline-block;
            max-width: 100%;
            overflow: hidden;
        }

        .score-display {
            text-align: center;
            padding: 25px;
            margin: 20px 0;
            border-radius: 15px;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .score-excellent {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            color: #155724;
            border: 2px solid #c3e6cb;
        }

        .score-good {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            color: #856404;
            border: 2px solid #ffeaa7;
        }

        .score-needs-improvement {
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
            color: #721c24;
            border: 2px solid #f5c6cb;
        }

        .student-info {
            background: #e6fffa;
            border: 2px solid #81e6d9;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .assignment-info {
            background: #fef5e7;
            border: 2px solid #f6ad55;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .mobile-break {
            display: none;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 15px;
                margin: 0;
                border-radius: 10px;
                max-width: 100%;
                overflow-x: hidden;
            }
            

            
            .mobile-break {
                display: inline;
            }
            
            .title {
                font-size: clamp(1.5rem, 6vw, 2rem);
                word-break: keep-all;
                margin-bottom: 12px;
            }
            
            .title::after {
                width: 60px;
                height: 3px;
            }
            
            .subtitle {
                font-size: clamp(0.9rem, 3vw, 1.1rem);
            }

            .student-title-section {
                padding: 15px;
                margin-bottom: 20px;
            }

            .student-title {
                font-size: clamp(1.4rem, 5vw, 1.8rem);
                margin-bottom: 6px;
            }

            .student-subtitle {
                font-size: clamp(0.85rem, 2.5vw, 1rem);
            }
            
            .display-text {
                font-size: clamp(0.9rem, 3vw, 1.3rem);
                word-break: break-word;
                white-space: pre-wrap;
                overflow: visible;
                text-overflow: unset;
                padding: 12px 8px;
                min-height: 50px;
                line-height: 1.2;
            }
            
            .guide-text {
                font-size: 3rem;
                letter-spacing: 0.05em;
            }
            
            .canvas-container {
                height: 300px;
            }
            
            .input-section {
                flex-direction: column;
                gap: 10px;
            }
            
            .text-input {
                min-width: 100%;
                font-size: 1.2rem;
                padding: 12px 20px;
            }

            .btn {
                padding: 12px 20px;
                font-size: 1rem;
                width: 100%;
            }

            .character-box {
                width: 150px;
                height: 150px;
                margin-bottom: 80px;
            }

            .character-guide {
                font-size: 120px;
                font-weight: 300;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .character-canvas {
                width: 150px;
                height: 150px;
            }

            .character-grid {
                gap: 20px;
                padding: 15px;
            }

            .assignment-text {
                font-size: clamp(1rem, 3vw, 1.3rem);
                word-break: break-word;
                white-space: pre-wrap;
                overflow: visible;
                text-overflow: unset;
                line-height: 1.3;
            }

            .student-header {
                padding: 12px 15px;
                margin-bottom: 15px;
                max-width: 95%;
                min-height: 70px;
            }

            .student-header h2 {
                font-size: clamp(0.9rem, 2.5vw, 1rem);
                margin-bottom: 6px;
                text-align: center;
            }

            .instructions {
                font-size: 1rem;
                padding: 12px;
                margin-bottom: 15px;
            }

            .tool-controls {
                max-width: 100%;
                margin: 15px 0;
                gap: 10px;
            }

            .tool-controls .btn {
                padding: 10px 15px;
                font-size: 1rem;
            }

            .controls {
                gap: 10px;
                flex-wrap: wrap;
                max-width: 100%;
            }

            .controls .btn {
                padding: 12px;
                font-size: 1rem;
                min-width: 120px;
            }

            .assignment-info, .teacher-only-notice {
                padding: 10px;
                margin-bottom: 15px;
            }

            .assignment-info h3 {
                font-size: 1rem;
                margin-bottom: 6px;
            }

            .assignment-info p {
                font-size: 0.8rem;
                line-height: 1.3;
            }

            .teacher-only-notice p {
                font-size: 0.9rem;
            }

            .assignment-link {
                padding: 15px;
                margin: 15px 0;
            }

            .score-display {
                padding: 15px;
                font-size: 1.2rem;
            }

            .status-indicator {
                bottom: -40px;
                width: 150px;
                font-size: 10px;
            }

            .evaluation-content {
                padding: 20px;
                margin: 20px;
            }

            .evaluation-title {
                font-size: 1.5rem;
            }

            .evaluation-score {
                font-size: 2.2rem;
            }

            .evaluation-message {
                font-size: 1rem;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            
            .container {
                padding: 10px;
            }
            

            
            .title {
                font-size: clamp(1.6rem, 6.5vw, 1.9rem);
                margin-bottom: 10px;
            }

            .title::after {
                width: 50px;
                height: 2px;
            }

            .subtitle {
                font-size: clamp(0.8rem, 3.5vw, 0.95rem);
            }

            .student-title-section {
                padding: 12px;
                margin-bottom: 15px;
            }

            .student-title {
                font-size: clamp(1.3rem, 6vw, 1.5rem);
                margin-bottom: 5px;
            }

            .student-subtitle {
                font-size: clamp(0.8rem, 3vw, 0.9rem);
            }
            
            .display-text {
                font-size: clamp(1.1rem, 5vw, 1.3rem);
            }
            
            .guide-text {
                font-size: 2.5rem;
            }
            
            .canvas-container {
                height: 250px;
            }

            .character-box {
                width: 120px;
                height: 120px;
                margin-bottom: 70px;
            }

            .character-guide {
                font-size: 90px;
                font-weight: 300;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .character-canvas {
                width: 120px;
                height: 120px;
            }

            .character-grid {
                gap: 15px;
                padding: 10px;
            }

            .assignment-text {
                font-size: clamp(0.9rem, 4vw, 1.1rem);
                word-break: break-word;
                white-space: pre-wrap;
                overflow: visible;
                text-overflow: unset;
                line-height: 1.2;
            }

            .student-header h2 {
                font-size: clamp(0.8rem, 3vw, 0.9rem);
                margin-bottom: 5px;
                text-align: center;
            }

            .btn {
                font-size: 0.9rem;
                padding: 10px 15px;
            }

            .controls .btn {
                min-width: 100px;
                font-size: 0.85rem;
            }

            .status-indicator {
                bottom: -35px;
                width: 120px;
                font-size: 9px;
            }

            .evaluation-content {
                padding: 15px;
                margin: 10px;
            }

            .evaluation-title {
                font-size: 1.3rem;
            }

            .evaluation-score {
                font-size: 2rem;
            }

            .evaluation-message {
                font-size: 0.9rem;
            }
        }

        .hidden {
            display: none;
        }

        .copy-notification {
            position: relative;
            margin-top: 15px;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 500;
            text-align: center;
            opacity: 1;
            transform: translateY(0);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            animation: notificationSlideIn 0.4s ease-out;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .copy-notification.success {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            color: #155724;
            border: 2px solid #c3e6cb;
        }

        .copy-notification.error {
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
            color: #721c24;
            border: 2px solid #f5c6cb;
        }

        @keyframes notificationSlideIn {
            from {
                opacity: 0;
                transform: translateY(10px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .active-tool {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%) !important;
            color: white !important;
            box-shadow: 0 4px 12px rgba(72, 187, 120, 0.4) !important;
            transform: translateY(-1px) !important;
        }

        .active-tool:hover {
            background: linear-gradient(135deg, #38a169 0%, #2f855a 100%) !important;
        }



        .student-title {
            color: #1a1a1a;
            font-size: clamp(1.5rem, 4vw, 2.2rem);
            font-weight: 800;
            margin-bottom: 8px;
            letter-spacing: 0.5px;
            animation: studentTitleGlow 1s ease-out 0.3s both;
            background: linear-gradient(45deg, #1a1a1a 25%, #4a5568 50%, #1a1a1a 75%);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: studentTitleGlow 1s ease-out 0.3s both, shimmerText 3s ease-in-out infinite;
        }

        .student-subtitle {
            color: #64748b;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            font-weight: 500;
            margin: 0;
            animation: studentSubtitleFade 0.8s ease-out 0.5s both;
        }

        .student-subtitle::before {
            content: '📚';
            margin-right: 6px;
            font-size: 0.9em;
        }

        .student-subtitle::after {
            content: '📝';
            margin-left: 6px;
            font-size: 0.9em;
        }

        @keyframes studentTitleFadeIn {
            from { 
                opacity: 0; 
                transform: translateY(-10px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }

        @keyframes studentTitleGlow {
            from { 
                opacity: 0; 
                transform: scale(0.95); 
            }
            to { 
                opacity: 1; 
                transform: scale(1); 
            }
        }

        @keyframes studentSubtitleFade {
            from { 
                opacity: 0; 
                transform: translateY(10px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }

        .student-header {
            text-align: center;
            margin-bottom: 20px;
            margin-top: 30px;
            padding: 15px 20px;
            background: linear-gradient(135deg, #e6fffa 0%, #b2f5ea 100%);
            border-radius: 10px;
            border: 2px solid #4fd1c7;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .assignment-text {
            color: #2d3748;
            font-weight: bold;
            line-height: 1.4;
            word-break: break-word;
            overflow-wrap: break-word;
            white-space: pre-wrap;
            margin: 0;
            padding: 5px 0;
            text-align: center;
        }

        .student-header h2 {
            color: #234e52;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            margin-bottom: 8px;
            font-weight: 600;
            text-align: center;
        }

        .student-header h2 span {
            color: #2d3748;
            font-weight: bold;
        }

        .student-main {
            display: flex;
            gap: 30px;
            height: calc(100vh - 300px);
            min-height: 500px;
        }

        .canvas-section {
            flex: 2;
        }

        .control-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-width: 300px;
        }

        .student-main .canvas-container {
            height: 100%;
            min-height: 400px;
        }

        .student-main .instructions {
            font-size: 1.1rem;
            padding: 15px;
            margin-bottom: 20px;
        }

        .student-main .controls {
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }

        .student-main .controls .btn {
            width: 100%;
            padding: 15px;
            font-size: 1.1rem;
        }

        /* 평가 팝업 스타일 */
        .evaluation-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: popupFadeIn 0.3s ease-out;
        }

        .evaluation-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            animation: popupSlideIn 0.3s ease-out;
        }

        .evaluation-title {
            font-size: 2rem;
            margin-bottom: 20px;
            color: #2d3748;
            font-weight: bold;
        }

        .evaluation-score {
            font-size: 3rem;
            font-weight: bold;
            margin: 20px 0;
        }

        .evaluation-message {
            font-size: 1.2rem;
            margin-bottom: 30px;
            line-height: 1.6;
            color: #4a5568;
        }

        .popup-close-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 12px 30px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .popup-close-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        @keyframes popupFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes popupSlideIn {
            from { 
                opacity: 0; 
                transform: translateY(-30px) scale(0.9); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0) scale(1); 
            }
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">글씨 요정</h1>
            <p class="subtitle">교사와 학생을 위한 바른 글씨 연습 도구</p>
        </div>

        <div class="mode-selector" id="modeSelector">
        </div>

        <!-- 교사 화면 -->
        <div id="teacherScreen" class="screen active">
            <div class="assignment-info" style="padding: 12px; margin-bottom: 20px; margin-top: 2px; max-width: 500px; margin-left: auto; margin-right: auto; text-align: center;">
                <h3 style="font-size: 1.1rem; margin-bottom: 8px;">📝 과제 제작법</h3>
                <p style="font-size: 0.9rem; margin: 0; word-break: keep-all; line-height: 1.4;">학생들이 따라 쓸 글씨를 설정하고 과제 링크를 생성하세요.</p>
            </div>

            <div class="input-section">
                <input type="text" id="teacherTextInput" class="text-input" placeholder="학생들이 따라 쓸 글씨를 입력하세요" value="">
                <button onclick="createAssignment()" class="btn btn-primary">📋 과제 생성</button>
            </div>

            <div style="margin-top: 20px; background: white; border: 2px solid #667eea; border-radius: 10px; padding: 20px;">
                <h3 style="text-align: center; margin-bottom: 15px;">🎯 쓰기 목표</h3>
                <div class="display-text" id="teacherDisplayText">입력된 글씨가 여기에 표시됩니다</div>
            </div>

            <div class="assignment-link" id="assignmentLink" style="display: none;">
                <h3>🔗 과제 배부</h3>
                <p style="margin-bottom: 25px;">과제가 성공적으로 생성되었습니다! 아래 버튼을 클릭하여 과제 링크를 복사하고, 학생들에게 공유하세요😊</p>
                <button onclick="copyLink()" class="btn btn-success">📋 링크 복사</button>
            </div>


        </div>

        <!-- 학생 화면 -->
        <div id="studentScreen" class="screen">
            <div class="student-header">
                <h2>📝 쓰기 목표</h2>
                <div class="assignment-text" id="studentDisplayText">과제를 불러오는 중...</div>
            </div>

            <div class="tool-controls">
                <button id="pencilBtn" onclick="setDrawingMode('pencil')" class="btn btn-primary active-tool">✏️ 연필</button>
                <button id="eraserBtn" onclick="setDrawingMode('eraser')" class="btn btn-secondary">🧽 지우개</button>
            </div>

            <div class="instructions">
                📝 각 칸의 회색 글씨를 정확히 따라 써 보세요! 글씨를 바르게 쓰면 칭찬 메시지가 나타나요😊<br class="mobile-break">
            </div>

            <div class="character-grid" id="characterGrid" style="margin-top: 40px;">
                <!-- 글자별 칸들이 여기에 동적으로 생성됩니다 -->
            </div>

            <div class="controls">
                <button onclick="clearAllCanvas()" class="btn btn-primary" style="flex: 1; min-width: 0;">🗑️ 모두 지우기</button>
                <button onclick="evaluateHandwriting()" class="btn btn-evaluate" style="flex: 1; min-width: 0;">🔍 글씨 평가</button>
                <button onclick="saveResult()" class="btn btn-success" style="flex: 1; min-width: 0;">💾 결과 저장</button>
            </div>


        </div>
    </div>

    <script>
        let currentAssignment = '';
        let characterCanvases = [];
        let characterData = [];
        let currentDrawingMode = 'pencil'; // 'pencil' 또는 'eraser'

        // 그리기 모드 설정
        function setDrawingMode(mode) {
            currentDrawingMode = mode;
            
            // 버튼 스타일 업데이트
            const pencilBtn = document.getElementById('pencilBtn');
            const eraserBtn = document.getElementById('eraserBtn');
            
            if (mode === 'pencil') {
                // 연필 버튼 활성화 (초록색 배경)
                pencilBtn.classList.add('active-tool');
                pencilBtn.classList.remove('btn-secondary');
                pencilBtn.classList.add('btn-primary');
                
                // 지우개 버튼 비활성화 (흰색 배경, 초록 테두리)
                eraserBtn.classList.remove('active-tool');
                eraserBtn.classList.remove('btn-primary');
                eraserBtn.classList.add('btn-secondary');
            } else {
                // 지우개 버튼 활성화 (초록색 배경)
                eraserBtn.classList.add('active-tool');
                eraserBtn.classList.remove('btn-secondary');
                eraserBtn.classList.add('btn-primary');
                
                // 연필 버튼 비활성화 (흰색 배경, 초록 테두리)
                pencilBtn.classList.remove('active-tool');
                pencilBtn.classList.remove('btn-primary');
                pencilBtn.classList.add('btn-secondary');
            }
            
            // 모든 캔버스의 커서 스타일 업데이트
            characterCanvases.forEach(canvasData => {
                if (mode === 'pencil') {
                    canvasData.canvas.style.cursor = 'crosshair';
                } else {
                    canvasData.canvas.style.cursor = 'grab';
                }
            });
        }

        // 글자별 캔버스 생성
        function createCharacterBoxes(text) {
            const grid = document.getElementById('characterGrid');
            grid.innerHTML = '';
            characterCanvases = [];
            characterData = [];

            let boxIndex = 0; // 실제 박스 인덱스
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                // 공백만 건너뛰기 (한글, 영어 대소문자, 숫자, 기호 모두 포함)
                if (char === ' ') {
                    continue;
                }

                const box = document.createElement('div');
                box.className = 'character-box';

                const index = document.createElement('div');
                index.className = 'character-index';
                index.textContent = boxIndex + 1;



                const guide = document.createElement('div');
                guide.className = 'character-guide';
                guide.textContent = char; // 원본 문자 그대로 표시 (대소문자 구분)

                const crosshair = document.createElement('div');
                crosshair.className = 'crosshair-guide';

                const canvas = document.createElement('canvas');
                canvas.className = 'character-canvas';
                canvas.width = 200;
                canvas.height = 200;
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                canvas.style.cursor = 'crosshair'; // 기본 연필 모드

                const indicator = document.createElement('div');
                indicator.className = 'status-indicator red';
                indicator.textContent = evaluationMessages.red[0]; // 초기 메시지 설정

                box.appendChild(index);
                box.appendChild(guide);
                box.appendChild(crosshair);
                box.appendChild(canvas);
                box.appendChild(indicator);
                grid.appendChild(box);

                // 캔버스 설정
                const ctx = canvas.getContext('2d');
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                characterCanvases.push({
                    canvas: canvas,
                    ctx: ctx,
                    char: char,
                    indicator: indicator,
                    isDrawing: false,
                    drawingData: []
                });

                characterData.push({
                    char: char,
                    completed: false
                });

                // 이벤트 리스너 추가
                setupCanvasEvents(canvas, boxIndex);
                boxIndex++; // 박스 인덱스 증가
            }
        }

        // 캔버스 이벤트 설정
        function setupCanvasEvents(canvas, index) {
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;

            function getEventPos(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                let clientX, clientY;
                if (e.touches && e.touches[0]) {
                    // 터치 이벤트의 경우 정확한 터치 포인트 사용
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else if (e.changedTouches && e.changedTouches[0]) {
                    // touchend 이벤트의 경우 changedTouches 사용
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                } else {
                    // 마우스 이벤트
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            }

            function startDrawing(e) {
                e.preventDefault();
                e.stopPropagation(); // 이벤트 전파 방지
                
                // 현재 캔버스가 실제 터치된 캔버스인지 확인
                if (e.target !== canvas) return;
                
                isDrawing = true;
                const pos = getEventPos(e);
                lastX = pos.x;
                lastY = pos.y;
                
                const ctx = characterCanvases[index].ctx;
                
                if (currentDrawingMode === 'pencil') {
                    ctx.globalCompositeOperation = 'source-over';
                    characterCanvases[index].drawingData.push({x: lastX, y: lastY, type: 'start'});
                } else if (currentDrawingMode === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    // 지우개 시작점에서도 지우기
                    ctx.beginPath();
                    ctx.arc(lastX, lastY, 15, 0, 2 * Math.PI);
                    ctx.fill();
                    characterCanvases[index].drawingData.push({x: lastX, y: lastY, type: 'erase_start'});
                }
            }

            function draw(e) {
                if (!isDrawing) return;
                e.preventDefault();
                e.stopPropagation(); // 이벤트 전파 방지
                
                // 현재 캔버스가 실제 터치된 캔버스인지 확인
                if (e.target !== canvas) return;
                
                const pos = getEventPos(e);
                const currentX = pos.x;
                const currentY = pos.y;

                const ctx = characterCanvases[index].ctx;
                
                if (currentDrawingMode === 'pencil') {
                    // 연필 모드: 그리기
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.beginPath();
                    ctx.moveTo(lastX, lastY);
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                    
                    characterCanvases[index].drawingData.push({x: currentX, y: currentY, type: 'draw'});
                } else if (currentDrawingMode === 'eraser') {
                    // 지우개 모드: 지우기
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath();
                    ctx.arc(currentX, currentY, 15, 0, 2 * Math.PI); // 원형 지우개
                    ctx.fill();
                    
                    characterCanvases[index].drawingData.push({x: currentX, y: currentY, type: 'erase'});
                }
                
                lastX = currentX;
                lastY = currentY;

                // 실시간 평가
                evaluateCharacter(index);
            }

            function stopDrawing(e) {
                if (isDrawing) {
                    e.preventDefault();
                    e.stopPropagation(); // 이벤트 전파 방지
                    
                    // 그리기 모드에 따라 다른 종료 타입 기록
                    if (currentDrawingMode === 'pencil') {
                        characterCanvases[index].drawingData.push({type: 'end'});
                    } else {
                        characterCanvases[index].drawingData.push({type: 'erase_end'});
                    }
                    
                    // 컨텍스트를 기본 그리기 모드로 복원
                    const ctx = characterCanvases[index].ctx;
                    ctx.globalCompositeOperation = 'source-over';
                }
                isDrawing = false;
            }

            // 마우스 이벤트
            canvas.addEventListener('mousedown', startDrawing, {passive: false});
            canvas.addEventListener('mousemove', draw, {passive: false});
            canvas.addEventListener('mouseup', stopDrawing, {passive: false});
            canvas.addEventListener('mouseout', stopDrawing, {passive: false});
            
            // 터치 이벤트 (passive: false로 preventDefault 허용)
            canvas.addEventListener('touchstart', startDrawing, {passive: false});
            canvas.addEventListener('touchmove', draw, {passive: false});
            canvas.addEventListener('touchend', stopDrawing, {passive: false});
            canvas.addEventListener('touchcancel', stopDrawing, {passive: false});
        }

        // 화면 전환
        function switchMode(mode) {
            document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));
            
            if (mode === 'teacher') {
                document.getElementById('teacherScreen').classList.add('active');
                document.getElementById('modeSelector').style.display = 'flex';
            } else {
                document.getElementById('studentScreen').classList.add('active');
                document.getElementById('modeSelector').style.display = 'none';
                loadAssignmentFromURL();
            }
        }

        // 교사 기능: 과제 생성
        let generatedLink = '';
        
        // 실시간 텍스트 업데이트
        function updateDisplayText() {
            const text = document.getElementById('teacherTextInput').value || '입력된 글씨가 여기에 표시됩니다';
            const displayElement = document.getElementById('teacherDisplayText');
            displayElement.textContent = text;
            
            // 텍스트 길이에 따라 폰트 크기 자동 조정
            adjustFontSize(displayElement);
        }
        
        // 동적 폰트 크기 조정 함수 (개선된 버전)
        function adjustFontSize(element) {
            const text = element.textContent;
            const textLength = text.length;
            
            // 컨테이너의 실제 사용 가능한 너비 계산
            const containerStyle = window.getComputedStyle(element);
            const paddingLeft = parseFloat(containerStyle.paddingLeft);
            const paddingRight = parseFloat(containerStyle.paddingRight);
            const availableWidth = element.offsetWidth - paddingLeft - paddingRight;
            
            // 임시 측정용 요소 생성
            const measurer = document.createElement('span');
            measurer.style.visibility = 'hidden';
            measurer.style.position = 'absolute';
            measurer.style.whiteSpace = 'nowrap';
            measurer.style.fontFamily = containerStyle.fontFamily;
            measurer.style.fontWeight = containerStyle.fontWeight;
            measurer.textContent = text;
            document.body.appendChild(measurer);
            
            // 적절한 폰트 크기 찾기
            let fontSize = Math.min(40, availableWidth / textLength * 2.5); // 초기 추정값
            let maxFontSize = 40;
            let minFontSize = 12;
            
            // 이진 탐색으로 최적 폰트 크기 찾기
            for (let i = 0; i < 15; i++) {
                measurer.style.fontSize = fontSize + 'px';
                const textWidth = measurer.offsetWidth;
                
                if (textWidth > availableWidth) {
                    maxFontSize = fontSize;
                    fontSize = (minFontSize + fontSize) / 2;
                } else {
                    minFontSize = fontSize;
                    fontSize = (fontSize + maxFontSize) / 2;
                }
                
                // 충분히 정확하면 종료
                if (Math.abs(textWidth - availableWidth) < 10) {
                    break;
                }
            }
            
            // 안전 여백 적용 (95% 크기로)
            fontSize = fontSize * 0.95;
            
            // 최소/최대 크기 제한
            fontSize = Math.max(12, Math.min(40, fontSize));
            
            // 측정용 요소 제거
            document.body.removeChild(measurer);
            
            // 폰트 크기 적용
            element.style.fontSize = fontSize + 'px';
            
            // 레이아웃 설정
            if (textLength > 30 || fontSize < 16) {
                element.style.minHeight = 'auto';
                element.style.height = 'auto';
                element.style.alignItems = 'flex-start';
                element.style.paddingTop = '20px';
                element.style.whiteSpace = 'pre-wrap';
                element.style.wordBreak = 'break-word';
                element.style.lineHeight = '1.3';
            } else {
                element.style.minHeight = '80px';
                element.style.alignItems = 'center';
                element.style.paddingTop = '0';
                element.style.whiteSpace = 'nowrap';
                element.style.wordBreak = 'normal';
                element.style.lineHeight = '1.2';
            }
            
            // 최종 검증 - 여전히 넘어가면 줄바꿈 강제 적용
            setTimeout(() => {
                if (element.scrollWidth > element.offsetWidth) {
                    element.style.whiteSpace = 'pre-wrap';
                    element.style.wordBreak = 'break-word';
                    element.style.alignItems = 'flex-start';
                    element.style.paddingTop = '20px';
                    element.style.lineHeight = '1.3';
                }
            }, 10);
        }
        
        function createAssignment() {
            const text = document.getElementById('teacherTextInput').value.trim();
            if (!text) {
                alert('따라 쓸 글씨를 입력해주세요.');
                return;
            }

            document.getElementById('teacherDisplayText').textContent = text;
            
            // URL에 과제 정보 인코딩
            const assignmentData = btoa(encodeURIComponent(text));
            generatedLink = `${window.location.origin}${window.location.pathname}?assignment=${assignmentData}`;
            
            document.getElementById('assignmentLink').style.display = 'block';
        }

        // 링크 복사
        function copyLink() {
            if (!generatedLink) {
                showCopyNotification('먼저 과제를 생성해주세요.', 'error');
                return;
            }
            
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(generatedLink).then(() => {
                    showCopyNotification('✅ 링크가 클립보드에 복사되었습니다!', 'success');
                }).catch(err => {
                    // 클립보드 API 실패 시 대체 방법
                    fallbackCopyTextToClipboard(generatedLink);
                });
            } else {
                // 클립보드 API를 지원하지 않는 브라우저용 대체 방법
                fallbackCopyTextToClipboard(generatedLink);
            }
        }

        // 클립보드 API 대체 방법
        function fallbackCopyTextToClipboard(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.left = "-999999px";
            textArea.style.top = "-999999px";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showCopyNotification('✅ 링크가 클립보드에 복사되었습니다!', 'success');
                } else {
                    showCopyNotification('❌ 링크 복사에 실패했습니다.', 'error');
                }
            } catch (err) {
                showCopyNotification('❌ 링크 복사에 실패했습니다.', 'error');
            }
            
            document.body.removeChild(textArea);
        }

        // 복사 알림 표시
        function showCopyNotification(message, type) {
            // 기존 알림이 있으면 제거
            const existingNotification = document.querySelector('.copy-notification');
            if (existingNotification) {
                existingNotification.remove();
            }
            
            // 알림 요소 생성
            const notification = document.createElement('div');
            notification.className = `copy-notification ${type}`;
            notification.textContent = message;
            
            // 알림을 링크 복사 버튼 근처에 표시
            const assignmentLink = document.getElementById('assignmentLink');
            assignmentLink.appendChild(notification);
            
            // 3초 후 자동 제거
            setTimeout(() => {
                if (notification && notification.parentNode) {
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateY(-10px)';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, 300);
                }
            }, 3000);
        }



        // 한글 자모 분해 함수
        function decomposeHangul(char) {
            const code = char.charCodeAt(0) - 0xAC00;
            if (code < 0 || code > 11171) return null; // 한글이 아닌 경우
            
            const chosung = Math.floor(code / 588);
            const jungsung = Math.floor((code % 588) / 28);
            const jongsung = code % 28;
            
            const chosungList = ['ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
            const jungsungList = ['ㅏ', 'ㅐ', 'ㅑ', 'ㅒ', 'ㅓ', 'ㅔ', 'ㅕ', 'ㅖ', 'ㅗ', 'ㅘ', 'ㅙ', 'ㅚ', 'ㅛ', 'ㅜ', 'ㅝ', 'ㅞ', 'ㅟ', 'ㅠ', 'ㅡ', 'ㅢ', 'ㅣ'];
            const jongsungList = ['', 'ㄱ', 'ㄲ', 'ㄳ', 'ㄴ', 'ㄵ', 'ㄶ', 'ㄷ', 'ㄹ', 'ㄺ', 'ㄻ', 'ㄼ', 'ㄽ', 'ㄾ', 'ㄿ', 'ㅀ', 'ㅁ', 'ㅂ', 'ㅄ', 'ㅅ', 'ㅆ', 'ㅇ', 'ㅈ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'];
            
            const result = {
                chosung: chosungList[chosung],
                jungsung: jungsungList[jungsung],
                jongsung: jongsungList[jongsung]
            };
            
            return result;
        }

        // 회색 가이드선 형태 일치 기반 엄격한 평가 시스템
        function evaluateCharacter(index) {
            setTimeout(() => {
                const canvasData = characterCanvases[index];
                const char = canvasData.char;
                
                // 최소 그리기 데이터 확인 (완화)
                if (canvasData.drawingData.length < 5) {
                    characterData[index].completed = false;
                    canvasData.indicator.className = 'status-indicator red';
                    return;
                }
                
                // 색칠/휘갈김 패턴 감지 (더 엄격하게)
                if (isScribbleOrFillPattern(canvasData.canvas)) {
                    characterData[index].completed = false;
                    canvasData.indicator.className = 'status-indicator red';
                    return;
                }
                
                // 회색 가이드선과의 형태 일치도 평가 (가장 중요한 기준)
                const guideMatchScore = calculateGuideLineMatchScore(canvasData.canvas, char);
                
                console.log(`글자 "${char}" - 가이드선 일치도: ${guideMatchScore.toFixed(3)}`);
                
                // 회색 가이드선 형태 일치 기준으로만 평가 (완화된 기준)
                let finalEvaluation;
                if (guideMatchScore >= 0.75) {
                    // 가이드선과 75% 이상 일치하면 초록불 (기존 85%에서 완화)
                    finalEvaluation = '초록불';
                } else if (guideMatchScore >= 0.55) {
                    // 가이드선과 55% 이상 일치하면 노란불 (기존 65%에서 완화)
                    finalEvaluation = '노란불';
                } else {
                    // 그 외는 모두 빨간불
                    finalEvaluation = '빨간불';
                }
                
                setIndicatorByEvaluation(canvasData.indicator, characterData[index], finalEvaluation);
                
            }, 50);
        }

        // 회색 가이드선과의 형태 일치도 계산 (핵심 평가 함수)
        function calculateGuideLineMatchScore(canvas, char) {
            const ctx = canvas.getContext('2d');
            
            // 회색 가이드선 형태 생성 (실제 화면에 표시되는 것과 동일)
            const guideCanvas = document.createElement('canvas');
            guideCanvas.width = canvas.width;
            guideCanvas.height = canvas.height;
            const guideCtx = guideCanvas.getContext('2d');
            
            // 회색 가이드선 그리기 (화면과 동일한 스타일)
            guideCtx.font = 'bold 160px Arial';
            guideCtx.fillStyle = '#888888';
            guideCtx.textAlign = 'center';
            guideCtx.textBaseline = 'middle';
            guideCtx.fillText(char, canvas.width / 2, canvas.height / 2);
            
            // 사용자 그림과 가이드선 이미지 데이터 가져오기
            const userImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const guideImageData = guideCtx.getImageData(0, 0, canvas.width, canvas.height);
            
            let matchingPixels = 0;
            let totalGuidePixels = 0;
            let userPixelsOnGuide = 0;
            let totalUserPixels = 0;
            
            // 픽셀별 비교
            for (let i = 0; i < guideImageData.data.length; i += 4) {
                const guideAlpha = guideImageData.data[i + 3];
                const userAlpha = userImageData.data[i + 3];
                
                if (userAlpha > 0) {
                    totalUserPixels++;
                }
                
                if (guideAlpha > 0) {
                    totalGuidePixels++;
                    
                    // 가이드선 위치에서 사용자 획 확인 (허용 오차 범위 내)
                    const pixelIndex = i / 4;
                    const x = pixelIndex % canvas.width;
                    const y = Math.floor(pixelIndex / canvas.width);
                    
                    if (isUserStrokeNearGuidePixel(userImageData, x, y, canvas.width, canvas.height, 8)) {
                        matchingPixels++;
                    }
                }
                
                // 사용자가 가이드선 근처에 그렸는지 확인
                if (userAlpha > 0) {
                    const pixelIndex = i / 4;
                    const x = pixelIndex % canvas.width;
                    const y = Math.floor(pixelIndex / canvas.width);
                    
                    if (isGuidePixelNearUserStroke(guideImageData, x, y, canvas.width, canvas.height, 8)) {
                        userPixelsOnGuide++;
                    }
                }
            }
            
            // 가이드선 커버리지 (가이드선의 몇 %를 따라 그렸는가)
            const guideCoverage = totalGuidePixels > 0 ? matchingPixels / totalGuidePixels : 0;
            
            // 정확도 (사용자가 그린 것 중 가이드선 근처에 있는 비율)
            const accuracy = totalUserPixels > 0 ? userPixelsOnGuide / totalUserPixels : 0;
            
            // 종합 점수 (커버리지 70%, 정확도 30%)
            const finalScore = (guideCoverage * 0.7) + (accuracy * 0.3);
            
            console.log(`가이드 커버리지: ${(guideCoverage * 100).toFixed(1)}%, 정확도: ${(accuracy * 100).toFixed(1)}%`);
            
            return finalScore;
        }
        
        // 가이드선 픽셀 근처에 사용자 획이 있는지 확인
        function isUserStrokeNearGuidePixel(userImageData, x, y, width, height, tolerance) {
            for (let dx = -tolerance; dx <= tolerance; dx++) {
                for (let dy = -tolerance; dy <= tolerance; dy++) {
                    const checkX = x + dx;
                    const checkY = y + dy;
                    
                    if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height) {
                        const index = (checkY * width + checkX) * 4;
                        if (userImageData.data[index + 3] > 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        // 사용자 획 근처에 가이드선 픽셀이 있는지 확인
        function isGuidePixelNearUserStroke(guideImageData, x, y, width, height, tolerance) {
            for (let dx = -tolerance; dx <= tolerance; dx++) {
                for (let dy = -tolerance; dy <= tolerance; dy++) {
                    const checkX = x + dx;
                    const checkY = y + dy;
                    
                    if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height) {
                        const index = (checkY * width + checkX) * 4;
                        if (guideImageData.data[index + 3] > 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // 색칠/휘갈김 패턴 감지 (휘갈김 감지만 더 엄격하게)
        function isScribbleOrFillPattern(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            let totalPixels = 0;
            let filledPixels = 0;
            let edgePixels = 0;
            
            // 픽셀 분석
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const index = (y * canvas.width + x) * 4;
                    totalPixels++;
                    
                    if (imageData.data[index + 3] > 0) {
                        filledPixels++;
                        
                        // 가장자리 픽셀인지 확인
                        if (isEdgePixel(imageData, x, y, canvas.width, canvas.height)) {
                            edgePixels++;
                        }
                    }
                }
            }
            
            const fillRatio = filledPixels / totalPixels;
            const edgeRatio = edgePixels / Math.max(filledPixels, 1);
            
            // 색칠 패턴: 전체 영역의 15% 이상이 채워지고 가장자리 비율이 낮음 (기존 유지)
            if (fillRatio > 0.15 && edgeRatio < 0.20) {
                return true;
            }
            
            // 휘갈김 패턴: 연속성이 없는 무작위 점들 (더 엄격하게)
            if (fillRatio > 0.03 && hasRandomScribblePattern(imageData, canvas.width, canvas.height)) {
                return true;
            }
            
            // 가이드선과 전혀 일치하지 않는 패턴 감지 (더 엄격하게)
            const char = characterCanvases.find(c => c.canvas === canvas)?.char;
            if (char) {
                const guideMatchScore = calculateGuideLineMatchScore(canvas, char);
                if (guideMatchScore < 0.20) { // 가이드선과 20% 미만 일치하면 휘갈김으로 간주 (더 엄격하게)
                    return true;
                }
            }
            
            // 추가 휘갈김 패턴 감지: 너무 많은 방향 변화
            if (hasExcessiveDirectionChanges(imageData, canvas.width, canvas.height)) {
                return true;
            }
            
            // 추가 휘갈김 패턴 감지: 불규칙한 밀도 분포
            if (hasIrregularDensityDistribution(imageData, canvas.width, canvas.height)) {
                return true;
            }
            
            return false;
        }
        
        // 가장자리 픽셀 확인
        function isEdgePixel(imageData, x, y, width, height) {
            const directions = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];
            
            for (let [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    const index = (ny * width + nx) * 4;
                    if (imageData.data[index + 3] === 0) {
                        return true; // 인접한 빈 픽셀이 있으면 가장자리
                    }
                }
            }
            return false;
        }
        
        // 무작위 휘갈김 패턴 감지 (더 엄격하게)
        function hasRandomScribblePattern(imageData, width, height) {
            let isolatedPixelGroups = 0;
            let totalGroups = 0;
            const visited = new Array(width * height).fill(false);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = (y * width + x) * 4;
                    const pixelIndex = y * width + x;
                    
                    if (imageData.data[index + 3] > 0 && !visited[pixelIndex]) {
                        const groupSize = floodFillCount(imageData, visited, x, y, width, height);
                        totalGroups++;
                        
                        if (groupSize < 15) { // 작은 고립된 그룹 기준 강화
                            isolatedPixelGroups++;
                        }
                    }
                }
            }
            
            // 고립된 작은 그룹이 많으면 휘갈김으로 판단 (더 엄격한 기준)
            const isolationRatio = totalGroups > 0 ? isolatedPixelGroups / totalGroups : 0;
            return isolatedPixelGroups > 3 || isolationRatio > 0.6;
        }
        
        // 연결된 픽셀 그룹 크기 계산
        function floodFillCount(imageData, visited, startX, startY, width, height) {
            const stack = [[startX, startY]];
            let count = 0;
            
            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const pixelIndex = y * width + x;
                
                if (x < 0 || x >= width || y < 0 || y >= height || visited[pixelIndex]) {
                    continue;
                }
                
                const index = (y * width + x) * 4;
                if (imageData.data[index + 3] === 0) {
                    continue;
                }
                
                visited[pixelIndex] = true;
                count++;
                
                // 8방향 탐색
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx !== 0 || dy !== 0) {
                            stack.push([x + dx, y + dy]);
                        }
                    }
                }
            }
            
            return count;
        }

        // 과도한 방향 변화 감지 (새로운 휘갈김 감지 기준)
        function hasExcessiveDirectionChanges(imageData, width, height) {
            const strokePoints = [];
            
            // 그려진 픽셀들의 좌표 수집
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = (y * width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        strokePoints.push({x, y});
                    }
                }
            }
            
            if (strokePoints.length < 20) return false;
            
            // 연속된 점들 사이의 방향 변화 계산
            let directionChanges = 0;
            let previousDirection = null;
            
            for (let i = 1; i < Math.min(strokePoints.length, 100); i += 2) {
                const current = strokePoints[i];
                const previous = strokePoints[i - 1];
                
                const dx = current.x - previous.x;
                const dy = current.y - previous.y;
                
                if (dx === 0 && dy === 0) continue;
                
                const currentDirection = Math.atan2(dy, dx);
                
                if (previousDirection !== null) {
                    let angleDiff = Math.abs(currentDirection - previousDirection);
                    if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                    
                    // 45도 이상의 급격한 방향 변화
                    if (angleDiff > Math.PI / 4) {
                        directionChanges++;
                    }
                }
                
                previousDirection = currentDirection;
            }
            
            // 방향 변화가 너무 많으면 휘갈김으로 판단
            const changeRatio = directionChanges / Math.min(strokePoints.length / 2, 50);
            return changeRatio > 0.4;
        }

        // 불규칙한 밀도 분포 감지 (새로운 휘갈김 감지 기준)
        function hasIrregularDensityDistribution(imageData, width, height) {
            const gridSize = 20; // 20x20 픽셀 단위로 나누어 검사
            const gridWidth = Math.ceil(width / gridSize);
            const gridHeight = Math.ceil(height / gridSize);
            const densityGrid = new Array(gridWidth * gridHeight).fill(0);
            
            // 각 그리드 셀의 픽셀 밀도 계산
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = (y * width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        const gridX = Math.floor(x / gridSize);
                        const gridY = Math.floor(y / gridSize);
                        const gridIndex = gridY * gridWidth + gridX;
                        densityGrid[gridIndex]++;
                    }
                }
            }
            
            // 밀도가 있는 셀들만 필터링
            const nonEmptyCells = densityGrid.filter(density => density > 0);
            if (nonEmptyCells.length < 3) return false;
            
            // 밀도의 표준편차 계산
            const mean = nonEmptyCells.reduce((sum, density) => sum + density, 0) / nonEmptyCells.length;
            const variance = nonEmptyCells.reduce((sum, density) => sum + Math.pow(density - mean, 2), 0) / nonEmptyCells.length;
            const standardDeviation = Math.sqrt(variance);
            
            // 표준편차가 평균의 80% 이상이면 불규칙한 분포로 판단
            const coefficientOfVariation = standardDeviation / mean;
            return coefficientOfVariation > 0.8;
        }

        // 자모 구성요소 존재 여부 확인 (구조적 평가)
        function checkJamoComponentExists(canvas, fullChar, jamo, position) {
            const ctx = canvas.getContext('2d');
            
            // 자모 영역 정의
            const jamoRegion = getJamoRegion(canvas.width, canvas.height, position);
            
            // 사용자 그림 데이터 가져오기
            const userImageData = ctx.getImageData(jamoRegion.x, jamoRegion.y, jamoRegion.width, jamoRegion.height);
            
            // 자모별 구성요소 존재 확인
            return checkJamoComponentsExist(userImageData, jamo, jamoRegion);
        }

        // 자모 구조적 평가 (0.0 ~ 1.0 점수 반환)
        function evaluateJamoStructure(canvas, fullChar, jamo, position) {
            const ctx = canvas.getContext('2d');
            const jamoRegion = getJamoRegion(canvas.width, canvas.height, position);
            const userImageData = ctx.getImageData(jamoRegion.x, jamoRegion.y, jamoRegion.width, jamoRegion.height);
            
            // 기본 구조 확인
            const hasBasicStructure = checkJamoBasicStructure(userImageData, jamo, jamoRegion);
            if (!hasBasicStructure) return 0.0;
            
            // 형태 정확도 평가
            const shapeAccuracy = evaluateJamoShapeAccuracy(userImageData, jamo, jamoRegion);
            
            // 위치 정확도 평가
            const positionAccuracy = evaluateJamoPositionAccuracy(userImageData, jamo, jamoRegion);
            
            // 종합 점수 (구조 50%, 형태 30%, 위치 20%)
            return (hasBasicStructure ? 0.5 : 0) + (shapeAccuracy * 0.3) + (positionAccuracy * 0.2);
        }
        
        // 자모 기본 구조 확인
        function checkJamoBasicStructure(imageData, jamo, region) {
            switch (jamo) {
                case 'ㄱ': return checkAngleStructure(imageData, region);
                case 'ㄴ': return checkLShapeStructure(imageData, region);
                case 'ㄷ': return checkCapStructure(imageData, region);
                case 'ㄹ': return checkComplexStructure(imageData, region, 2);
                case 'ㅁ': return checkRectangleStructure(imageData, region);
                case 'ㅂ': return checkVerticalWithHorizontalsStructure(imageData, region);
                case 'ㅅ': return checkVShapeStructure(imageData, region);
                case 'ㅇ': return checkCircleStructure(imageData, region);
                case 'ㅈ': return checkVWithHorizontalStructure(imageData, region);
                case 'ㅊ': return checkVWithHorizontalsStructure(imageData, region);
                case 'ㅋ': return checkVerticalWithRightStrokesStructure(imageData, region);
                case 'ㅌ': return checkCapWithVerticalStructure(imageData, region);
                case 'ㅍ': return checkRectangleWithVerticalStructure(imageData, region);
                case 'ㅎ': return checkCircleWithHorizontalStructure(imageData, region);
                
                case 'ㅏ': return checkVerticalWithRightHorizontalStructure(imageData, region);
                case 'ㅓ': return checkVerticalWithLeftHorizontalStructure(imageData, region);
                case 'ㅗ': return checkHorizontalWithDownVerticalStructure(imageData, region);
                case 'ㅜ': return checkHorizontalWithUpVerticalStructure(imageData, region);
                case 'ㅡ': return checkHorizontalStructure(imageData, region);
                case 'ㅣ': return checkVerticalStructure(imageData, region);
                case 'ㅑ': return checkVerticalWithTwoRightHorizontalsStructure(imageData, region);
                case 'ㅕ': return checkVerticalWithTwoLeftHorizontalsStructure(imageData, region);
                case 'ㅛ': return checkHorizontalWithTwoDownVerticalsStructure(imageData, region);
                case 'ㅠ': return checkHorizontalWithTwoUpVerticalsStructure(imageData, region);
                
                default:
                    return checkBasicStrokeStructure(imageData, region);
            }
        }
        
        // 자모 형태 정확도 평가
        function evaluateJamoShapeAccuracy(imageData, jamo, region) {
            // 기준 형태와의 유사도 계산
            const referenceShape = generateReferenceShape(jamo, region);
            return calculateShapeSimilarity(imageData, referenceShape, region);
        }
        
        // 자모 위치 정확도 평가
        function evaluateJamoPositionAccuracy(imageData, jamo, region) {
            const centerOfMass = calculateCenterOfMass(imageData, region);
            const expectedCenter = getExpectedJamoCenter(jamo, region);
            
            const distance = Math.sqrt(
                Math.pow(centerOfMass.x - expectedCenter.x, 2) + 
                Math.pow(centerOfMass.y - expectedCenter.y, 2)
            );
            
            const maxDistance = Math.sqrt(region.width * region.width + region.height * region.height) / 4;
            return Math.max(0, 1 - (distance / maxDistance));
        }
        
        // 전체 글자 구조 평가
        function evaluateOverallCharacterStructure(canvas, char) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // 글자 전체 윤곽 평가
            const contourScore = evaluateCharacterContour(imageData, char, canvas.width, canvas.height);
            
            // 글자 비율 평가
            const proportionScore = evaluateCharacterProportion(imageData, char, canvas.width, canvas.height);
            
            // 글자 연결성 평가
            const connectivityScore = evaluateCharacterConnectivity(imageData, canvas.width, canvas.height);
            
            return (contourScore * 0.5) + (proportionScore * 0.3) + (connectivityScore * 0.2);
        }
        
        // 한글이 아닌 문자 구조 평가
        function evaluateNonHangulStructure(canvas, char) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // 기본 형태 확인
            const hasBasicShape = checkNonHangulBasicShape(imageData, char, canvas.width, canvas.height);
            if (!hasBasicShape) return '빨간불';
            
            // 형태 정확도
            const shapeAccuracy = calculateNonHangulShapeAccuracy(imageData, char, canvas.width, canvas.height);
            
            if (shapeAccuracy >= 0.7) return '초록불';
            else if (shapeAccuracy >= 0.4) return '노란불';
            else return '빨간불';
        }
        
        // 평가 결과에 따른 표시등 설정
        function setIndicatorByEvaluation(indicator, characterData, evaluation) {
            switch (evaluation) {
                case '초록불':
                    characterData.completed = true;
                    indicator.className = 'status-indicator green';
                    break;
                case '노란불':
                    characterData.completed = false;
                    indicator.className = 'status-indicator yellow';
                    break;
                case '빨간불':
                default:
                    characterData.completed = false;
                    indicator.className = 'status-indicator red';
                    break;
            }
        }

        // 모든 획이 완전히 그려졌는지 확인하는 엄격한 검사
        function checkAllStrokesComplete(canvas, fullChar, jamo, position) {
            const ctx = canvas.getContext('2d');
            const jamoRegion = getJamoRegion(canvas.width, canvas.height, position);
            const userImageData = ctx.getImageData(jamoRegion.x, jamoRegion.y, jamoRegion.width, jamoRegion.height);
            
            switch (jamo) {
                case 'ㄱ': return checkAngleStrokeComplete(userImageData, jamoRegion);
                case 'ㄴ': return checkLShapeStrokeComplete(userImageData, jamoRegion);
                case 'ㄷ': return checkCapStrokeComplete(userImageData, jamoRegion);
                case 'ㄹ': return checkRieulStrokeComplete(userImageData, jamoRegion);
                case 'ㅁ': return checkRectangleStrokeComplete(userImageData, jamoRegion);
                case 'ㅂ': return checkBieupStrokeComplete(userImageData, jamoRegion);
                case 'ㅅ': return checkSiotStrokeComplete(userImageData, jamoRegion);
                case 'ㅇ': return checkIeungStrokeComplete(userImageData, jamoRegion);
                case 'ㅈ': return checkJieupStrokeComplete(userImageData, jamoRegion);
                case 'ㅊ': return checkChieuchStrokeComplete(userImageData, jamoRegion);
                case 'ㅋ': return checkKieukStrokeComplete(userImageData, jamoRegion);
                case 'ㅌ': return checkTieutStrokeComplete(userImageData, jamoRegion);
                case 'ㅍ': return checkPieupStrokeComplete(userImageData, jamoRegion);
                case 'ㅎ': return checkHieuhStrokeComplete(userImageData, jamoRegion);
                
                case 'ㅏ': return checkAStrokeComplete(userImageData, jamoRegion);
                case 'ㅓ': return checkEoStrokeComplete(userImageData, jamoRegion);
                case 'ㅗ': return checkOStrokeComplete(userImageData, jamoRegion);
                case 'ㅜ': return checkUStrokeComplete(userImageData, jamoRegion);
                case 'ㅡ': return checkEuStrokeComplete(userImageData, jamoRegion);
                case 'ㅣ': return checkIStrokeComplete(userImageData, jamoRegion);
                case 'ㅑ': return checkYaStrokeComplete(userImageData, jamoRegion);
                case 'ㅕ': return checkYeoStrokeComplete(userImageData, jamoRegion);
                case 'ㅛ': return checkYoStrokeComplete(userImageData, jamoRegion);
                case 'ㅠ': return checkYuStrokeComplete(userImageData, jamoRegion);
                
                default:
                    return checkCompleteStrokeExists(userImageData, jamoRegion);
            }
        }

        // 완전한 획 존재 확인 (엄격한 기준)
        function checkCompleteStrokeExists(imageData, region) {
            let strokePixels = 0;
            const minStrokePixels = Math.max(20, region.width * region.height * 0.05); // 최소 5%의 픽셀
            
            for (let i = 0; i < imageData.data.length; i += 4) {
                if (imageData.data[i + 3] > 0) {
                    strokePixels++;
                }
            }
            return strokePixels >= minStrokePixels;
        }

        // ㄱ: 가로선 + 세로선 모두 필요
        function checkAngleStrokeComplete(imageData, region) {
            return checkHorizontalStrokeStrict(imageData, region) && checkVerticalStrokeStrict(imageData, region);
        }

        // ㄴ: 세로선 + 가로선 모두 필요
        function checkLShapeStrokeComplete(imageData, region) {
            return checkVerticalStrokeStrict(imageData, region) && checkHorizontalStrokeStrict(imageData, region);
        }

        // ㄷ: 위쪽 가로선 + 양쪽 세로선 필요
        function checkCapStrokeComplete(imageData, region) {
            return checkHorizontalStrokeStrict(imageData, region) && 
                   checkVerticalInRegionStrict(imageData, region, 0.0, 0.3, 0.0, 0.7) &&
                   checkVerticalInRegionStrict(imageData, region, 0.7, 1.0, 0.0, 0.7);
        }

        // ㄹ: 복잡한 형태 - 여러 획 필요
        function checkRieulStrokeComplete(imageData, region) {
            return checkHorizontalStrokeStrict(imageData, region) && 
                   checkVerticalStrokeStrict(imageData, region) &&
                   checkCompleteStrokeExists(imageData, region);
        }

        // ㅁ: 사각형 - 4면 모두 필요
        function checkRectangleStrokeComplete(imageData, region) {
            return checkHorizontalInRegionStrict(imageData, region, 0.1, 0.9, 0.0, 0.2) && // 위
                   checkHorizontalInRegionStrict(imageData, region, 0.1, 0.9, 0.8, 1.0) && // 아래
                   checkVerticalInRegionStrict(imageData, region, 0.0, 0.2, 0.1, 0.9) &&   // 왼쪽
                   checkVerticalInRegionStrict(imageData, region, 0.8, 1.0, 0.1, 0.9);     // 오른쪽
        }

        // ㅂ: 세로선 + 두 개의 가로선
        function checkBieupStrokeComplete(imageData, region) {
            return checkVerticalStrokeStrict(imageData, region) &&
                   checkHorizontalInRegionStrict(imageData, region, 0.2, 0.8, 0.2, 0.4) &&
                   checkHorizontalInRegionStrict(imageData, region, 0.2, 0.8, 0.6, 0.8);
        }

        // ㅅ: 두 개의 대각선
        function checkSiotStrokeComplete(imageData, region) {
            return checkDiagonalStrokeExists(imageData, region, 'left') && 
                   checkDiagonalStrokeExists(imageData, region, 'right');
        }

        // ㅇ: 원형
        function checkIeungStrokeComplete(imageData, region) {
            return checkCircularStrokeExists(imageData, region);
        }

        // ㅈ: ㅅ + 가로선
        function checkJieupStrokeComplete(imageData, region) {
            return checkSiotStrokeComplete(imageData, region) && 
                   checkHorizontalInRegionStrict(imageData, region, 0.2, 0.8, 0.8, 1.0);
        }

        // ㅊ: ㅈ + 추가 가로선
        function checkChieuchStrokeComplete(imageData, region) {
            return checkJieupStrokeComplete(imageData, region) && 
                   checkHorizontalInRegionStrict(imageData, region, 0.2, 0.8, 0.0, 0.2);
        }

        // ㅋ: 세로선 + 두 개의 오른쪽 가로선
        function checkKieukStrokeComplete(imageData, region) {
            return checkVerticalStrokeStrict(imageData, region) &&
                   checkHorizontalInRegionStrict(imageData, region, 0.5, 0.9, 0.2, 0.4) &&
                   checkHorizontalInRegionStrict(imageData, region, 0.5, 0.9, 0.6, 0.8);
        }

        // ㅌ: ㄷ + 세로선
        function checkTieutStrokeComplete(imageData, region) {
            return checkCapStrokeComplete(imageData, region) && 
                   checkVerticalInRegionStrict(imageData, region, 0.4, 0.6, 0.3, 0.8);
        }

        // ㅍ: ㅁ + 세로선
        function checkPieupStrokeComplete(imageData, region) {
            return checkRectangleStrokeComplete(imageData, region) && 
                   checkVerticalInRegionStrict(imageData, region, 0.4, 0.6, 0.3, 0.7);
        }

        // ㅎ: ㅇ + 가로선
        function checkHieuhStrokeComplete(imageData, region) {
            return checkIeungStrokeComplete(imageData, region) && 
                   checkHorizontalInRegionStrict(imageData, region, 0.2, 0.8, 0.4, 0.6);
        }

        // ㅏ: 세로선 + 오른쪽 가로선
        function checkAStrokeComplete(imageData, region) {
            return checkVerticalStrokeStrict(imageData, region) && 
                   checkHorizontalInRegionStrict(imageData, region, 0.5, 0.9, 0.4, 0.6);
        }

        // ㅓ: 세로선 + 왼쪽 가로선
        function checkEoStrokeComplete(imageData, region) {
            return checkVerticalStrokeStrict(imageData, region) && 
                   checkHorizontalInRegionStrict(imageData, region, 0.1, 0.5, 0.4, 0.6);
        }

        // ㅗ: 가로선 + 아래 세로선
        function checkOStrokeComplete(imageData, region) {
            return checkHorizontalStrokeStrict(imageData, region) && 
                   checkVerticalInRegionStrict(imageData, region, 0.4, 0.6, 0.5, 0.9);
        }

        // ㅜ: 가로선 + 위 세로선
        function checkUStrokeComplete(imageData, region) {
            return checkHorizontalStrokeStrict(imageData, region) && 
                   checkVerticalInRegionStrict(imageData, region, 0.4, 0.6, 0.1, 0.5);
        }

        // ㅡ: 가로선
        function checkEuStrokeComplete(imageData, region) {
            return checkHorizontalStrokeStrict(imageData, region);
        }

        // ㅣ: 세로선
        function checkIStrokeComplete(imageData, region) {
            return checkVerticalStrokeStrict(imageData, region);
        }

        // ㅑ: 세로선 + 두 개의 오른쪽 가로선
        function checkYaStrokeComplete(imageData, region) {
            return checkVerticalStrokeStrict(imageData, region) && 
                   checkHorizontalInRegionStrict(imageData, region, 0.5, 0.9, 0.3, 0.4) &&
                   checkHorizontalInRegionStrict(imageData, region, 0.5, 0.9, 0.6, 0.7);
        }

        // ㅕ: 세로선 + 두 개의 왼쪽 가로선
        function checkYeoStrokeComplete(imageData, region) {
            return checkVerticalStrokeStrict(imageData, region) && 
                   checkHorizontalInRegionStrict(imageData, region, 0.1, 0.5, 0.3, 0.4) &&
                   checkHorizontalInRegionStrict(imageData, region, 0.1, 0.5, 0.6, 0.7);
        }

        // ㅛ: 가로선 + 두 개의 아래 세로선
        function checkYoStrokeComplete(imageData, region) {
            return checkHorizontalStrokeStrict(imageData, region) && 
                   checkVerticalInRegionStrict(imageData, region, 0.3, 0.4, 0.5, 0.9) &&
                   checkVerticalInRegionStrict(imageData, region, 0.6, 0.7, 0.5, 0.9);
        }

        // ㅠ: 가로선 + 두 개의 위 세로선
        function checkYuStrokeComplete(imageData, region) {
            return checkHorizontalStrokeStrict(imageData, region) && 
                   checkVerticalInRegionStrict(imageData, region, 0.3, 0.4, 0.1, 0.5) &&
                   checkVerticalInRegionStrict(imageData, region, 0.6, 0.7, 0.1, 0.5);
        }

        // 엄격한 세로선 확인 (가이드선 영역 내 인식 개선)
        function checkVerticalStrokeStrict(imageData, region) {
            const centerX = Math.floor(region.width / 2);
            const tolerance = Math.max(10, Math.floor(region.width * 0.3)); // 허용 범위 더 확대
            let verticalPixels = 0;
            const minVerticalPixels = Math.floor(region.height * 0.25); // 25%로 더 완화
            
            for (let y = 0; y < region.height; y++) {
                let foundInRow = false;
                for (let x = centerX - tolerance; x <= centerX + tolerance; x++) {
                    if (x >= 0 && x < region.width) {
                        const index = (y * region.width + x) * 4;
                        if (imageData.data[index + 3] > 0) {
                            foundInRow = true;
                            break;
                        }
                    }
                }
                if (foundInRow) verticalPixels++;
            }
            return verticalPixels >= minVerticalPixels;
        }

        // 엄격한 가로선 확인 (가이드선 영역 내 인식 개선)
        function checkHorizontalStrokeStrict(imageData, region) {
            const centerY = Math.floor(region.height / 2);
            const tolerance = Math.max(10, Math.floor(region.height * 0.3)); // 허용 범위 더 확대
            let horizontalPixels = 0;
            const minHorizontalPixels = Math.floor(region.width * 0.25); // 25%로 더 완화
            
            for (let x = 0; x < region.width; x++) {
                let foundInCol = false;
                for (let y = centerY - tolerance; y <= centerY + tolerance; y++) {
                    if (y >= 0 && y < region.height) {
                        const index = (y * region.width + x) * 4;
                        if (imageData.data[index + 3] > 0) {
                            foundInCol = true;
                            break;
                        }
                    }
                }
                if (foundInCol) horizontalPixels++;
            }
            return horizontalPixels >= minHorizontalPixels;
        }

        // 특정 영역에서 엄격한 가로선 확인 (가이드선 영역 내 인식 개선)
        function checkHorizontalInRegionStrict(imageData, region, xStart, xEnd, yStart, yEnd) {
            const startX = Math.floor(region.width * xStart);
            const endX = Math.floor(region.width * xEnd);
            const startY = Math.floor(region.height * yStart);
            const endY = Math.floor(region.height * yEnd);
            
            let horizontalPixels = 0;
            const minPixels = Math.floor((endX - startX) * 0.3); // 30%로 완화
            
            // 각 행에서 픽셀이 있는지 확인
            for (let y = startY; y < endY; y++) {
                let foundInRow = false;
                for (let x = startX; x < endX; x++) {
                    const index = (y * region.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        foundInRow = true;
                        break;
                    }
                }
                if (foundInRow) horizontalPixels++;
            }
            
            // 최소 행 수에서 픽셀이 발견되면 성공
            const minRows = Math.max(1, Math.floor((endY - startY) * 0.2));
            return horizontalPixels >= minRows;
        }

        // 특정 영역에서 엄격한 세로선 확인 (가이드선 영역 내 인식 개선)
        function checkVerticalInRegionStrict(imageData, region, xStart, xEnd, yStart, yEnd) {
            const startX = Math.floor(region.width * xStart);
            const endX = Math.floor(region.width * xEnd);
            const startY = Math.floor(region.height * yStart);
            const endY = Math.floor(region.height * yEnd);
            
            let verticalPixels = 0;
            const minPixels = Math.floor((endY - startY) * 0.3); // 30%로 완화
            
            // 각 열에서 픽셀이 있는지 확인
            for (let x = startX; x < endX; x++) {
                let foundInCol = false;
                for (let y = startY; y < endY; y++) {
                    const index = (y * region.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        foundInCol = true;
                        break;
                    }
                }
                if (foundInCol) verticalPixels++;
            }
            
            // 최소 열 수에서 픽셀이 발견되면 성공
            const minCols = Math.max(1, Math.floor((endX - startX) * 0.2));
            return verticalPixels >= minCols;
        }

        // 대각선 확인 (가이드선 영역 내 인식 개선)
        function checkDiagonalStrokeExists(imageData, region, direction) {
            let diagonalPixels = 0;
            const minPixels = Math.floor(Math.min(region.width, region.height) * 0.1); // 10%로 완화
            const tolerance = 12; // 허용 범위 더 확대
            
            if (direction === 'left') {
                // 왼쪽 위에서 오른쪽 아래로
                for (let i = 0; i < Math.min(region.width, region.height); i++) {
                    const centerX = Math.floor(i * 0.7);
                    const centerY = Math.floor(i * 0.8);
                    
                    let foundInArea = false;
                    for (let dx = -tolerance; dx <= tolerance; dx++) {
                        for (let dy = -tolerance; dy <= tolerance; dy++) {
                            const x = centerX + dx;
                            const y = centerY + dy;
                            if (x >= 0 && x < region.width && y >= 0 && y < region.height) {
                                const index = (y * region.width + x) * 4;
                                if (imageData.data[index + 3] > 0) {
                                    foundInArea = true;
                                    break;
                                }
                            }
                        }
                        if (foundInArea) break;
                    }
                    if (foundInArea) diagonalPixels++;
                }
            } else {
                // 오른쪽 위에서 왼쪽 아래로
                for (let i = 0; i < Math.min(region.width, region.height); i++) {
                    const centerX = Math.floor(region.width - i * 0.7);
                    const centerY = Math.floor(i * 0.8);
                    
                    let foundInArea = false;
                    for (let dx = -tolerance; dx <= tolerance; dx++) {
                        for (let dy = -tolerance; dy <= tolerance; dy++) {
                            const x = centerX + dx;
                            const y = centerY + dy;
                            if (x >= 0 && x < region.width && y >= 0 && y < region.height) {
                                const index = (y * region.width + x) * 4;
                                if (imageData.data[index + 3] > 0) {
                                    foundInArea = true;
                                    break;
                                }
                            }
                        }
                        if (foundInArea) break;
                    }
                    if (foundInArea) diagonalPixels++;
                }
            }
            
            return diagonalPixels >= minPixels;
        }

        // 원형 확인 (가이드선 영역 내 인식 개선)
        function checkCircularStrokeExists(imageData, region) {
            const centerX = Math.floor(region.width / 2);
            const centerY = Math.floor(region.height / 2);
            const radius = Math.min(region.width, region.height) * 0.3;
            let circularPixels = 0;
            const minPixels = Math.floor(radius * 2 * Math.PI * 0.15); // 원둘레의 15%로 완화
            const tolerance = 12; // 허용 범위 더 확대
            
            // 원 둘레를 따라 픽셀 확인
            for (let angle = 0; angle < 360; angle += 15) { // 간격 더 확대
                const radian = (angle * Math.PI) / 180;
                const centerPointX = Math.floor(centerX + radius * Math.cos(radian));
                const centerPointY = Math.floor(centerY + radius * Math.sin(radian));
                
                // 주변 영역에서 픽셀 확인
                let foundInArea = false;
                for (let dx = -tolerance; dx <= tolerance; dx++) {
                    for (let dy = -tolerance; dy <= tolerance; dy++) {
                        const checkX = centerPointX + dx;
                        const checkY = centerPointY + dy;
                        if (checkX >= 0 && checkX < region.width && checkY >= 0 && checkY < region.height) {
                            const index = (checkY * region.width + checkX) * 4;
                            if (imageData.data[index + 3] > 0) {
                                foundInArea = true;
                                break;
                            }
                        }
                    }
                    if (foundInArea) break;
                }
                if (foundInArea) circularPixels++;
            }
            
            return circularPixels >= minPixels;
        }

        // 자모의 구성요소 존재 여부 검사 (회색 가이드선 영역 내에서만 인정)
        function checkJamoComponentsExist(userImageData, jamo, region) {
            // 먼저 회색 가이드선 영역 내에 충분한 획이 있는지 확인
            if (!checkStrokeInGuideArea(userImageData, region)) {
                return false;
            }
            
            switch (jamo) {
                case 'ㄱ': return checkAngleStrokeInGuide(userImageData, region);
                case 'ㄴ': return checkLShapeStrokeInGuide(userImageData, region);
                case 'ㄷ': return checkCapStrokeInGuide(userImageData, region);
                case 'ㄹ': return checkComplexStrokeInGuide(userImageData, region, 3);
                case 'ㅁ': return checkRectangleStrokeInGuide(userImageData, region);
                case 'ㅂ': return checkVerticalWithHorizontalsInGuide(userImageData, region);
                case 'ㅅ': return checkVShapeStrokeInGuide(userImageData, region);
                case 'ㅇ': return checkCircleStrokeInGuide(userImageData, region);
                case 'ㅈ': return checkVWithHorizontalInGuide(userImageData, region);
                case 'ㅊ': return checkVWithHorizontalsInGuide(userImageData, region);
                case 'ㅋ': return checkVerticalWithRightStrokesInGuide(userImageData, region);
                case 'ㅌ': return checkCapWithVerticalInGuide(userImageData, region);
                case 'ㅍ': return checkRectangleWithVerticalInGuide(userImageData, region);
                case 'ㅎ': return checkCircleWithHorizontalInGuide(userImageData, region);
                
                case 'ㅏ': return checkVerticalWithRightHorizontalInGuide(userImageData, region);
                case 'ㅓ': return checkVerticalWithLeftHorizontalInGuide(userImageData, region);
                case 'ㅗ': return checkHorizontalWithDownVerticalInGuide(userImageData, region);
                case 'ㅜ': return checkHorizontalWithUpVerticalInGuide(userImageData, region);
                case 'ㅡ': return checkHorizontalStrokeInGuide(userImageData, region);
                case 'ㅣ': return checkVerticalStrokeInGuide(userImageData, region);
                case 'ㅑ': return checkVerticalWithTwoRightHorizontalsInGuide(userImageData, region);
                case 'ㅕ': return checkVerticalWithTwoLeftHorizontalsInGuide(userImageData, region);
                case 'ㅛ': return checkHorizontalWithTwoDownVerticalsInGuide(userImageData, region);
                case 'ㅠ': return checkHorizontalWithTwoUpVerticalsInGuide(userImageData, region);
                
                default:
                    return checkBasicStrokeInGuideArea(userImageData, region);
            }
        }

        // 회색 가이드선 영역 내에 획이 있는지 확인
        function checkStrokeInGuideArea(imageData, region) {
            // 가이드선 영역 정의 (중앙 80% 영역)
            const guideMargin = 0.1; // 10% 여백
            const guideStartX = Math.floor(region.width * guideMargin);
            const guideEndX = Math.floor(region.width * (1 - guideMargin));
            const guideStartY = Math.floor(region.height * guideMargin);
            const guideEndY = Math.floor(region.height * (1 - guideMargin));
            
            let strokePixelsInGuide = 0;
            const minStrokePixels = Math.max(10, (guideEndX - guideStartX) * (guideEndY - guideStartY) * 0.02); // 가이드 영역의 2%로 완화
            
            for (let y = guideStartY; y < guideEndY; y++) {
                for (let x = guideStartX; x < guideEndX; x++) {
                    const index = (y * region.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        strokePixelsInGuide++;
                        if (strokePixelsInGuide >= minStrokePixels) return true;
                    }
                }
            }
            return false;
        }

        // 기본 획 존재 확인 (가이드 영역 내에서만)
        function checkBasicStrokeInGuideArea(imageData, region) {
            return checkStrokeInGuideArea(imageData, region);
        }

        // 세로선 존재 확인 (가이드 영역 내에서만)
        function checkVerticalStrokeInGuide(imageData, region) {
            // 가이드 영역 정의
            const guideMargin = 0.1;
            const guideStartX = Math.floor(region.width * guideMargin);
            const guideEndX = Math.floor(region.width * (1 - guideMargin));
            const guideStartY = Math.floor(region.height * guideMargin);
            const guideEndY = Math.floor(region.height * (1 - guideMargin));
            
            const centerX = Math.floor(region.width / 2);
            const tolerance = Math.floor(region.width * 0.2); // 가이드 영역 내에서만 허용
            let verticalPixels = 0;
            const minVerticalPixels = Math.floor((guideEndY - guideStartY) * 0.3); // 가이드 영역 높이의 30%로 완화
            
            for (let y = guideStartY; y < guideEndY; y++) {
                let foundInRow = false;
                for (let x = Math.max(guideStartX, centerX - tolerance); x <= Math.min(guideEndX, centerX + tolerance); x++) {
                    const index = (y * region.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        foundInRow = true;
                        break;
                    }
                }
                if (foundInRow) verticalPixels++;
            }
            return verticalPixels >= minVerticalPixels;
        }

        // 가로선 존재 확인 (가이드 영역 내에서만)
        function checkHorizontalStrokeInGuide(imageData, region) {
            // 가이드 영역 정의
            const guideMargin = 0.1;
            const guideStartX = Math.floor(region.width * guideMargin);
            const guideEndX = Math.floor(region.width * (1 - guideMargin));
            const guideStartY = Math.floor(region.height * guideMargin);
            const guideEndY = Math.floor(region.height * (1 - guideMargin));
            
            const centerY = Math.floor(region.height / 2);
            const tolerance = Math.floor(region.height * 0.2); // 가이드 영역 내에서만 허용
            let horizontalPixels = 0;
            const minHorizontalPixels = Math.floor((guideEndX - guideStartX) * 0.3); // 가이드 영역 너비의 30%로 완화
            
            for (let x = guideStartX; x < guideEndX; x++) {
                let foundInCol = false;
                for (let y = Math.max(guideStartY, centerY - tolerance); y <= Math.min(guideEndY, centerY + tolerance); y++) {
                    const index = (y * region.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        foundInCol = true;
                        break;
                    }
                }
                if (foundInCol) horizontalPixels++;
            }
            return horizontalPixels >= minHorizontalPixels;
        }

        // 기존 함수들을 가이드 영역 제한 버전으로 대체
        function checkVerticalStroke(imageData, region) {
            return checkVerticalStrokeInGuide(imageData, region);
        }

        function checkHorizontalStroke(imageData, region) {
            return checkHorizontalStrokeInGuide(imageData, region);
        }

        // 가이드 영역 제한 함수들 추가
        function checkVerticalWithRightHorizontalInGuide(imageData, region) {
            return checkVerticalStrokeInGuide(imageData, region) && 
                   checkHorizontalInGuideRegion(imageData, region, 0.6, 1.0, 0.3, 0.7);
        }

        function checkVerticalWithLeftHorizontalInGuide(imageData, region) {
            return checkVerticalStrokeInGuide(imageData, region) && 
                   checkHorizontalInGuideRegion(imageData, region, 0.0, 0.4, 0.3, 0.7);
        }

        function checkHorizontalWithDownVerticalInGuide(imageData, region) {
            return checkHorizontalStrokeInGuide(imageData, region) && 
                   checkVerticalInGuideRegion(imageData, region, 0.3, 0.7, 0.5, 1.0);
        }

        function checkHorizontalWithUpVerticalInGuide(imageData, region) {
            return checkHorizontalStrokeInGuide(imageData, region) && 
                   checkVerticalInGuideRegion(imageData, region, 0.3, 0.7, 0.0, 0.5);
        }

        // 모든 자모 함수들을 가이드 영역 제한 버전으로 생성
        function checkAngleStrokeInGuide(imageData, region) {
            return checkHorizontalStrokeInGuide(imageData, region) || checkVerticalStrokeInGuide(imageData, region);
        }

        function checkLShapeStrokeInGuide(imageData, region) {
            return checkVerticalStrokeInGuide(imageData, region) || checkHorizontalStrokeInGuide(imageData, region);
        }

        function checkCapStrokeInGuide(imageData, region) {
            return checkHorizontalStrokeInGuide(imageData, region) || checkVerticalStrokeInGuide(imageData, region);
        }

        function checkComplexStrokeInGuide(imageData, region, minComponents) {
            let components = 0;
            if (checkHorizontalStrokeInGuide(imageData, region)) components++;
            if (checkVerticalStrokeInGuide(imageData, region)) components++;
            if (checkStrokeInGuideArea(imageData, region)) components++;
            return components >= Math.min(minComponents, 2);
        }

        function checkRectangleStrokeInGuide(imageData, region) {
            return checkHorizontalStrokeInGuide(imageData, region) && checkVerticalStrokeInGuide(imageData, region);
        }

        function checkVerticalWithHorizontalsInGuide(imageData, region) {
            return checkVerticalStrokeInGuide(imageData, region) || checkHorizontalStrokeInGuide(imageData, region);
        }

        function checkVShapeStrokeInGuide(imageData, region) {
            return checkStrokeInGuideArea(imageData, region);
        }

        function checkCircleStrokeInGuide(imageData, region) {
            return checkStrokeInGuideArea(imageData, region);
        }

        function checkVWithHorizontalInGuide(imageData, region) {
            return checkStrokeInGuideArea(imageData, region);
        }

        function checkVWithHorizontalsInGuide(imageData, region) {
            return checkStrokeInGuideArea(imageData, region);
        }

        function checkVerticalWithRightStrokesInGuide(imageData, region) {
            return checkVerticalStrokeInGuide(imageData, region) || checkStrokeInGuideArea(imageData, region);
        }

        function checkCapWithVerticalInGuide(imageData, region) {
            return checkHorizontalStrokeInGuide(imageData, region) || checkVerticalStrokeInGuide(imageData, region);
        }

        function checkRectangleWithVerticalInGuide(imageData, region) {
            return checkHorizontalStrokeInGuide(imageData, region) || checkVerticalStrokeInGuide(imageData, region);
        }

        function checkCircleWithHorizontalInGuide(imageData, region) {
            return checkStrokeInGuideArea(imageData, region);
        }

        function checkVerticalWithTwoRightHorizontalsInGuide(imageData, region) {
            return checkVerticalStrokeInGuide(imageData, region) || checkHorizontalStrokeInGuide(imageData, region);
        }

        function checkVerticalWithTwoLeftHorizontalsInGuide(imageData, region) {
            return checkVerticalStrokeInGuide(imageData, region) || checkHorizontalStrokeInGuide(imageData, region);
        }

        function checkHorizontalWithTwoDownVerticalsInGuide(imageData, region) {
            return checkHorizontalStrokeInGuide(imageData, region) || checkVerticalStrokeInGuide(imageData, region);
        }

        function checkHorizontalWithTwoUpVerticalsInGuide(imageData, region) {
            return checkHorizontalStrokeInGuide(imageData, region) || checkVerticalStrokeInGuide(imageData, region);
        }

        // 기존 함수들을 가이드 영역 제한 버전으로 대체
        function checkVerticalWithRightHorizontal(imageData, region) {
            return checkVerticalWithRightHorizontalInGuide(imageData, region);
        }

        function checkVerticalWithLeftHorizontal(imageData, region) {
            return checkVerticalWithLeftHorizontalInGuide(imageData, region);
        }

        function checkHorizontalWithDownVertical(imageData, region) {
            return checkHorizontalWithDownVerticalInGuide(imageData, region);
        }

        function checkHorizontalWithUpVertical(imageData, region) {
            return checkHorizontalWithUpVerticalInGuide(imageData, region);
        }

        // 가이드 영역 내 특정 영역에서 가로선 확인
        function checkHorizontalInGuideRegion(imageData, region, xStart, xEnd, yStart, yEnd) {
            // 가이드 영역 정의
            const guideMargin = 0.1;
            const guideStartX = Math.floor(region.width * guideMargin);
            const guideEndX = Math.floor(region.width * (1 - guideMargin));
            const guideStartY = Math.floor(region.height * guideMargin);
            const guideEndY = Math.floor(region.height * (1 - guideMargin));
            
            // 요청된 영역을 가이드 영역 내로 제한
            const startX = Math.max(guideStartX, Math.floor(region.width * xStart));
            const endX = Math.min(guideEndX, Math.floor(region.width * xEnd));
            const startY = Math.max(guideStartY, Math.floor(region.height * yStart));
            const endY = Math.min(guideEndY, Math.floor(region.height * yEnd));
            
            let horizontalPixels = 0;
            const minPixels = Math.floor((endX - startX) * 0.3); // 30%
            
            for (let y = startY; y < endY; y++) {
                let foundInRow = false;
                for (let x = startX; x < endX; x++) {
                    const index = (y * region.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        foundInRow = true;
                        break;
                    }
                }
                if (foundInRow) horizontalPixels++;
            }
            
            const minRows = Math.max(1, Math.floor((endY - startY) * 0.2));
            return horizontalPixels >= minRows;
        }

        // 가이드 영역 내 특정 영역에서 세로선 확인
        function checkVerticalInGuideRegion(imageData, region, xStart, xEnd, yStart, yEnd) {
            // 가이드 영역 정의
            const guideMargin = 0.1;
            const guideStartX = Math.floor(region.width * guideMargin);
            const guideEndX = Math.floor(region.width * (1 - guideMargin));
            const guideStartY = Math.floor(region.height * guideMargin);
            const guideEndY = Math.floor(region.height * (1 - guideMargin));
            
            // 요청된 영역을 가이드 영역 내로 제한
            const startX = Math.max(guideStartX, Math.floor(region.width * xStart));
            const endX = Math.min(guideEndX, Math.floor(region.width * xEnd));
            const startY = Math.max(guideStartY, Math.floor(region.height * yStart));
            const endY = Math.min(guideEndY, Math.floor(region.height * yEnd));
            
            let verticalPixels = 0;
            const minPixels = Math.floor((endY - startY) * 0.3); // 30%
            
            for (let x = startX; x < endX; x++) {
                let foundInCol = false;
                for (let y = startY; y < endY; y++) {
                    const index = (y * region.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        foundInCol = true;
                        break;
                    }
                }
                if (foundInCol) verticalPixels++;
            }
            
            const minCols = Math.max(1, Math.floor((endX - startX) * 0.2));
            return verticalPixels >= minCols;
        }

        // 기존 함수들을 가이드 영역 제한 버전으로 대체
        function checkHorizontalInRegion(imageData, region, xStart, xEnd, yStart, yEnd) {
            return checkHorizontalInGuideRegion(imageData, region, xStart, xEnd, yStart, yEnd);
        }

        function checkVerticalInRegion(imageData, region, xStart, xEnd, yStart, yEnd) {
            return checkVerticalInGuideRegion(imageData, region, xStart, xEnd, yStart, yEnd);
        }

        // 각도 있는 획 (ㄱ)
        function checkAngleStroke(imageData, region) {
            return checkHorizontalStroke(imageData, region) || checkVerticalStroke(imageData, region);
        }

        // L자 모양 (ㄴ)
        function checkLShapeStroke(imageData, region) {
            return checkVerticalStroke(imageData, region) || checkHorizontalStroke(imageData, region);
        }

        // 모자 모양 (ㄷ)
        function checkCapStroke(imageData, region) {
            return checkHorizontalStroke(imageData, region) || checkVerticalStroke(imageData, region);
        }

        // 복잡한 획 (ㄹ)
        function checkComplexStroke(imageData, region, minComponents) {
            let components = 0;
            if (checkHorizontalStroke(imageData, region)) components++;
            if (checkVerticalStroke(imageData, region)) components++;
            if (checkBasicStrokeExists(imageData, region)) components++;
            return components >= Math.min(minComponents, 2);
        }

        // 사각형 모양 (ㅁ)
        function checkRectangleStroke(imageData, region) {
            return checkHorizontalStroke(imageData, region) && checkVerticalStroke(imageData, region);
        }

        // 세로선 + 가로선들 (ㅂ)
        function checkVerticalWithHorizontals(imageData, region) {
            return checkVerticalStroke(imageData, region) || checkHorizontalStroke(imageData, region);
        }

        // V자 모양 (ㅅ)
        function checkVShapeStroke(imageData, region) {
            return checkBasicStrokeExists(imageData, region);
        }

        // 원 모양 (ㅇ)
        function checkCircleStroke(imageData, region) {
            return checkBasicStrokeExists(imageData, region);
        }

        // V자 + 가로선 (ㅈ)
        function checkVWithHorizontal(imageData, region) {
            return checkBasicStrokeExists(imageData, region);
        }

        // V자 + 가로선들 (ㅊ)
        function checkVWithHorizontals(imageData, region) {
            return checkBasicStrokeExists(imageData, region);
        }

        // 세로선 + 오른쪽 획들 (ㅋ)
        function checkVerticalWithRightStrokes(imageData, region) {
            return checkVerticalStroke(imageData, region) || checkBasicStrokeExists(imageData, region);
        }

        // 모자 + 세로선 (ㅌ)
        function checkCapWithVertical(imageData, region) {
            return checkHorizontalStroke(imageData, region) || checkVerticalStroke(imageData, region);
        }

        // 사각형 + 세로선 (ㅍ)
        function checkRectangleWithVertical(imageData, region) {
            return checkHorizontalStroke(imageData, region) || checkVerticalStroke(imageData, region);
        }

        // 원 + 가로선 (ㅎ)
        function checkCircleWithHorizontal(imageData, region) {
            return checkBasicStrokeExists(imageData, region);
        }

        // 세로선 + 두 개의 오른쪽 가로선 (ㅑ)
        function checkVerticalWithTwoRightHorizontals(imageData, region) {
            return checkVerticalStroke(imageData, region) || checkHorizontalStroke(imageData, region);
        }

        // 세로선 + 두 개의 왼쪽 가로선 (ㅕ)
        function checkVerticalWithTwoLeftHorizontals(imageData, region) {
            return checkVerticalStroke(imageData, region) || checkHorizontalStroke(imageData, region);
        }

        // 가로선 + 두 개의 아래 세로선 (ㅛ)
        function checkHorizontalWithTwoDownVerticals(imageData, region) {
            return checkHorizontalStroke(imageData, region) || checkVerticalStroke(imageData, region);
        }

        // 가로선 + 두 개의 위 세로선 (ㅠ)
        function checkHorizontalWithTwoUpVerticals(imageData, region) {
            return checkHorizontalStroke(imageData, region) || checkVerticalStroke(imageData, region);
        }

        // 구조 확인 헬퍼 함수들
        function checkAngleStructure(imageData, region) {
            return checkVerticalStructure(imageData, region) && checkHorizontalStructure(imageData, region);
        }
        
        function checkLShapeStructure(imageData, region) {
            return checkVerticalStructure(imageData, region) && checkHorizontalStructure(imageData, region);
        }
        
        function checkCapStructure(imageData, region) {
            return checkHorizontalStructure(imageData, region) && 
                   (checkVerticalStructure(imageData, region) || checkBasicStrokeStructure(imageData, region));
        }
        
        function checkRectangleStructure(imageData, region) {
            return checkHorizontalStructure(imageData, region) && checkVerticalStructure(imageData, region);
        }
        
        function checkVerticalWithHorizontalsStructure(imageData, region) {
            return checkVerticalStructure(imageData, region) && checkHorizontalStructure(imageData, region);
        }
        
        function checkVShapeStructure(imageData, region) {
            return checkBasicStrokeStructure(imageData, region);
        }
        
        function checkCircleStructure(imageData, region) {
            return checkBasicStrokeStructure(imageData, region);
        }
        
        function checkVWithHorizontalStructure(imageData, region) {
            return checkBasicStrokeStructure(imageData, region);
        }
        
        function checkVWithHorizontalsStructure(imageData, region) {
            return checkBasicStrokeStructure(imageData, region);
        }
        
        function checkVerticalWithRightStrokesStructure(imageData, region) {
            return checkVerticalStructure(imageData, region);
        }
        
        function checkCapWithVerticalStructure(imageData, region) {
            return checkHorizontalStructure(imageData, region) && checkVerticalStructure(imageData, region);
        }
        
        function checkRectangleWithVerticalStructure(imageData, region) {
            return checkHorizontalStructure(imageData, region) && checkVerticalStructure(imageData, region);
        }
        
        function checkCircleWithHorizontalStructure(imageData, region) {
            return checkBasicStrokeStructure(imageData, region);
        }
        
        function checkVerticalWithRightHorizontalStructure(imageData, region) {
            return checkVerticalStructure(imageData, region) && checkHorizontalStructure(imageData, region);
        }
        
        function checkVerticalWithLeftHorizontalStructure(imageData, region) {
            return checkVerticalStructure(imageData, region) && checkHorizontalStructure(imageData, region);
        }
        
        function checkHorizontalWithDownVerticalStructure(imageData, region) {
            return checkHorizontalStructure(imageData, region) && checkVerticalStructure(imageData, region);
        }
        
        function checkHorizontalWithUpVerticalStructure(imageData, region) {
            return checkHorizontalStructure(imageData, region) && checkVerticalStructure(imageData, region);
        }
        
        function checkVerticalWithTwoRightHorizontalsStructure(imageData, region) {
            return checkVerticalStructure(imageData, region) && checkHorizontalStructure(imageData, region);
        }
        
        function checkVerticalWithTwoLeftHorizontalsStructure(imageData, region) {
            return checkVerticalStructure(imageData, region) && checkHorizontalStructure(imageData, region);
        }
        
        function checkHorizontalWithTwoDownVerticalsStructure(imageData, region) {
            return checkHorizontalStructure(imageData, region) && checkVerticalStructure(imageData, region);
        }
        
        function checkHorizontalWithTwoUpVerticalsStructure(imageData, region) {
            return checkHorizontalStructure(imageData, region) && checkVerticalStructure(imageData, region);
        }
        
        // 기본 구조 확인 함수들
        function checkVerticalStructure(imageData, region) {
            const centerX = Math.floor(region.width / 2);
            const tolerance = Math.floor(region.width * 0.25);
            let verticalPixels = 0;
            const minVerticalPixels = Math.floor(region.height * 0.4);
            
            for (let y = 0; y < region.height; y++) {
                let foundInRow = false;
                for (let x = Math.max(0, centerX - tolerance); x <= Math.min(region.width - 1, centerX + tolerance); x++) {
                    const index = (y * region.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        foundInRow = true;
                        break;
                    }
                }
                if (foundInRow) verticalPixels++;
            }
            return verticalPixels >= minVerticalPixels;
        }
        
        function checkHorizontalStructure(imageData, region) {
            const centerY = Math.floor(region.height / 2);
            const tolerance = Math.floor(region.height * 0.25);
            let horizontalPixels = 0;
            const minHorizontalPixels = Math.floor(region.width * 0.4);
            
            for (let x = 0; x < region.width; x++) {
                let foundInCol = false;
                for (let y = Math.max(0, centerY - tolerance); y <= Math.min(region.height - 1, centerY + tolerance); y++) {
                    const index = (y * region.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        foundInCol = true;
                        break;
                    }
                }
                if (foundInCol) horizontalPixels++;
            }
            return horizontalPixels >= minHorizontalPixels;
        }
        
        function checkBasicStrokeStructure(imageData, region) {
            let strokePixels = 0;
            const minStrokePixels = Math.max(20, region.width * region.height * 0.05);
            
            for (let i = 0; i < imageData.data.length; i += 4) {
                if (imageData.data[i + 3] > 0) {
                    strokePixels++;
                }
            }
            return strokePixels >= minStrokePixels;
        }
        
        // 형태 유사도 계산 함수들
        function generateReferenceShape(jamo, region) {
            // 간단한 기준 형태 생성 (실제 구현에서는 더 정교하게)
            return new Array(region.width * region.height).fill(0);
        }
        
        function calculateShapeSimilarity(imageData, referenceShape, region) {
            // 기본적인 형태 유사도 계산
            return 0.8; // 임시값
        }
        
        function calculateCenterOfMass(imageData, region) {
            let totalX = 0, totalY = 0, totalPixels = 0;
            
            for (let y = 0; y < region.height; y++) {
                for (let x = 0; x < region.width; x++) {
                    const index = (y * region.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        totalX += x;
                        totalY += y;
                        totalPixels++;
                    }
                }
            }
            
            return totalPixels > 0 ? 
                { x: totalX / totalPixels, y: totalY / totalPixels } : 
                { x: region.width / 2, y: region.height / 2 };
        }
        
        function getExpectedJamoCenter(jamo, region) {
            // 자모별 예상 중심점 (간단한 구현)
            return { x: region.width / 2, y: region.height / 2 };
        }
        
        // 전체 글자 평가 함수들
        function evaluateCharacterContour(imageData, char, width, height) {
            // 글자 윤곽 평가
            return 0.8; // 임시값
        }
        
        function evaluateCharacterProportion(imageData, char, width, height) {
            // 글자 비율 평가
            return 0.8; // 임시값
        }
        
        function evaluateCharacterConnectivity(imageData, width, height) {
            // 글자 연결성 평가
            return 0.8; // 임시값
        }
        
        // 한글이 아닌 문자 평가 함수들
        function checkNonHangulBasicShape(imageData, char, width, height) {
            let strokePixels = 0;
            const minStrokePixels = Math.max(30, width * height * 0.03);
            
            for (let i = 0; i < imageData.data.length; i += 4) {
                if (imageData.data[i + 3] > 0) {
                    strokePixels++;
                }
            }
            return strokePixels >= minStrokePixels;
        }
        
        function calculateNonHangulShapeAccuracy(imageData, char, width, height) {
            // 한글이 아닌 문자의 형태 정확도
            let strokePixels = 0;
            const totalPixels = width * height;
            
            for (let i = 0; i < imageData.data.length; i += 4) {
                if (imageData.data[i + 3] > 0) {
                    strokePixels++;
                }
            }
            
            const strokeRatio = strokePixels / totalPixels;
            
            // 적절한 획 밀도 범위
            if (strokeRatio >= 0.02 && strokeRatio <= 0.3) {
                return 0.8;
            } else if (strokeRatio >= 0.01 && strokeRatio <= 0.5) {
                return 0.5;
            } else {
                return 0.2;
            }
        }

        // 한글이 아닌 경우 구성요소 매칭 (가이드 영역 내에서만)
        function calculateComponentMatch(canvas, char) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // 가이드 영역 정의
            const guideMargin = 0.1;
            const guideStartX = Math.floor(canvas.width * guideMargin);
            const guideEndX = Math.floor(canvas.width * (1 - guideMargin));
            const guideStartY = Math.floor(canvas.height * guideMargin);
            const guideEndY = Math.floor(canvas.height * (1 - guideMargin));
            
            // 가이드 영역 내의 획만 확인
            let strokePixelsInGuide = 0;
            const guideAreaPixels = (guideEndX - guideStartX) * (guideEndY - guideStartY);
            
            for (let y = guideStartY; y < guideEndY; y++) {
                for (let x = guideStartX; x < guideEndX; x++) {
                    const index = (y * canvas.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        strokePixelsInGuide++;
                    }
                }
            }
            
            const strokeRatio = strokePixelsInGuide / guideAreaPixels;
            
            // 가이드 영역 내에 적절한 양의 획이 있으면 완성으로 간주
            if (strokeRatio >= 0.02 && strokeRatio <= 0.4) {
                return 0.8; // 높은 점수
            } else if (strokeRatio >= 0.01) {
                return 0.4; // 중간 점수
            } else {
                return 0.1; // 낮은 점수
            }
        }

        // 자모별 픽셀 일치율 계산 (균형잡힌 완성도 기준) - 기존 함수 유지
        function calculateJamoPixelMatch(canvas, fullChar, jamo, position) {
            const ctx = canvas.getContext('2d');
            
            // 전체 글자의 기준 캔버스 생성
            const referenceCanvas = document.createElement('canvas');
            referenceCanvas.width = canvas.width;
            referenceCanvas.height = canvas.height;
            const refCtx = referenceCanvas.getContext('2d');
            
            // 기준 글자 그리기 (얇은 선으로)
            refCtx.font = '300 120px Arial';
            refCtx.fillStyle = '#000000';
            refCtx.textAlign = 'center';
            refCtx.textBaseline = 'middle';
            refCtx.fillText(fullChar, canvas.width / 2, canvas.height / 2);
            
            // 해당 자모 영역만 추출
            const jamoRegion = getJamoRegion(canvas.width, canvas.height, position);
            
            // 사용자 그림과 기준 글자의 픽셀 데이터 가져오기
            const userImageData = ctx.getImageData(jamoRegion.x, jamoRegion.y, jamoRegion.width, jamoRegion.height);
            const refImageData = refCtx.getImageData(jamoRegion.x, jamoRegion.y, jamoRegion.width, jamoRegion.height);
            
            // 자모의 주요 구성 요소별 완성도 검사
            const componentCompletionRates = checkJamoComponents(userImageData, refImageData, jamo, jamoRegion);
            
            // 모든 구성 요소가 충분히 완성되었는지 확인
            let totalCompletionRate = 0;
            let componentCount = componentCompletionRates.length;
            
            for (let rate of componentCompletionRates) {
                totalCompletionRate += rate;
            }
            
            return componentCount > 0 ? totalCompletionRate / componentCount : 0;
        }

        // 자모의 구성 요소별 완성도 검사
        function checkJamoComponents(userImageData, refImageData, jamo, region) {
            const componentRates = [];
            
            // 자모별 구성 요소 정의 및 검사
            switch (jamo) {
                case 'ㅏ': // ㅣ + ㅡ (오른쪽 세로선 + 가로선)
                    componentRates.push(checkVerticalLine(userImageData, refImageData, region, 'right'));
                    componentRates.push(checkHorizontalLine(userImageData, refImageData, region, 'middle'));
                    break;
                case 'ㅓ': // ㅣ + ㅡ (왼쪽 세로선 + 가로선)
                    componentRates.push(checkVerticalLine(userImageData, refImageData, region, 'right'));
                    componentRates.push(checkHorizontalLine(userImageData, refImageData, region, 'middle'));
                    break;
                case 'ㅗ': // ㅡ + ㅣ (위쪽 가로선 + 세로선)
                    componentRates.push(checkHorizontalLine(userImageData, refImageData, region, 'upper'));
                    componentRates.push(checkVerticalLine(userImageData, refImageData, region, 'center'));
                    break;
                case 'ㅜ': // ㅡ + ㅣ (아래쪽 가로선 + 세로선)
                    componentRates.push(checkHorizontalLine(userImageData, refImageData, region, 'lower'));
                    componentRates.push(checkVerticalLine(userImageData, refImageData, region, 'center'));
                    break;
                case 'ㅑ': // ㅣ + ㅡ + ㅡ (세로선 + 두 개의 가로선)
                    componentRates.push(checkVerticalLine(userImageData, refImageData, region, 'right'));
                    componentRates.push(checkHorizontalLine(userImageData, refImageData, region, 'upper'));
                    componentRates.push(checkHorizontalLine(userImageData, refImageData, region, 'lower'));
                    break;
                case 'ㅕ': // ㅣ + ㅡ + ㅡ (세로선 + 두 개의 가로선)
                    componentRates.push(checkVerticalLine(userImageData, refImageData, region, 'right'));
                    componentRates.push(checkHorizontalLine(userImageData, refImageData, region, 'upper'));
                    componentRates.push(checkHorizontalLine(userImageData, refImageData, region, 'lower'));
                    break;
                case 'ㅛ': // ㅡ + ㅣ + ㅣ (가로선 + 두 개의 세로선)
                    componentRates.push(checkHorizontalLine(userImageData, refImageData, region, 'upper'));
                    componentRates.push(checkVerticalLine(userImageData, refImageData, region, 'left'));
                    componentRates.push(checkVerticalLine(userImageData, refImageData, region, 'right'));
                    break;
                case 'ㅠ': // ㅡ + ㅣ + ㅣ (가로선 + 두 개의 세로선)
                    componentRates.push(checkHorizontalLine(userImageData, refImageData, region, 'lower'));
                    componentRates.push(checkVerticalLine(userImageData, refImageData, region, 'left'));
                    componentRates.push(checkVerticalLine(userImageData, refImageData, region, 'right'));
                    break;
                default:
                    // 기본적인 픽셀 매칭 방식 사용
                    let matchingPixels = 0;
                    let totalReferencePixels = 0;
                    
                    for (let i = 0; i < refImageData.data.length; i += 4) {
                        const refAlpha = refImageData.data[i + 3];
                        
                        if (refAlpha > 0) {
                            totalReferencePixels++;
                            
                            const pixelIndex = i / 4;
                            const x = pixelIndex % region.width;
                            const y = Math.floor(pixelIndex / region.width);
                            
                            if (isNearUserStrokeInRegion(userImageData, x, y, region.width, region.height, 5)) {
                                matchingPixels++;
                            }
                        }
                    }
                    
                    componentRates.push(totalReferencePixels > 0 ? matchingPixels / totalReferencePixels : 0);
                    break;
            }
            
            return componentRates;
        }

        // 세로선 검사
        function checkVerticalLine(userImageData, refImageData, region, position) {
            let startX, endX;
            const tolerance = 15; // 허용 오차
            
            switch (position) {
                case 'left':
                    startX = 0;
                    endX = Math.floor(region.width * 0.4);
                    break;
                case 'center':
                    startX = Math.floor(region.width * 0.3);
                    endX = Math.floor(region.width * 0.7);
                    break;
                case 'right':
                    startX = Math.floor(region.width * 0.6);
                    endX = region.width;
                    break;
                default:
                    startX = 0;
                    endX = region.width;
            }
            
            let matchingPixels = 0;
            let totalReferencePixels = 0;
            
            for (let y = 0; y < region.height; y++) {
                for (let x = startX; x < endX; x++) {
                    const index = (y * region.width + x) * 4;
                    const refAlpha = refImageData.data[index + 3];
                    
                    if (refAlpha > 0) {
                        totalReferencePixels++;
                        
                        if (isNearUserStrokeInRegion(userImageData, x, y, region.width, region.height, tolerance)) {
                            matchingPixels++;
                        }
                    }
                }
            }
            
            return totalReferencePixels > 0 ? matchingPixels / totalReferencePixels : 0;
        }

        // 가로선 검사
        function checkHorizontalLine(userImageData, refImageData, region, position) {
            let startY, endY;
            const tolerance = 15; // 허용 오차
            
            switch (position) {
                case 'upper':
                    startY = 0;
                    endY = Math.floor(region.height * 0.4);
                    break;
                case 'middle':
                    startY = Math.floor(region.height * 0.3);
                    endY = Math.floor(region.height * 0.7);
                    break;
                case 'lower':
                    startY = Math.floor(region.height * 0.6);
                    endY = region.height;
                    break;
                default:
                    startY = 0;
                    endY = region.height;
            }
            
            let matchingPixels = 0;
            let totalReferencePixels = 0;
            
            for (let y = startY; y < endY; y++) {
                for (let x = 0; x < region.width; x++) {
                    const index = (y * region.width + x) * 4;
                    const refAlpha = refImageData.data[index + 3];
                    
                    if (refAlpha > 0) {
                        totalReferencePixels++;
                        
                        if (isNearUserStrokeInRegion(userImageData, x, y, region.width, region.height, tolerance)) {
                            matchingPixels++;
                        }
                    }
                }
            }
            
            return totalReferencePixels > 0 ? matchingPixels / totalReferencePixels : 0;
        }

        // 자모 위치별 영역 정의
        function getJamoRegion(canvasWidth, canvasHeight, position) {
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            const regionSize = Math.min(canvasWidth, canvasHeight) * 0.8;
            
            switch (position) {
                case 'chosung': // 초성 (왼쪽 또는 위쪽)
                    return {
                        x: Math.max(0, centerX - regionSize * 0.6),
                        y: Math.max(0, centerY - regionSize * 0.4),
                        width: Math.min(canvasWidth, regionSize * 0.6),
                        height: Math.min(canvasHeight, regionSize * 0.8)
                    };
                case 'jungsung': // 중성 (오른쪽 또는 아래쪽)
                    return {
                        x: Math.max(0, centerX - regionSize * 0.2),
                        y: Math.max(0, centerY - regionSize * 0.4),
                        width: Math.min(canvasWidth, regionSize * 0.6),
                        height: Math.min(canvasHeight, regionSize * 0.8)
                    };
                case 'jongsung': // 종성 (아래쪽)
                    return {
                        x: Math.max(0, centerX - regionSize * 0.4),
                        y: Math.max(0, centerY + regionSize * 0.1),
                        width: Math.min(canvasWidth, regionSize * 0.8),
                        height: Math.min(canvasHeight, regionSize * 0.4)
                    };
                default:
                    return {x: 0, y: 0, width: canvasWidth, height: canvasHeight};
            }
        }

        // 영역 내에서 사용자 획 확인
        function isNearUserStrokeInRegion(imageData, x, y, width, height, tolerance) {
            for (let dx = -tolerance; dx <= tolerance; dx++) {
                for (let dy = -tolerance; dy <= tolerance; dy++) {
                    const checkX = x + dx;
                    const checkY = y + dy;
                    
                    if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height) {
                        const index = (checkY * width + checkX) * 4;
                        if (imageData.data[index + 3] > 0) { // 알파 채널이 0보다 크면 그려진 부분
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // 전체 글자 완성도 계산 (이중 검증용)
        function calculateOverallPixelMatch(canvas, char) {
            const ctx = canvas.getContext('2d');
            
            // 기준 글자 캔버스 생성
            const referenceCanvas = document.createElement('canvas');
            referenceCanvas.width = canvas.width;
            referenceCanvas.height = canvas.height;
            const refCtx = referenceCanvas.getContext('2d');
            
            // 기준 글자 그리기 (더 굵은 선으로 - 전체 형태 확인용)
            refCtx.font = 'bold 120px Arial';
            refCtx.fillStyle = '#000000';
            refCtx.textAlign = 'center';
            refCtx.textBaseline = 'middle';
            refCtx.fillText(char, canvas.width / 2, canvas.height / 2);
            
            // 사용자 그림과 기준 글자의 픽셀 데이터 가져오기
            const userImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const refImageData = refCtx.getImageData(0, 0, canvas.width, canvas.height);
            
            let matchingPixels = 0;
            let totalReferencePixels = 0;
            let userPixels = 0;
            
            // 사용자가 그린 픽셀 수 계산
            for (let i = 0; i < userImageData.data.length; i += 4) {
                if (userImageData.data[i + 3] > 0) {
                    userPixels++;
                }
            }
            
            // 픽셀별로 비교 (알파 채널 기준)
            for (let i = 0; i < refImageData.data.length; i += 4) {
                const refAlpha = refImageData.data[i + 3];
                
                if (refAlpha > 0) { // 기준 글자에 픽셀이 있는 경우
                    totalReferencePixels++;
                    
                    // 사용자가 그린 부분과 겹치는지 확인 (허용 오차)
                    const pixelIndex = i / 4;
                    const x = pixelIndex % canvas.width;
                    const y = Math.floor(pixelIndex / canvas.width);
                    
                    if (isNearUserStroke(userImageData, x, y, canvas.width, canvas.height, 8)) {
                        matchingPixels++;
                    }
                }
            }
            
            // 전체 완성도 = (일치하는 픽셀 / 기준 픽셀) * (적절한 그리기 양 보정)
            const baseMatchRate = totalReferencePixels > 0 ? matchingPixels / totalReferencePixels : 0;
            
            // 너무 적게 그렸거나 너무 많이 그린 경우 페널티
            const expectedPixels = totalReferencePixels * 1.2; // 기준보다 20% 정도 더 그리는 것은 허용
            const drawingAmountRatio = Math.min(1, userPixels / expectedPixels);
            
            return baseMatchRate * drawingAmountRatio;
        }

        // 픽셀 일치율 계산 (한글이 아닌 경우)
        function calculatePixelMatchRate(canvas, char) {
            const ctx = canvas.getContext('2d');
            
            // 기준 글자 캔버스 생성
            const referenceCanvas = document.createElement('canvas');
            referenceCanvas.width = canvas.width;
            referenceCanvas.height = canvas.height;
            const refCtx = referenceCanvas.getContext('2d');
            
            // 기준 글자 그리기 (얇은 선으로)
            refCtx.font = '300 120px Arial';
            refCtx.fillStyle = '#000000';
            refCtx.textAlign = 'center';
            refCtx.textBaseline = 'middle';
            refCtx.fillText(char, canvas.width / 2, canvas.height / 2);
            
            // 사용자 그림과 기준 글자의 픽셀 데이터 가져오기
            const userImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const refImageData = refCtx.getImageData(0, 0, canvas.width, canvas.height);
            
            let matchingPixels = 0;
            let totalReferencePixels = 0;
            
            // 픽셀별로 비교 (알파 채널 기준)
            for (let i = 0; i < refImageData.data.length; i += 4) {
                const refAlpha = refImageData.data[i + 3];
                
                if (refAlpha > 0) { // 기준 글자에 픽셀이 있는 경우
                    totalReferencePixels++;
                    
                    // 사용자가 그린 부분과 겹치는지 확인 (주변 픽셀도 고려)
                    const pixelIndex = i / 4;
                    const x = pixelIndex % canvas.width;
                    const y = Math.floor(pixelIndex / canvas.width);
                    
                    if (isNearUserStroke(userImageData, x, y, canvas.width, canvas.height, 8)) {
                        matchingPixels++;
                    }
                }
            }
            
            return totalReferencePixels > 0 ? matchingPixels / totalReferencePixels : 0;
        }

        // 주변에 사용자 획이 있는지 확인 (허용 오차 범위 내)
        function isNearUserStroke(imageData, x, y, width, height, tolerance) {
            for (let dx = -tolerance; dx <= tolerance; dx++) {
                for (let dy = -tolerance; dy <= tolerance; dy++) {
                    const checkX = x + dx;
                    const checkY = y + dy;
                    
                    if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height) {
                        const index = (checkY * width + checkX) * 4;
                        if (imageData.data[index + 3] > 0) { // 알파 채널이 0보다 크면 그려진 부분
                            return true;
                        }
                    }
                }
            }
            return false;
        }











        // URL에서 과제 로드
        function loadAssignmentFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const assignmentData = urlParams.get('assignment');
            
            if (assignmentData) {
                try {
                    const text = decodeURIComponent(atob(assignmentData));
                    currentAssignment = text;
                    const displayElement = document.getElementById('studentDisplayText');
                    displayElement.textContent = text;
                    adjustStudentDisplayFontSize(displayElement);
                    createCharacterBoxes(text);
                } catch (e) {
                    document.getElementById('studentDisplayText').textContent = '과제를 불러올 수 없습니다.';
                }
            } else {
                document.getElementById('studentDisplayText').textContent = '과제 링크로 접속해주세요.';
            }
        }

        // 학생 화면 목표 글씨 폰트 크기 자동 조정 (개선된 버전)
        function adjustStudentDisplayFontSize(element) {
            const text = element.textContent;
            const textLength = text.length;
            
            // 컨테이너 크기 확인
            const container = element.closest('.student-header');
            const containerStyle = window.getComputedStyle(element);
            const paddingLeft = parseFloat(containerStyle.paddingLeft);
            const paddingRight = parseFloat(containerStyle.paddingRight);
            const availableWidth = container.offsetWidth - paddingLeft - paddingRight - 20; // 추가 여백
            
            // 임시 측정용 요소 생성
            const measurer = document.createElement('span');
            measurer.style.visibility = 'hidden';
            measurer.style.position = 'absolute';
            measurer.style.whiteSpace = 'nowrap';
            measurer.style.fontFamily = containerStyle.fontFamily;
            measurer.style.fontWeight = containerStyle.fontWeight;
            measurer.textContent = text;
            document.body.appendChild(measurer);
            
            // 적절한 폰트 크기 찾기
            let fontSize = Math.min(35, availableWidth / textLength * 2.2); // 초기 추정값
            let maxFontSize = 35;
            let minFontSize = 14;
            
            // 이진 탐색으로 최적 폰트 크기 찾기
            for (let i = 0; i < 15; i++) {
                measurer.style.fontSize = fontSize + 'px';
                const textWidth = measurer.offsetWidth;
                
                if (textWidth > availableWidth) {
                    maxFontSize = fontSize;
                    fontSize = (minFontSize + fontSize) / 2;
                } else {
                    minFontSize = fontSize;
                    fontSize = (fontSize + maxFontSize) / 2;
                }
                
                // 충분히 정확하면 종료
                if (Math.abs(textWidth - availableWidth) < 15) {
                    break;
                }
            }
            
            // 안전 여백 적용 (92% 크기로)
            fontSize = fontSize * 0.92;
            
            // 최소/최대 크기 제한
            fontSize = Math.max(14, Math.min(35, fontSize));
            
            // 측정용 요소 제거
            document.body.removeChild(measurer);
            
            // 폰트 크기 적용
            element.style.fontSize = fontSize + 'px';
            
            // 레이아웃 설정
            if (textLength > 20 || fontSize < 18) {
                element.style.whiteSpace = 'pre-wrap';
                element.style.wordBreak = 'break-word';
                element.style.overflowWrap = 'break-word';
                element.style.lineHeight = '1.3';
                
                // 컨테이너 높이 자동 조정
                container.style.minHeight = 'auto';
                container.style.height = 'auto';
            } else {
                element.style.whiteSpace = 'nowrap';
                element.style.wordBreak = 'normal';
                element.style.overflowWrap = 'normal';
                element.style.lineHeight = '1.2';
            }
            
            // 최종 검증 - 여전히 넘어가면 줄바꿈 강제 적용
            setTimeout(() => {
                if (element.scrollWidth > availableWidth + 20) {
                    element.style.whiteSpace = 'pre-wrap';
                    element.style.wordBreak = 'break-word';
                    element.style.overflowWrap = 'break-word';
                    element.style.lineHeight = '1.3';
                    container.style.minHeight = 'auto';
                    container.style.height = 'auto';
                }
            }, 10);
        }



        // 모든 캔버스 지우기
        function clearAllCanvas() {
            characterCanvases.forEach((canvasData, index) => {
                // 캔버스 지우기
                canvasData.ctx.clearRect(0, 0, canvasData.canvas.width, canvasData.canvas.height);
                
                // 그리기 데이터 초기화
                canvasData.drawingData = [];
                
                // 상태 표시등을 빨간색으로 초기화
                canvasData.indicator.className = 'status-indicator red';
                canvasData.indicator.textContent = evaluationMessages.red[0]; // '✏️작성 중'으로 초기화
                
                // 캐릭터 데이터 초기화
                characterData[index].completed = false;
            });
            console.log('모든 캔버스 초기화 완료');
        }





        // 화면 캡처 및 저장 기능
        function saveResult() {
            // html2canvas 라이브러리를 동적으로 로드
            if (!window.html2canvas) {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
                script.onload = function() {
                    captureAndSave();
                };
                document.head.appendChild(script);
            } else {
                captureAndSave();
            }
        }

        function captureAndSave() {
            const characterGrid = document.getElementById('characterGrid');
            
            html2canvas(characterGrid, {
                backgroundColor: '#ffffff',
                scale: 2,
                useCORS: true,
                allowTaint: true,
                width: characterGrid.scrollWidth,
                height: characterGrid.scrollHeight
            }).then(function(canvas) {
                // 캔버스를 이미지로 변환
                const link = document.createElement('a');
                link.download = `글씨연습_${currentAssignment}_${new Date().toLocaleDateString('ko-KR')}.png`;
                link.href = canvas.toDataURL('image/png');
                
                // 자동으로 다운로드 실행
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // 완성 상태 알림
                let completedCount = 0;
                characterData.forEach(data => {
                    if (data.completed) completedCount++;
                });
                
                alert(`결과가 저장되었습니다!\n완성된 글자: ${completedCount}/${characterData.length}개`);
            }).catch(function(error) {
                console.error('캡처 실패:', error);
                alert('이미지 저장에 실패했습니다. 다시 시도해주세요.');
            });
        }

        // 페이지 로드 시 URL 확인
        window.addEventListener('load', () => {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('assignment')) {
                switchMode('student');
            } else {
                // 교사 화면에서도 동일한 제목 설정
                document.title = '글씨 요정 - 바른 글씨 연습';
            }
        });

        // 창 크기 변경 시 폰트 크기 재조정
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // 교사 화면 텍스트 재조정
                const teacherDisplayText = document.getElementById('teacherDisplayText');
                if (teacherDisplayText && teacherDisplayText.textContent !== '입력된 글씨가 여기에 표시됩니다') {
                    adjustFontSize(teacherDisplayText);
                }
                
                // 학생 화면 텍스트 재조정
                const studentDisplayText = document.getElementById('studentDisplayText');
                if (studentDisplayText && studentDisplayText.textContent !== '과제를 불러오는 중...' && studentDisplayText.textContent !== '과제 링크로 접속해주세요.') {
                    adjustStudentDisplayFontSize(studentDisplayText);
                }
            }, 300); // 300ms 디바운스
        });

        // 엔터키 이벤트 및 실시간 업데이트
        document.getElementById('teacherTextInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                createAssignment();
            }
        });
        
        // 실시간 텍스트 업데이트 이벤트 리스너
        document.getElementById('teacherTextInput').addEventListener('input', updateDisplayText);
        
        // 페이지 로드 시 초기 텍스트 설정
        document.addEventListener('DOMContentLoaded', function() {
            updateDisplayText();
        });

        // 라이브 평가 문구 배열
        const evaluationMessages = {
            red: ['✏️작성 중'],
            yellow: ['😊좋아요'],
            green: ['💚훌륭해요']
        };

        // 평가 결과에 따른 표시등 설정 (라이브 평가 문구 적용)
        function setIndicatorByEvaluation(indicator, characterData, evaluation) {
            let message;
            switch (evaluation) {
                case '초록불':
                    characterData.completed = true;
                    indicator.className = 'status-indicator green';
                    message = evaluationMessages.green[0];
                    break;
                case '노란불':
                    characterData.completed = false;
                    indicator.className = 'status-indicator yellow';
                    message = evaluationMessages.yellow[0];
                    break;
                case '빨간불':
                default:
                    characterData.completed = false;
                    indicator.className = 'status-indicator red';
                    message = evaluationMessages.red[0];
                    break;
            }
            indicator.textContent = message;
        }

        // 글씨 평가 함수
        function evaluateHandwriting() {
            // 모든 글자 칸이 채워졌는지 확인
            let emptyCount = 0;
            characterCanvases.forEach((canvasData) => {
                if (canvasData.drawingData.length < 1) {
                    emptyCount++;
                }
            });

            // 빈 글자 칸이 있으면 안내창 표시
            if (emptyCount > 0) {
                showIncompleteAlert();
                return;
            }

            let totalScore = 0;
            let evaluatedCount = 0;

            // 각 글자 칸의 점수 계산
            characterCanvases.forEach((canvasData, index) => {
                const char = canvasData.char;
                
                // 색칠/휘갈김 패턴 감지
                if (isScribbleOrFillPattern(canvasData.canvas)) {
                    // 점수: 0점
                    totalScore += 0;
                    evaluatedCount++;
                    return;
                }
                
                // 회색 가이드선과의 형태 일치도 평가
                const guideMatchScore = calculateGuideLineMatchScore(canvasData.canvas, char);
                
                let characterScore = 0;
                if (guideMatchScore >= 0.75) {
                    characterScore = 100; // 초록불 -> 100점
                } else if (guideMatchScore >= 0.55) {
                    characterScore = 60;  // 노란불 -> 60점
                } else {
                    characterScore = 0;   // 빨간불 -> 0점
                }
                
                totalScore += characterScore;
                evaluatedCount++;
            });

            // 평균 점수 계산
            const averageScore = evaluatedCount > 0 ? Math.round(totalScore / evaluatedCount) : 0;
            
            // 평가 등급과 메시지 결정
            let grade, message;
            if (averageScore >= 80) {
                grade = '🌟정말 훌륭해요!';
                message = '글씨가 바르게 잘 써졌어요! 아주 멋진 실력이에요.';
            } else if (averageScore >= 50) {
                grade = '🌸잘했어요!';
                message = '거의 다 반듯하게 잘 썼어요! 조금 더 다듬으면 완벽해요.';
            } else if (averageScore >= 25) {
                grade = '🌱조금 더 연습해요!';
                message = '몇 글자는 잘 썼어요! 천천히 반복하면 더 좋아질 거예요.';
            } else {
                grade = '🐾처음부터 차근차근';
                message = '이제 시작이에요! 하나씩 써보면 금방 나아질 거예요.';
            }

            // 팝업 표시
            showEvaluationPopup(grade, averageScore, message);
        }

        // 미완성 안내창 표시
        function showIncompleteAlert() {
            const popup = document.createElement('div');
            popup.className = 'evaluation-popup';
            
                                popup.innerHTML = `
                        <div class="evaluation-content">
                            <div class="evaluation-title">잠깐!</div>
                            <div class="evaluation-message" style="margin: 30px 0; word-break: keep-all; line-height: 1.4; text-align: center;">모든 글씨를 다 완성해야<br>평가 받을 수 있어요💡</div>
                            <button class="popup-close-btn" onclick="closeIncompleteAlert()">확인</button>
                        </div>
                    `;

            document.body.appendChild(popup);

            // 팝업 클릭으로 닫기 (배경 클릭시)
            popup.addEventListener('click', function(e) {
                if (e.target === popup) {
                    closeIncompleteAlert();
                }
            });
        }

        // 미완성 안내창 닫기
        function closeIncompleteAlert() {
            const popup = document.querySelector('.evaluation-popup');
            if (popup) {
                popup.style.animation = 'popupFadeOut 0.3s ease-out forwards';
                setTimeout(() => {
                    popup.remove();
                }, 300);
            }
        }

        // 평가 팝업 표시
        function showEvaluationPopup(grade, score, message) {
            // 기존 팝업이 있으면 제거
            const existingPopup = document.querySelector('.evaluation-popup');
            if (existingPopup) {
                existingPopup.remove();
            }

            // 팝업 생성
            const popup = document.createElement('div');
            popup.className = 'evaluation-popup';
            
            popup.innerHTML = `
                <div class="evaluation-content">
                    <div class="evaluation-title">${grade}</div>
                    <div class="evaluation-score" style="color: ${getScoreColor(score)}">${score}점</div>
                    <div class="evaluation-message">${message}</div>
                    <button class="popup-close-btn" onclick="closeEvaluationPopup()">닫기</button>
                </div>
            `;

            document.body.appendChild(popup);

            // 팝업 클릭으로 닫기 (배경 클릭시)
            popup.addEventListener('click', function(e) {
                if (e.target === popup) {
                    closeEvaluationPopup();
                }
            });
        }

        // 점수에 따른 색상 반환
        function getScoreColor(score) {
            if (score >= 80) return '#48bb78';      // 초록색
            else if (score >= 50) return '#ed8936'; // 주황색
            else if (score >= 25) return '#ecc94b'; // 노란색
            else return '#f56565';                  // 빨간색
        }

        // 평가 팝업 닫기
        function closeEvaluationPopup() {
            const popup = document.querySelector('.evaluation-popup');
            if (popup) {
                popup.style.animation = 'popupFadeOut 0.3s ease-out forwards';
                setTimeout(() => {
                    popup.remove();
                }, 300);
            }
        }

        // 팝업 페이드아웃 애니메이션 추가
        const style = document.createElement('style');
        style.textContent = `
            @keyframes popupFadeOut {
                from { opacity: 1; }
                to { opacity: 0; }
            }
        `;
        document.head.appendChild(style);
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'965d4859c6ad3176',t:'MTc1MzYzMTMyMy4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
