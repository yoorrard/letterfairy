<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Í∏ÄÏî® ÏöîÏ†ï - Î∞îÎ•∏ Í∏ÄÏî® Ïó∞Ïäµ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 20px;
            animation: fadeIn 0.8s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            padding: 30px;
            animation: slideUp 0.6s ease-out 0.2s both;
            transition: box-shadow 0.3s ease;
        }

        .container:hover {
            box-shadow: 0 15px 40px rgba(0,0,0,0.15);
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .header {
            text-align: center;
            margin-bottom: 8px;
            position: relative;
        }





        .title {
            color: #1a1a1a;
            font-size: clamp(1.8rem, 5vw, 3rem);
            font-weight: 800;
            margin-bottom: 15px;
            word-break: keep-all;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            animation: titleGlow 0.8s ease-out 0.4s both;
            position: relative;
            letter-spacing: 0.8px;
            text-align: center;
            background: linear-gradient(45deg, #1a1a1a 25%, #4a5568 50%, #1a1a1a 75%);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 0.8s ease-out 0.4s both, shimmerText 6s ease-in-out infinite;
        }

        @keyframes shimmerText {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .title::before {
            content: '';
            position: absolute;
            top: -12px;
            left: -20px;
            right: -20px;
            bottom: -12px;
            background: transparent;
            border-radius: 25px;
            z-index: -2;
            opacity: 0;
            animation: titleBackgroundGlow 1.2s ease-out 0.6s both;
        }

        .title::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            width: 0;
            height: 5px;
            background: linear-gradient(90deg, #2d3748, #4a5568, #2d3748);
            border-radius: 4px;
            transform: translateX(-50%);
            animation: underlineExpand 1.2s ease-out 0.8s both;
            box-shadow: 
                0 2px 8px rgba(0, 0, 0, 0.15),
                0 4px 16px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        @keyframes titleGlow {
            from { 
                opacity: 0; 
                transform: translateY(-15px) scale(0.95); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0) scale(1); 
            }
        }

        @keyframes titleBackgroundGlow {
            from { 
                opacity: 0; 
                transform: scale(0.8); 
            }
            to { 
                opacity: 1; 
                transform: scale(1); 
            }
        }

        @keyframes underlineExpand {
            from { 
                width: 0; 
                opacity: 0;
            }
            to { 
                width: 80px; 
                opacity: 1;
            }
        }

        .subtitle {
            color: #64748b;
            font-size: clamp(1rem, 2.5vw, 1.3rem);
            font-weight: 500;
            word-break: keep-all;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            animation: fadeInUp 0.6s ease-out 0.6s both;
            position: relative;
            margin-bottom: 5px;
            text-align: center;
        }

        .subtitle::before {
            content: '‚ú®';
            margin-right: 8px;
            font-size: 1.1em;
            animation: sparkle 2s ease-in-out infinite;
        }

        .subtitle::after {
            content: '‚ú®';
            margin-left: 8px;
            font-size: 1.1em;
            animation: sparkle 2s ease-in-out infinite 1s;
        }

        @keyframes sparkle {
            0%, 100% { 
                opacity: 0.6; 
                transform: scale(1); 
            }
            50% { 
                opacity: 1; 
                transform: scale(1.1); 
            }
        }

        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(15px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .mode-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            animation: fadeInScale 0.6s ease-out 0.8s both;
        }

        @keyframes fadeInScale {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        .teacher-only-notice {
            text-align: center;
            background: linear-gradient(135deg, #e6fffa 0%, #b2f5ea 100%);
            border: 2px solid #4fd1c7;
            border-radius: 15px;
            padding: 15px;
            color: #234e52;
            animation: slideInFromTop 0.6s ease-out 1s both;
            position: relative;
            overflow: hidden;
        }

        .teacher-only-notice::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.3), transparent);
            transform: rotate(45deg);
            animation: shimmer 2s infinite;
        }

        @keyframes slideInFromTop {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
            100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
        }

        .teacher-only-notice p {
            margin: 0;
            font-size: 1rem;
            font-weight: 500;
        }

        .mode-btn {
            padding: 15px 30px;
            font-size: 1.2rem;
            border: 3px solid #e2e8f0;
            border-radius: 15px;
            background: white;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: bold;
            position: relative;
            overflow: hidden;
        }

        .mode-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.5s;
        }

        .mode-btn:hover::before {
            left: 100%;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
        }

        .mode-btn:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .mode-btn:active {
            transform: translateY(-1px) scale(0.98);
        }

        .screen {
            display: none;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.4s ease-out;
        }

        .screen.active {
            display: block;
            animation: screenFadeIn 0.5s ease-out forwards;
        }

        @keyframes screenFadeIn {
            from { 
                opacity: 0; 
                transform: translateY(20px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }

        .input-section {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            animation: slideInFromBottom 0.6s ease-out 0.3s both;
        }

        @keyframes slideInFromBottom {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .text-input {
            padding: 15px 25px;
            font-size: 1.4rem;
            border: 3px solid #e2e8f0;
            border-radius: 15px;
            outline: none;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 500px;
            width: 100%;
            max-width: 600px;
            position: relative;
            background: white;
        }

        .text-input:focus {
            border-color: #4299e1;
            box-shadow: 0 0 0 4px rgba(66, 153, 225, 0.1), 0 4px 12px rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }

        .text-input:hover:not(:focus) {
            border-color: #cbd5e0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .btn {
            padding: 15px 30px;
            font-size: 1.2rem;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: bold;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:active::before {
            width: 300px;
            height: 300px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.2);
        }

        .btn-primary:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
            background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
        }

        .btn-primary:active {
            transform: translateY(-1px) scale(0.98);
        }

        .btn-secondary {
            background: white;
            color: #48bb78;
            border: 2px solid #48bb78;
            box-shadow: 0 2px 8px rgba(72, 187, 120, 0.1);
        }

        .btn-secondary:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 25px rgba(72, 187, 120, 0.3);
            background: #f0fff4;
            border-color: #38a169;
            color: #38a169;
        }

        .btn-secondary:active {
            transform: translateY(-1px) scale(0.98);
        }

        .btn-evaluate {
            background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
            color: white;
            border: none;
            box-shadow: 0 4px 15px rgba(237, 137, 54, 0.3);
        }

        .btn-evaluate:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 25px rgba(237, 137, 54, 0.4);
            background: linear-gradient(135deg, #dd6b20 0%, #c05621 100%);
        }

        .btn-evaluate:active {
            transform: translateY(-1px) scale(0.98);
        }

        .btn-success {
            background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%);
            color: #2d5016;
            box-shadow: 0 4px 15px rgba(132, 250, 176, 0.3);
        }

        .btn-success:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 8px 25px rgba(132, 250, 176, 0.5);
            background: linear-gradient(135deg, #68d391 0%, #4fd1c7 100%);
        }

        .btn-success:active {
            transform: translateY(-1px) scale(0.98);
        }

        .assignment-link {
            background: #f7fafc;
            border: 2px dashed #cbd5e0;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            animation: slideInFromRight 0.6s ease-out;
            position: relative;
            overflow: hidden;
        }

        .assignment-link::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(203, 213, 224, 0.3), transparent);
            animation: linkShimmer 2s infinite;
        }

        @keyframes slideInFromRight {
            from { opacity: 0; transform: translateX(30px); }
            to { opacity: 1; transform: translateX(0); }
        }

        @keyframes linkShimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .link-display {
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 1.1rem;
            word-break: break-all;
        }

        .display-text {
            text-align: center;
            font-size: clamp(1rem, 3vw, 1.8rem);
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 20px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px;
            word-wrap: break-word;
            word-break: break-word;
            line-height: 1.3;
            overflow-wrap: break-word;
            hyphens: auto;
            white-space: pre-wrap;
            overflow: hidden;
            box-sizing: border-box;
            transition: all 0.3s ease;
            position: relative;
        }

        .display-text::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            width: 0;
            height: 2px;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transform: translateX(-50%);
            transition: width 0.5s ease;
        }

        .display-text:not(:empty)::after {
            width: 80%;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 500px;
            border: 3px dashed #cbd5e0;
            border-radius: 15px;
            background: #f7fafc;
            margin-bottom: 20px;
            overflow: hidden;
            transition: all 0.3s ease;
            animation: containerFadeIn 0.6s ease-out 0.5s both;
        }

        .canvas-container:hover {
            border-color: #a0aec0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        @keyframes containerFadeIn {
            from { opacity: 0; transform: scale(0.95); }
            to { opacity: 1; transform: scale(1); }
        }

        .guide-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8rem;
            font-weight: bold;
            color: #888;
            opacity: 0.3;
            pointer-events: none;
            z-index: 1;
            white-space: nowrap;
            letter-spacing: 0.2em;
        }

        #drawingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            z-index: 2;
        }

        .character-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            justify-content: center;
            align-items: center;
            padding: 20px;
            min-height: 500px;
        }

        .character-box {
            position: relative;
            width: 200px;
            height: 200px;
            border: 3px solid #cbd5e0;
            border-radius: 10px;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 120px;
        }

        .character-guide {
            position: absolute;
            font-size: 160px;
            font-weight: 300;
            color: #d1d5db;
            opacity: 0.6;
            pointer-events: none;
            z-index: 1;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .character-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            z-index: 2;
            touch-action: none; /* ÌÑ∞Ïπò Ïä§ÌÅ¨Î°§ Î∞è Ï§å Î∞©ÏßÄ */
        }

        .crosshair-guide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .crosshair-guide::before,
        .crosshair-guide::after {
            content: '';
            position: absolute;
            background: #cbd5e0;
            opacity: 0.3;
        }

        .crosshair-guide::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            border-top: 1px dashed #cbd5e0;
        }

        .crosshair-guide::after {
            top: 0;
            left: 50%;
            width: 1px;
            height: 100%;
            border-left: 1px dashed #cbd5e0;
        }

        .status-indicator {
            position: absolute;
            bottom: -50px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: auto;
            padding: 0;
            border: none;
            background: none;
            box-shadow: none;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .status-indicator.red {
            color: #000;
        }

        .status-indicator.green {
            color: #000;
        }

        .status-indicator.yellow {
            color: #000;
        }

        .character-index {
            position: absolute;
            top: -25px;
            left: 5px;
            font-size: 14px;
            color: #718096;
            font-weight: bold;
        }



        .tool-controls {
            display: flex;
            justify-content: space-between;
            gap: 15px;
            margin: 20px 0;
            max-width: 400px;
            margin-left: auto;
            margin-right: auto;
        }

        .tool-controls .btn {
            flex: 1;
            padding: 12px 20px;
            font-size: 1.1rem;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: nowrap;
            margin-bottom: 20px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .instructions {
            text-align: center;
            color: #718096;
            font-size: clamp(1rem, 2.5vw, 1.2rem);
            margin-bottom: 20px;
            padding: 20px;
            background: #edf2f7;
            border-radius: 10px;
            word-break: keep-all;
            line-height: 1.5;
        }

        /* ÎèôÏ†Å Ìè∞Ìä∏ ÌÅ¨Í∏∞ Ï°∞Ï†ïÏùÑ ÏúÑÌïú ÌÅ¥ÎûòÏä§Îì§ */
        .dynamic-text {
            transition: font-size 0.2s ease;
        }

        .auto-resize-text {
            display: inline-block;
            max-width: 100%;
            overflow: hidden;
        }

        .score-display {
            text-align: center;
            padding: 25px;
            margin: 20px 0;
            border-radius: 15px;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .score-excellent {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            color: #155724;
            border: 2px solid #c3e6cb;
        }

        .score-good {
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            color: #856404;
            border: 2px solid #ffeaa7;
        }

        .score-needs-improvement {
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
            color: #721c24;
            border: 2px solid #f5c6cb;
        }

        .student-info {
            background: #e6fffa;
            border: 2px solid #81e6d9;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .assignment-info {
            background: #fef5e7;
            border: 2px solid #f6ad55;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .mobile-break {
            display: none;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 15px;
                margin: 0;
                border-radius: 10px;
                max-width: 100%;
                overflow-x: hidden;
            }
            

            
            .mobile-break {
                display: inline;
            }
            
            .title {
                font-size: clamp(1.5rem, 6vw, 2rem);
                word-break: keep-all;
                margin-bottom: 12px;
            }
            
            .title::after {
                width: 60px;
                height: 3px;
            }
            
            .subtitle {
                font-size: clamp(0.9rem, 3vw, 1.1rem);
            }

            .student-title-section {
                padding: 15px;
                margin-bottom: 20px;
            }

            .student-title {
                font-size: clamp(1.4rem, 5vw, 1.8rem);
                margin-bottom: 6px;
            }

            .student-subtitle {
                font-size: clamp(0.85rem, 2.5vw, 1rem);
            }
            
            .display-text {
                font-size: clamp(0.9rem, 3vw, 1.3rem);
                word-break: break-word;
                white-space: pre-wrap;
                overflow: visible;
                text-overflow: unset;
                padding: 12px 8px;
                min-height: 50px;
                line-height: 1.2;
            }
            
            .guide-text {
                font-size: 3rem;
                letter-spacing: 0.05em;
            }
            
            .canvas-container {
                height: 300px;
            }
            
            .input-section {
                flex-direction: column;
                gap: 10px;
            }
            
            .text-input {
                min-width: 100%;
                font-size: 1.2rem;
                padding: 12px 20px;
            }

            .btn {
                padding: 12px 20px;
                font-size: 1rem;
                width: 100%;
            }

            .character-box {
                width: 150px;
                height: 150px;
                margin-bottom: 80px;
            }

            .character-guide {
                font-size: 120px;
                font-weight: 300;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .character-canvas {
                width: 150px;
                height: 150px;
            }

            .character-grid {
                gap: 20px;
                padding: 15px;
            }

            .assignment-text {
                font-size: clamp(1rem, 3vw, 1.3rem);
                word-break: break-word;
                white-space: pre-wrap;
                overflow: visible;
                text-overflow: unset;
                line-height: 1.3;
            }

            .student-header {
                padding: 12px 15px;
                margin-bottom: 15px;
                max-width: 95%;
                min-height: 70px;
            }

            .student-header h2 {
                font-size: clamp(0.9rem, 2.5vw, 1rem);
                margin-bottom: 6px;
                text-align: center;
            }

            .instructions {
                font-size: 1rem;
                padding: 12px;
                margin-bottom: 15px;
            }

            .tool-controls {
                max-width: 100%;
                margin: 15px 0;
                gap: 10px;
            }

            .tool-controls .btn {
                padding: 10px 15px;
                font-size: 1rem;
            }

            .controls {
                gap: 10px;
                flex-wrap: wrap;
                max-width: 100%;
            }

            .controls .btn {
                padding: 12px;
                font-size: 1rem;
                min-width: 120px;
            }

            .assignment-info, .teacher-only-notice {
                padding: 10px;
                margin-bottom: 15px;
            }

            .assignment-info h3 {
                font-size: 1rem;
                margin-bottom: 6px;
            }

            .assignment-info p {
                font-size: 0.8rem;
                line-height: 1.3;
            }

            .teacher-only-notice p {
                font-size: 0.9rem;
            }

            .assignment-link {
                padding: 15px;
                margin: 15px 0;
            }

            .score-display {
                padding: 15px;
                font-size: 1.2rem;
            }

            .status-indicator {
                bottom: -40px;
                width: 150px;
                font-size: 10px;
            }

            .evaluation-content {
                padding: 20px;
                margin: 20px;
            }

            .evaluation-title {
                font-size: 1.5rem;
            }

            .evaluation-score {
                font-size: 2.2rem;
            }

            .evaluation-message {
                font-size: 1rem;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            
            .container {
                padding: 10px;
            }
            

            
            .title {
                font-size: clamp(1.6rem, 6.5vw, 1.9rem);
                margin-bottom: 10px;
            }

            .title::after {
                width: 50px;
                height: 2px;
            }

            .subtitle {
                font-size: clamp(0.8rem, 3.5vw, 0.95rem);
            }

            .student-title-section {
                padding: 12px;
                margin-bottom: 15px;
            }

            .student-title {
                font-size: clamp(1.3rem, 6vw, 1.5rem);
                margin-bottom: 5px;
            }

            .student-subtitle {
                font-size: clamp(0.8rem, 3vw, 0.9rem);
            }
            
            .display-text {
                font-size: clamp(1.1rem, 5vw, 1.3rem);
            }
            
            .guide-text {
                font-size: 2.5rem;
            }
            
            .canvas-container {
                height: 250px;
            }

            .character-box {
                width: 120px;
                height: 120px;
                margin-bottom: 70px;
            }

            .character-guide {
                font-size: 90px;
                font-weight: 300;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .character-canvas {
                width: 120px;
                height: 120px;
            }

            .character-grid {
                gap: 15px;
                padding: 10px;
            }

            .assignment-text {
                font-size: clamp(0.9rem, 4vw, 1.1rem);
                word-break: break-word;
                white-space: pre-wrap;
                overflow: visible;
                text-overflow: unset;
                line-height: 1.2;
            }

            .student-header h2 {
                font-size: clamp(0.8rem, 3vw, 0.9rem);
                margin-bottom: 5px;
                text-align: center;
            }

            .btn {
                font-size: 0.9rem;
                padding: 10px 15px;
            }

            .controls .btn {
                min-width: 100px;
                font-size: 0.85rem;
            }

            .status-indicator {
                bottom: -35px;
                width: 120px;
                font-size: 9px;
            }

            .evaluation-content {
                padding: 15px;
                margin: 10px;
            }

            .evaluation-title {
                font-size: 1.3rem;
            }

            .evaluation-score {
                font-size: 2rem;
            }

            .evaluation-message {
                font-size: 0.9rem;
            }
        }

        .hidden {
            display: none;
        }

        .copy-notification {
            position: relative;
            margin-top: 15px;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 500;
            text-align: center;
            opacity: 1;
            transform: translateY(0);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            animation: notificationSlideIn 0.4s ease-out;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .copy-notification.success {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            color: #155724;
            border: 2px solid #c3e6cb;
        }

        .copy-notification.error {
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
            color: #721c24;
            border: 2px solid #f5c6cb;
        }

        @keyframes notificationSlideIn {
            from {
                opacity: 0;
                transform: translateY(10px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .active-tool {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%) !important;
            color: white !important;
            box-shadow: 0 4px 12px rgba(72, 187, 120, 0.4) !important;
            transform: translateY(-1px) !important;
        }

        .active-tool:hover {
            background: linear-gradient(135deg, #38a169 0%, #2f855a 100%) !important;
        }



        .student-title {
            color: #1a1a1a;
            font-size: clamp(1.5rem, 4vw, 2.2rem);
            font-weight: 800;
            margin-bottom: 8px;
            letter-spacing: 0.5px;
            animation: studentTitleGlow 1s ease-out 0.3s both;
            background: linear-gradient(45deg, #1a1a1a 25%, #4a5568 50%, #1a1a1a 75%);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: studentTitleGlow 1s ease-out 0.3s both, shimmerText 3s ease-in-out infinite;
        }

        .student-subtitle {
            color: #64748b;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            font-weight: 500;
            margin: 0;
            animation: studentSubtitleFade 0.8s ease-out 0.5s both;
        }

        .student-subtitle::before {
            content: 'üìö';
            margin-right: 6px;
            font-size: 0.9em;
        }

        .student-subtitle::after {
            content: 'üìù';
            margin-left: 6px;
            font-size: 0.9em;
        }

        @keyframes studentTitleFadeIn {
            from { 
                opacity: 0; 
                transform: translateY(-10px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }

        @keyframes studentTitleGlow {
            from { 
                opacity: 0; 
                transform: scale(0.95); 
            }
            to { 
                opacity: 1; 
                transform: scale(1); 
            }
        }

        @keyframes studentSubtitleFade {
            from { 
                opacity: 0; 
                transform: translateY(10px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }

        .student-header {
            text-align: center;
            margin-bottom: 20px;
            margin-top: 30px;
            padding: 15px 20px;
            background: linear-gradient(135deg, #e6fffa 0%, #b2f5ea 100%);
            border-radius: 10px;
            border: 2px solid #4fd1c7;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .assignment-text {
            color: #2d3748;
            font-weight: bold;
            line-height: 1.4;
            word-break: break-word;
            overflow-wrap: break-word;
            white-space: pre-wrap;
            margin: 0;
            padding: 5px 0;
            text-align: center;
        }

        .student-header h2 {
            color: #234e52;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
            margin-bottom: 8px;
            font-weight: 600;
            text-align: center;
        }

        .student-header h2 span {
            color: #2d3748;
            font-weight: bold;
        }

        .student-main {
            display: flex;
            gap: 30px;
            height: calc(100vh - 300px);
            min-height: 500px;
        }

        .canvas-section {
            flex: 2;
        }

        .control-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            min-width: 300px;
        }

        .student-main .canvas-container {
            height: 100%;
            min-height: 400px;
        }

        .student-main .instructions {
            font-size: 1.1rem;
            padding: 15px;
            margin-bottom: 20px;
        }

        .student-main .controls {
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }

        .student-main .controls .btn {
            width: 100%;
            padding: 15px;
            font-size: 1.1rem;
        }

        /* ÌèâÍ∞Ä ÌåùÏóÖ Ïä§ÌÉÄÏùº */
        .evaluation-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: popupFadeIn 0.3s ease-out;
        }

        .evaluation-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            animation: popupSlideIn 0.3s ease-out;
        }

        .evaluation-title {
            font-size: 2rem;
            margin-bottom: 20px;
            color: #2d3748;
            font-weight: bold;
        }

        .evaluation-score {
            font-size: 3rem;
            font-weight: bold;
            margin: 20px 0;
        }

        .evaluation-message {
            font-size: 1.2rem;
            margin-bottom: 30px;
            line-height: 1.6;
            color: #4a5568;
        }

        .popup-close-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 12px 30px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .popup-close-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        @keyframes popupFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes popupSlideIn {
            from { 
                opacity: 0; 
                transform: translateY(-30px) scale(0.9); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0) scale(1); 
            }
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">Í∏ÄÏî® ÏöîÏ†ï</h1>
            <p class="subtitle">ÍµêÏÇ¨ÏôÄ ÌïôÏÉùÏùÑ ÏúÑÌïú Î∞îÎ•∏ Í∏ÄÏî® Ïó∞Ïäµ ÎèÑÍµ¨</p>
        </div>

        <div class="mode-selector" id="modeSelector">
        </div>

        <!-- ÍµêÏÇ¨ ÌôîÎ©¥ -->
        <div id="teacherScreen" class="screen active">
            <div class="assignment-info" style="padding: 12px; margin-bottom: 20px; margin-top: 2px; max-width: 500px; margin-left: auto; margin-right: auto; text-align: center;">
                <h3 style="font-size: 1.1rem; margin-bottom: 8px;">üìù Í≥ºÏ†ú Ï†úÏûëÎ≤ï</h3>
                <p style="font-size: 0.9rem; margin: 0; word-break: keep-all; line-height: 1.4;">ÌïôÏÉùÎì§Ïù¥ Îî∞Îùº Ïì∏ Í∏ÄÏî®Î•º ÏÑ§Ï†ïÌïòÍ≥† Í≥ºÏ†ú ÎßÅÌÅ¨Î•º ÏÉùÏÑ±ÌïòÏÑ∏Ïöî.</p>
            </div>

            <div class="input-section">
                <input type="text" id="teacherTextInput" class="text-input" placeholder="ÌïôÏÉùÎì§Ïù¥ Îî∞Îùº Ïì∏ Í∏ÄÏî®Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî" value="">
                <button onclick="createAssignment()" class="btn btn-primary">üìã Í≥ºÏ†ú ÏÉùÏÑ±</button>
            </div>

            <div style="margin-top: 20px; background: white; border: 2px solid #667eea; border-radius: 10px; padding: 20px;">
                <h3 style="text-align: center; margin-bottom: 15px;">üéØ Ïì∞Í∏∞ Î™©Ìëú</h3>
                <div class="display-text" id="teacherDisplayText">ÏûÖÎ†•Îêú Í∏ÄÏî®Í∞Ä Ïó¨Í∏∞Ïóê ÌëúÏãúÎê©ÎãàÎã§</div>
            </div>

            <div class="assignment-link" id="assignmentLink" style="display: none;">
                <h3>üîó Í≥ºÏ†ú Î∞∞Î∂Ä</h3>
                <p style="margin-bottom: 25px;">Í≥ºÏ†úÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÉùÏÑ±ÎêòÏóàÏäµÎãàÎã§! ÏïÑÎûò Î≤ÑÌäºÏùÑ ÌÅ¥Î¶≠ÌïòÏó¨ Í≥ºÏ†ú ÎßÅÌÅ¨Î•º Î≥µÏÇ¨ÌïòÍ≥†, ÌïôÏÉùÎì§ÏóêÍ≤å Í≥µÏú†ÌïòÏÑ∏Ïöîüòä</p>
                <button onclick="copyLink()" class="btn btn-success">üìã ÎßÅÌÅ¨ Î≥µÏÇ¨</button>
            </div>


        </div>

        <!-- ÌïôÏÉù ÌôîÎ©¥ -->
        <div id="studentScreen" class="screen">
            <div class="student-header">
                <h2>üìù Ïì∞Í∏∞ Î™©Ìëú</h2>
                <div class="assignment-text" id="studentDisplayText">Í≥ºÏ†úÎ•º Î∂àÎü¨Ïò§Îäî Ï§ë...</div>
            </div>

            <div class="tool-controls">
                <button id="pencilBtn" onclick="setDrawingMode('pencil')" class="btn btn-primary active-tool">‚úèÔ∏è Ïó∞ÌïÑ</button>
                <button id="eraserBtn" onclick="setDrawingMode('eraser')" class="btn btn-secondary">üßΩ ÏßÄÏö∞Í∞ú</button>
            </div>

            <div class="instructions">
                üìù Í∞Å Ïπ∏Ïùò ÌöåÏÉâ Í∏ÄÏî®Î•º Ï†ïÌôïÌûà Îî∞Îùº Ïç® Î≥¥ÏÑ∏Ïöî! Í∏ÄÏî®Î•º Î∞îÎ•¥Í≤å Ïì∞Î©¥ Ïπ≠Ï∞¨ Î©îÏãúÏßÄÍ∞Ä ÎÇòÌÉÄÎÇòÏöîüòä<br class="mobile-break">
            </div>

            <div class="character-grid" id="characterGrid" style="margin-top: 40px;">
                <!-- Í∏ÄÏûêÎ≥Ñ Ïπ∏Îì§Ïù¥ Ïó¨Í∏∞Ïóê ÎèôÏ†ÅÏúºÎ°ú ÏÉùÏÑ±Îê©ÎãàÎã§ -->
            </div>

            <div class="controls">
                <button onclick="clearAllCanvas()" class="btn btn-primary" style="flex: 1; min-width: 0;">üóëÔ∏è Î™®Îëê ÏßÄÏö∞Í∏∞</button>
                <button onclick="evaluateHandwriting()" class="btn btn-evaluate" style="flex: 1; min-width: 0;">üîç Í∏ÄÏî® ÌèâÍ∞Ä</button>
                <button onclick="saveResult()" class="btn btn-success" style="flex: 1; min-width: 0;">üíæ Í≤∞Í≥º Ï†ÄÏû•</button>
            </div>


        </div>
    </div>

    <script>
        let currentAssignment = '';
        let characterCanvases = [];
        let characterData = [];
        let currentDrawingMode = 'pencil'; // 'pencil' ÎòêÎäî 'eraser'

        // Í∑∏Î¶¨Í∏∞ Î™®Îìú ÏÑ§Ï†ï
        function setDrawingMode(mode) {
            currentDrawingMode = mode;
            
            // Î≤ÑÌäº Ïä§ÌÉÄÏùº ÏóÖÎç∞Ïù¥Ìä∏
            const pencilBtn = document.getElementById('pencilBtn');
            const eraserBtn = document.getElementById('eraserBtn');
            
            if (mode === 'pencil') {
                // Ïó∞ÌïÑ Î≤ÑÌäº ÌôúÏÑ±Ìôî (Ï¥àÎ°ùÏÉâ Î∞∞Í≤Ω)
                pencilBtn.classList.add('active-tool');
                pencilBtn.classList.remove('btn-secondary');
                pencilBtn.classList.add('btn-primary');
                
                // ÏßÄÏö∞Í∞ú Î≤ÑÌäº ÎπÑÌôúÏÑ±Ìôî (Ìù∞ÏÉâ Î∞∞Í≤Ω, Ï¥àÎ°ù ÌÖåÎëêÎ¶¨)
                eraserBtn.classList.remove('active-tool');
                eraserBtn.classList.remove('btn-primary');
                eraserBtn.classList.add('btn-secondary');
            } else {
                // ÏßÄÏö∞Í∞ú Î≤ÑÌäº ÌôúÏÑ±Ìôî (Ï¥àÎ°ùÏÉâ Î∞∞Í≤Ω)
                eraserBtn.classList.add('active-tool');
                eraserBtn.classList.remove('btn-secondary');
                eraserBtn.classList.add('btn-primary');
                
                // Ïó∞ÌïÑ Î≤ÑÌäº ÎπÑÌôúÏÑ±Ìôî (Ìù∞ÏÉâ Î∞∞Í≤Ω, Ï¥àÎ°ù ÌÖåÎëêÎ¶¨)
                pencilBtn.classList.remove('active-tool');
                pencilBtn.classList.remove('btn-primary');
                pencilBtn.classList.add('btn-secondary');
            }
            
            // Î™®Îì† Ï∫îÎ≤ÑÏä§Ïùò Ïª§ÏÑú Ïä§ÌÉÄÏùº ÏóÖÎç∞Ïù¥Ìä∏
            characterCanvases.forEach(canvasData => {
                if (mode === 'pencil') {
                    canvasData.canvas.style.cursor = 'crosshair';
                } else {
                    canvasData.canvas.style.cursor = 'grab';
                }
            });
        }

        // Í∏ÄÏûêÎ≥Ñ Ï∫îÎ≤ÑÏä§ ÏÉùÏÑ±
        function createCharacterBoxes(text) {
            const grid = document.getElementById('characterGrid');
            grid.innerHTML = '';
            characterCanvases = [];
            characterData = [];

            let boxIndex = 0; // Ïã§Ï†ú Î∞ïÏä§ Ïù∏Îç±Ïä§
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                // Í≥µÎ∞±Îßå Í±¥ÎÑàÎõ∞Í∏∞ (ÌïúÍ∏Ä, ÏòÅÏñ¥ ÎåÄÏÜåÎ¨∏Ïûê, Ïà´Ïûê, Í∏∞Ìò∏ Î™®Îëê Ìè¨Ìï®)
                if (char === ' ') {
                    continue;
                }

                const box = document.createElement('div');
                box.className = 'character-box';

                const index = document.createElement('div');
                index.className = 'character-index';
                index.textContent = boxIndex + 1;



                const guide = document.createElement('div');
                guide.className = 'character-guide';
                guide.textContent = char; // ÏõêÎ≥∏ Î¨∏Ïûê Í∑∏ÎåÄÎ°ú ÌëúÏãú (ÎåÄÏÜåÎ¨∏Ïûê Íµ¨Î∂Ñ)

                const crosshair = document.createElement('div');
                crosshair.className = 'crosshair-guide';

                const canvas = document.createElement('canvas');
                canvas.className = 'character-canvas';
                canvas.width = 200;
                canvas.height = 200;
                canvas.style.width = '100%';
                canvas.style.height = '100%';
                canvas.style.cursor = 'crosshair'; // Í∏∞Î≥∏ Ïó∞ÌïÑ Î™®Îìú

                const indicator = document.createElement('div');
                indicator.className = 'status-indicator red';
                indicator.textContent = evaluationMessages.red[0]; // Ï¥àÍ∏∞ Î©îÏãúÏßÄ ÏÑ§Ï†ï

                box.appendChild(index);
                box.appendChild(guide);
                box.appendChild(crosshair);
                box.appendChild(canvas);
                box.appendChild(indicator);
                grid.appendChild(box);

                // Ï∫îÎ≤ÑÏä§ ÏÑ§Ï†ï
                const ctx = canvas.getContext('2d');
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                characterCanvases.push({
                    canvas: canvas,
                    ctx: ctx,
                    char: char,
                    indicator: indicator,
                    isDrawing: false,
                    drawingData: []
                });

                characterData.push({
                    char: char,
                    completed: false
                });

                // Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï∂îÍ∞Ä
                setupCanvasEvents(canvas, boxIndex);
                boxIndex++; // Î∞ïÏä§ Ïù∏Îç±Ïä§ Ï¶ùÍ∞Ä
            }
        }

        // Ï∫îÎ≤ÑÏä§ Ïù¥Î≤§Ìä∏ ÏÑ§Ï†ï
        function setupCanvasEvents(canvas, index) {
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;

            function getEventPos(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                let clientX, clientY;
                if (e.touches && e.touches[0]) {
                    // ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏Ïùò Í≤ΩÏö∞ Ï†ïÌôïÌïú ÌÑ∞Ïπò Ìè¨Ïù∏Ìä∏ ÏÇ¨Ïö©
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else if (e.changedTouches && e.changedTouches[0]) {
                    // touchend Ïù¥Î≤§Ìä∏Ïùò Í≤ΩÏö∞ changedTouches ÏÇ¨Ïö©
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                } else {
                    // ÎßàÏö∞Ïä§ Ïù¥Î≤§Ìä∏
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            }

            function startDrawing(e) {
                e.preventDefault();
                e.stopPropagation(); // Ïù¥Î≤§Ìä∏ Ï†ÑÌåå Î∞©ÏßÄ
                
                // ÌòÑÏû¨ Ï∫îÎ≤ÑÏä§Í∞Ä Ïã§Ï†ú ÌÑ∞ÏπòÎêú Ï∫îÎ≤ÑÏä§Ïù∏ÏßÄ ÌôïÏù∏
                if (e.target !== canvas) return;
                
                isDrawing = true;
                const pos = getEventPos(e);
                lastX = pos.x;
                lastY = pos.y;
                
                const ctx = characterCanvases[index].ctx;
                
                if (currentDrawingMode === 'pencil') {
                    ctx.globalCompositeOperation = 'source-over';
                    characterCanvases[index].drawingData.push({x: lastX, y: lastY, type: 'start'});
                } else if (currentDrawingMode === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    // ÏßÄÏö∞Í∞ú ÏãúÏûëÏ†êÏóêÏÑúÎèÑ ÏßÄÏö∞Í∏∞
                    ctx.beginPath();
                    ctx.arc(lastX, lastY, 15, 0, 2 * Math.PI);
                    ctx.fill();
                    characterCanvases[index].drawingData.push({x: lastX, y: lastY, type: 'erase_start'});
                }
            }

            function draw(e) {
                if (!isDrawing) return;
                e.preventDefault();
                e.stopPropagation(); // Ïù¥Î≤§Ìä∏ Ï†ÑÌåå Î∞©ÏßÄ
                
                // ÌòÑÏû¨ Ï∫îÎ≤ÑÏä§Í∞Ä Ïã§Ï†ú ÌÑ∞ÏπòÎêú Ï∫îÎ≤ÑÏä§Ïù∏ÏßÄ ÌôïÏù∏
                if (e.target !== canvas) return;
                
                const pos = getEventPos(e);
                const currentX = pos.x;
                const currentY = pos.y;

                const ctx = characterCanvases[index].ctx;
                
                if (currentDrawingMode === 'pencil') {
                    // Ïó∞ÌïÑ Î™®Îìú: Í∑∏Î¶¨Í∏∞
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.beginPath();
                    ctx.moveTo(lastX, lastY);
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                    
                    characterCanvases[index].drawingData.push({x: currentX, y: currentY, type: 'draw'});
                } else if (currentDrawingMode === 'eraser') {
                    // ÏßÄÏö∞Í∞ú Î™®Îìú: ÏßÄÏö∞Í∏∞
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath();
                    ctx.arc(currentX, currentY, 15, 0, 2 * Math.PI); // ÏõêÌòï ÏßÄÏö∞Í∞ú
                    ctx.fill();
                    
                    characterCanvases[index].drawingData.push({x: currentX, y: currentY, type: 'erase'});
                }
                
                lastX = currentX;
                lastY = currentY;

                // Ïã§ÏãúÍ∞Ñ ÌèâÍ∞Ä
                evaluateCharacter(index);
            }

            function stopDrawing(e) {
                if (isDrawing) {
                    e.preventDefault();
                    e.stopPropagation(); // Ïù¥Î≤§Ìä∏ Ï†ÑÌåå Î∞©ÏßÄ
                    
                    // Í∑∏Î¶¨Í∏∞ Î™®ÎìúÏóê Îî∞Îùº Îã§Î•∏ Ï¢ÖÎ£å ÌÉÄÏûÖ Í∏∞Î°ù
                    if (currentDrawingMode === 'pencil') {
                        characterCanvases[index].drawingData.push({type: 'end'});
                    } else {
                        characterCanvases[index].drawingData.push({type: 'erase_end'});
                    }
                    
                    // Ïª®ÌÖçÏä§Ìä∏Î•º Í∏∞Î≥∏ Í∑∏Î¶¨Í∏∞ Î™®ÎìúÎ°ú Î≥µÏõê
                    const ctx = characterCanvases[index].ctx;
                    ctx.globalCompositeOperation = 'source-over';
                }
                isDrawing = false;
            }

            // ÎßàÏö∞Ïä§ Ïù¥Î≤§Ìä∏
            canvas.addEventListener('mousedown', startDrawing, {passive: false});
            canvas.addEventListener('mousemove', draw, {passive: false});
            canvas.addEventListener('mouseup', stopDrawing, {passive: false});
            canvas.addEventListener('mouseout', stopDrawing, {passive: false});
            
            // ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏ (passive: falseÎ°ú preventDefault ÌóàÏö©)
            canvas.addEventListener('touchstart', startDrawing, {passive: false});
            canvas.addEventListener('touchmove', draw, {passive: false});
            canvas.addEventListener('touchend', stopDrawing, {passive: false});
            canvas.addEventListener('touchcancel', stopDrawing, {passive: false});
        }

        // ÌôîÎ©¥ Ï†ÑÌôò
        function switchMode(mode) {
            document.querySelectorAll('.screen').forEach(screen => screen.classList.remove('active'));
            
            if (mode === 'teacher') {
                document.getElementById('teacherScreen').classList.add('active');
                document.getElementById('modeSelector').style.display = 'flex';
            } else {
                document.getElementById('studentScreen').classList.add('active');
                document.getElementById('modeSelector').style.display = 'none';
                loadAssignmentFromURL();
            }
        }

        // ÍµêÏÇ¨ Í∏∞Îä•: Í≥ºÏ†ú ÏÉùÏÑ±
        let generatedLink = '';
        
        // Ïã§ÏãúÍ∞Ñ ÌÖçÏä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏
        function updateDisplayText() {
            const text = document.getElementById('teacherTextInput').value || 'ÏûÖÎ†•Îêú Í∏ÄÏî®Í∞Ä Ïó¨Í∏∞Ïóê ÌëúÏãúÎê©ÎãàÎã§';
            const displayElement = document.getElementById('teacherDisplayText');
            displayElement.textContent = text;
            
            // ÌÖçÏä§Ìä∏ Í∏∏Ïù¥Ïóê Îî∞Îùº Ìè∞Ìä∏ ÌÅ¨Í∏∞ ÏûêÎèô Ï°∞Ï†ï
            adjustFontSize(displayElement);
        }
        
        // ÎèôÏ†Å Ìè∞Ìä∏ ÌÅ¨Í∏∞ Ï°∞Ï†ï Ìï®Ïàò (Í∞úÏÑ†Îêú Î≤ÑÏ†Ñ)
        function adjustFontSize(element) {
            const text = element.textContent;
            const textLength = text.length;
            
            // Ïª®ÌÖåÏù¥ÎÑàÏùò Ïã§Ï†ú ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÎÑàÎπÑ Í≥ÑÏÇ∞
            const containerStyle = window.getComputedStyle(element);
            const paddingLeft = parseFloat(containerStyle.paddingLeft);
            const paddingRight = parseFloat(containerStyle.paddingRight);
            const availableWidth = element.offsetWidth - paddingLeft - paddingRight;
            
            // ÏûÑÏãú Ï∏°Ï†ïÏö© ÏöîÏÜå ÏÉùÏÑ±
            const measurer = document.createElement('span');
            measurer.style.visibility = 'hidden';
            measurer.style.position = 'absolute';
            measurer.style.whiteSpace = 'nowrap';
            measurer.style.fontFamily = containerStyle.fontFamily;
            measurer.style.fontWeight = containerStyle.fontWeight;
            measurer.textContent = text;
            document.body.appendChild(measurer);
            
            // Ï†ÅÏ†àÌïú Ìè∞Ìä∏ ÌÅ¨Í∏∞ Ï∞æÍ∏∞
            let fontSize = Math.min(40, availableWidth / textLength * 2.5); // Ï¥àÍ∏∞ Ï∂îÏ†ïÍ∞í
            let maxFontSize = 40;
            let minFontSize = 12;
            
            // Ïù¥ÏßÑ ÌÉêÏÉâÏúºÎ°ú ÏµúÏ†Å Ìè∞Ìä∏ ÌÅ¨Í∏∞ Ï∞æÍ∏∞
            for (let i = 0; i < 15; i++) {
                measurer.style.fontSize = fontSize + 'px';
                const textWidth = measurer.offsetWidth;
                
                if (textWidth > availableWidth) {
                    maxFontSize = fontSize;
                    fontSize = (minFontSize + fontSize) / 2;
                } else {
                    minFontSize = fontSize;
                    fontSize = (fontSize + maxFontSize) / 2;
                }
                
                // Ï∂©Î∂ÑÌûà Ï†ïÌôïÌïòÎ©¥ Ï¢ÖÎ£å
                if (Math.abs(textWidth - availableWidth) < 10) {
                    break;
                }
            }
            
            // ÏïàÏ†Ñ Ïó¨Î∞± Ï†ÅÏö© (95% ÌÅ¨Í∏∞Î°ú)
            fontSize = fontSize * 0.95;
            
            // ÏµúÏÜå/ÏµúÎåÄ ÌÅ¨Í∏∞ Ï†úÌïú
            fontSize = Math.max(12, Math.min(40, fontSize));
            
            // Ï∏°Ï†ïÏö© ÏöîÏÜå Ï†úÍ±∞
            document.body.removeChild(measurer);
            
            // Ìè∞Ìä∏ ÌÅ¨Í∏∞ Ï†ÅÏö©
            element.style.fontSize = fontSize + 'px';
            
            // Î†àÏù¥ÏïÑÏõÉ ÏÑ§Ï†ï
            if (textLength > 30 || fontSize < 16) {
                element.style.minHeight = 'auto';
                element.style.height = 'auto';
                element.style.alignItems = 'flex-start';
                element.style.paddingTop = '20px';
                element.style.whiteSpace = 'pre-wrap';
                element.style.wordBreak = 'break-word';
                element.style.lineHeight = '1.3';
            } else {
                element.style.minHeight = '80px';
                element.style.alignItems = 'center';
                element.style.paddingTop = '0';
                element.style.whiteSpace = 'nowrap';
                element.style.wordBreak = 'normal';
                element.style.lineHeight = '1.2';
            }
            
            // ÏµúÏ¢Ö Í≤ÄÏ¶ù - Ïó¨Ï†ÑÌûà ÎÑòÏñ¥Í∞ÄÎ©¥ Ï§ÑÎ∞îÍøà Í∞ïÏ†ú Ï†ÅÏö©
            setTimeout(() => {
                if (element.scrollWidth > element.offsetWidth) {
                    element.style.whiteSpace = 'pre-wrap';
                    element.style.wordBreak = 'break-word';
                    element.style.alignItems = 'flex-start';
                    element.style.paddingTop = '20px';
                    element.style.lineHeight = '1.3';
                }
            }, 10);
        }
        
        function createAssignment() {
            const text = document.getElementById('teacherTextInput').value.trim();
            if (!text) {
                alert('Îî∞Îùº Ïì∏ Í∏ÄÏî®Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.');
                return;
            }

            document.getElementById('teacherDisplayText').textContent = text;
            
            // URLÏóê Í≥ºÏ†ú Ï†ïÎ≥¥ Ïù∏ÏΩîÎî©
            const assignmentData = btoa(encodeURIComponent(text));
            generatedLink = `${window.location.origin}${window.location.pathname}?assignment=${assignmentData}`;
            
            document.getElementById('assignmentLink').style.display = 'block';
        }

        // ÎßÅÌÅ¨ Î≥µÏÇ¨
        function copyLink() {
            if (!generatedLink) {
                showCopyNotification('Î®ºÏ†Ä Í≥ºÏ†úÎ•º ÏÉùÏÑ±Ìï¥Ï£ºÏÑ∏Ïöî.', 'error');
                return;
            }
            
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(generatedLink).then(() => {
                    showCopyNotification('‚úÖ ÎßÅÌÅ¨Í∞Ä ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§!', 'success');
                }).catch(err => {
                    // ÌÅ¥Î¶ΩÎ≥¥Îìú API Ïã§Ìå® Ïãú ÎåÄÏ≤¥ Î∞©Î≤ï
                    fallbackCopyTextToClipboard(generatedLink);
                });
            } else {
                // ÌÅ¥Î¶ΩÎ≥¥Îìú APIÎ•º ÏßÄÏõêÌïòÏßÄ ÏïäÎäî Î∏åÎùºÏö∞Ï†ÄÏö© ÎåÄÏ≤¥ Î∞©Î≤ï
                fallbackCopyTextToClipboard(generatedLink);
            }
        }

        // ÌÅ¥Î¶ΩÎ≥¥Îìú API ÎåÄÏ≤¥ Î∞©Î≤ï
        function fallbackCopyTextToClipboard(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "fixed";
            textArea.style.left = "-999999px";
            textArea.style.top = "-999999px";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showCopyNotification('‚úÖ ÎßÅÌÅ¨Í∞Ä ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨ÎêòÏóàÏäµÎãàÎã§!', 'success');
                } else {
                    showCopyNotification('‚ùå ÎßÅÌÅ¨ Î≥µÏÇ¨Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.', 'error');
                }
            } catch (err) {
                showCopyNotification('‚ùå ÎßÅÌÅ¨ Î≥µÏÇ¨Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.', 'error');
            }
            
            document.body.removeChild(textArea);
        }

        // Î≥µÏÇ¨ ÏïåÎ¶º ÌëúÏãú
        function showCopyNotification(message, type) {
            // Í∏∞Ï°¥ ÏïåÎ¶ºÏù¥ ÏûàÏúºÎ©¥ Ï†úÍ±∞
            const existingNotification = document.querySelector('.copy-notification');
            if (existingNotification) {
                existingNotification.remove();
            }
            
            // ÏïåÎ¶º ÏöîÏÜå ÏÉùÏÑ±
            const notification = document.createElement('div');
            notification.className = `copy-notification ${type}`;
            notification.textContent = message;
            
            // ÏïåÎ¶ºÏùÑ ÎßÅÌÅ¨ Î≥µÏÇ¨ Î≤ÑÌäº Í∑ºÏ≤òÏóê ÌëúÏãú
            const assignmentLink = document.getElementById('assignmentLink');
            assignmentLink.appendChild(notification);
            
            // 3Ï¥à ÌõÑ ÏûêÎèô Ï†úÍ±∞
            setTimeout(() => {
                if (notification && notification.parentNode) {
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateY(-10px)';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.remove();
                        }
                    }, 300);
                }
            }, 3000);
        }



        // ÌïúÍ∏Ä ÏûêÎ™® Î∂ÑÌï¥ Ìï®Ïàò
        function decomposeHangul(char) {
            const code = char.charCodeAt(0) - 0xAC00;
            if (code < 0 || code > 11171) return null; // ÌïúÍ∏ÄÏù¥ ÏïÑÎãå Í≤ΩÏö∞
            
            const chosung = Math.floor(code / 588);
            const jungsung = Math.floor((code % 588) / 28);
            const jongsung = code % 28;
            
            const chosungList = ['„Ñ±', '„Ñ≤', '„Ñ¥', '„Ñ∑', '„Ñ∏', '„Ñπ', '„ÖÅ', '„ÖÇ', '„ÖÉ', '„ÖÖ', '„ÖÜ', '„Öá', '„Öà', '„Öâ', '„Öä', '„Öã', '„Öå', '„Öç', '„Öé'];
            const jungsungList = ['„Öè', '„Öê', '„Öë', '„Öí', '„Öì', '„Öî', '„Öï', '„Öñ', '„Öó', '„Öò', '„Öô', '„Öö', '„Öõ', '„Öú', '„Öù', '„Öû', '„Öü', '„Ö†', '„Ö°', '„Ö¢', '„Ö£'];
            const jongsungList = ['', '„Ñ±', '„Ñ≤', '„Ñ≥', '„Ñ¥', '„Ñµ', '„Ñ∂', '„Ñ∑', '„Ñπ', '„Ñ∫', '„Ñª', '„Ñº', '„ÑΩ', '„Ñæ', '„Ñø', '„ÖÄ', '„ÖÅ', '„ÖÇ', '„ÖÑ', '„ÖÖ', '„ÖÜ', '„Öá', '„Öà', '„Öä', '„Öã', '„Öå', '„Öç', '„Öé'];
            
            const result = {
                chosung: chosungList[chosung],
                jungsung: jungsungList[jungsung],
                jongsung: jongsungList[jongsung]
            };
            
            return result;
        }

        // ÌöåÏÉâ Í∞ÄÏù¥ÎìúÏÑ† ÌòïÌÉú ÏùºÏπò Í∏∞Î∞ò ÏóÑÍ≤©Ìïú ÌèâÍ∞Ä ÏãúÏä§ÌÖú
        function evaluateCharacter(index) {
            setTimeout(() => {
                const canvasData = characterCanvases[index];
                const char = canvasData.char;
                
                // ÏµúÏÜå Í∑∏Î¶¨Í∏∞ Îç∞Ïù¥ÌÑ∞ ÌôïÏù∏ (ÏôÑÌôî)
                if (canvasData.drawingData.length < 5) {
                    characterData[index].completed = false;
                    canvasData.indicator.className = 'status-indicator red';
                    return;
                }
                
                // ÏÉâÏπ†/ÌúòÍ∞àÍπÄ Ìå®ÌÑ¥ Í∞êÏßÄ (Îçî ÏóÑÍ≤©ÌïòÍ≤å)
                if (isScribbleOrFillPattern(canvasData.canvas)) {
                    characterData[index].completed = false;
                    canvasData.indicator.className = 'status-indicator red';
                    return;
                }
                
                // ÌöåÏÉâ Í∞ÄÏù¥ÎìúÏÑ†Í≥ºÏùò ÌòïÌÉú ÏùºÏπòÎèÑ ÌèâÍ∞Ä (Í∞ÄÏû• Ï§ëÏöîÌïú Í∏∞Ï§Ä)
                const guideMatchScore = calculateGuideLineMatchScore(canvasData.canvas, char);
                
                console.log(`Í∏ÄÏûê "${char}" - Í∞ÄÏù¥ÎìúÏÑ† ÏùºÏπòÎèÑ: ${guideMatchScore.toFixed(3)}`);
                
                // ÌöåÏÉâ Í∞ÄÏù¥ÎìúÏÑ† ÌòïÌÉú ÏùºÏπò Í∏∞Ï§ÄÏúºÎ°úÎßå ÌèâÍ∞Ä (ÏôÑÌôîÎêú Í∏∞Ï§Ä)
                let finalEvaluation;
                if (guideMatchScore >= 0.75) {
                    // Í∞ÄÏù¥ÎìúÏÑ†Í≥º 75% Ïù¥ÏÉÅ ÏùºÏπòÌïòÎ©¥ Ï¥àÎ°ùÎ∂à (Í∏∞Ï°¥ 85%ÏóêÏÑú ÏôÑÌôî)
                    finalEvaluation = 'Ï¥àÎ°ùÎ∂à';
                } else if (guideMatchScore >= 0.55) {
                    // Í∞ÄÏù¥ÎìúÏÑ†Í≥º 55% Ïù¥ÏÉÅ ÏùºÏπòÌïòÎ©¥ ÎÖ∏ÎûÄÎ∂à (Í∏∞Ï°¥ 65%ÏóêÏÑú ÏôÑÌôî)
                    finalEvaluation = 'ÎÖ∏ÎûÄÎ∂à';
                } else {
                    // Í∑∏ Ïô∏Îäî Î™®Îëê Îπ®Í∞ÑÎ∂à
                    finalEvaluation = 'Îπ®Í∞ÑÎ∂à';
                }
                
                setIndicatorByEvaluation(canvasData.indicator, characterData[index], finalEvaluation);
                
            }, 50);
        }

        // ÌöåÏÉâ Í∞ÄÏù¥ÎìúÏÑ†Í≥ºÏùò ÌòïÌÉú ÏùºÏπòÎèÑ Í≥ÑÏÇ∞ (ÌïµÏã¨ ÌèâÍ∞Ä Ìï®Ïàò)
        function calculateGuideLineMatchScore(canvas, char) {
            const ctx = canvas.getContext('2d');
            
            // ÌöåÏÉâ Í∞ÄÏù¥ÎìúÏÑ† ÌòïÌÉú ÏÉùÏÑ± (Ïã§Ï†ú ÌôîÎ©¥Ïóê ÌëúÏãúÎêòÎäî Í≤ÉÍ≥º ÎèôÏùº)
            const guideCanvas = document.createElement('canvas');
            guideCanvas.width = canvas.width;
            guideCanvas.height = canvas.height;
            const guideCtx = guideCanvas.getContext('2d');
            
            // ÌöåÏÉâ Í∞ÄÏù¥ÎìúÏÑ† Í∑∏Î¶¨Í∏∞ (ÌôîÎ©¥Í≥º ÎèôÏùºÌïú Ïä§ÌÉÄÏùº)
            guideCtx.font = 'bold 160px Arial';
            guideCtx.fillStyle = '#888888';
            guideCtx.textAlign = 'center';
            guideCtx.textBaseline = 'middle';
            guideCtx.fillText(char, canvas.width / 2, canvas.height / 2);
            
            // ÏÇ¨Ïö©Ïûê Í∑∏Î¶ºÍ≥º Í∞ÄÏù¥ÎìúÏÑ† Ïù¥ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
            const userImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const guideImageData = guideCtx.getImageData(0, 0, canvas.width, canvas.height);
            
            let matchingPixels = 0;
            let totalGuidePixels = 0;
            let userPixelsOnGuide = 0;
            let totalUserPixels = 0;
            
            // ÌîΩÏÖÄÎ≥Ñ ÎπÑÍµê
            for (let i = 0; i < guideImageData.data.length; i += 4) {
                const guideAlpha = guideImageData.data[i + 3];
                const userAlpha = userImageData.data[i + 3];
                
                if (userAlpha > 0) {
                    totalUserPixels++;
                }
                
                if (guideAlpha > 0) {
                    totalGuidePixels++;
                    
                    // Í∞ÄÏù¥ÎìúÏÑ† ÏúÑÏπòÏóêÏÑú ÏÇ¨Ïö©Ïûê Ìöç ÌôïÏù∏ (ÌóàÏö© Ïò§Ï∞® Î≤îÏúÑ ÎÇ¥)
                    const pixelIndex = i / 4;
                    const x = pixelIndex % canvas.width;
                    const y = Math.floor(pixelIndex / canvas.width);
                    
                    if (isUserStrokeNearGuidePixel(userImageData, x, y, canvas.width, canvas.height, 8)) {
                        matchingPixels++;
                    }
                }
                
                // ÏÇ¨Ïö©ÏûêÍ∞Ä Í∞ÄÏù¥ÎìúÏÑ† Í∑ºÏ≤òÏóê Í∑∏Î†∏ÎäîÏßÄ ÌôïÏù∏
                if (userAlpha > 0) {
                    const pixelIndex = i / 4;
                    const x = pixelIndex % canvas.width;
                    const y = Math.floor(pixelIndex / canvas.width);
                    
                    if (isGuidePixelNearUserStroke(guideImageData, x, y, canvas.width, canvas.height, 8)) {
                        userPixelsOnGuide++;
                    }
                }
            }
            
            // Í∞ÄÏù¥ÎìúÏÑ† Ïª§Î≤ÑÎ¶¨ÏßÄ (Í∞ÄÏù¥ÎìúÏÑ†Ïùò Î™á %Î•º Îî∞Îùº Í∑∏Î†∏ÎäîÍ∞Ä)
            const guideCoverage = totalGuidePixels > 0 ? matchingPixels / totalGuidePixels : 0;
            
            // Ï†ïÌôïÎèÑ (ÏÇ¨Ïö©ÏûêÍ∞Ä Í∑∏Î¶∞ Í≤É Ï§ë Í∞ÄÏù¥ÎìúÏÑ† Í∑ºÏ≤òÏóê ÏûàÎäî ÎπÑÏú®)
            const accuracy = totalUserPixels > 0 ? userPixelsOnGuide / totalUserPixels : 0;
            
            // Ï¢ÖÌï© Ï†êÏàò (Ïª§Î≤ÑÎ¶¨ÏßÄ 70%, Ï†ïÌôïÎèÑ 30%)
            const finalScore = (guideCoverage * 0.7) + (accuracy * 0.3);
            
            console.log(`Í∞ÄÏù¥Îìú Ïª§Î≤ÑÎ¶¨ÏßÄ: ${(guideCoverage * 100).toFixed(1)}%, Ï†ïÌôïÎèÑ: ${(accuracy * 100).toFixed(1)}%`);
            
            return finalScore;
        }
        
        // Í∞ÄÏù¥ÎìúÏÑ† ÌîΩÏÖÄ Í∑ºÏ≤òÏóê ÏÇ¨Ïö©Ïûê ÌöçÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
        function isUserStrokeNearGuidePixel(userImageData, x, y, width, height, tolerance) {
            for (let dx = -tolerance; dx <= tolerance; dx++) {
                for (let dy = -tolerance; dy <= tolerance; dy++) {
                    const checkX = x + dx;
                    const checkY = y + dy;
                    
                    if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height) {
                        const index = (checkY * width + checkX) * 4;
                        if (userImageData.data[index + 3] > 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        // ÏÇ¨Ïö©Ïûê Ìöç Í∑ºÏ≤òÏóê Í∞ÄÏù¥ÎìúÏÑ† ÌîΩÏÖÄÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
        function isGuidePixelNearUserStroke(guideImageData, x, y, width, height, tolerance) {
            for (let dx = -tolerance; dx <= tolerance; dx++) {
                for (let dy = -tolerance; dy <= tolerance; dy++) {
                    const checkX = x + dx;
                    const checkY = y + dy;
                    
                    if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height) {
                        const index = (checkY * width + checkX) * 4;
                        if (guideImageData.data[index + 3] > 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // ÏÉâÏπ†/ÌúòÍ∞àÍπÄ Ìå®ÌÑ¥ Í∞êÏßÄ (ÌúòÍ∞àÍπÄ Í∞êÏßÄÎßå Îçî ÏóÑÍ≤©ÌïòÍ≤å)
        function isScribbleOrFillPattern(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            let totalPixels = 0;
            let filledPixels = 0;
            let edgePixels = 0;
            
            // ÌîΩÏÖÄ Î∂ÑÏÑù
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const index = (y * canvas.width + x) * 4;
                    totalPixels++;
                    
                    if (imageData.data[index + 3] > 0) {
                        filledPixels++;
                        
                        // Í∞ÄÏû•ÏûêÎ¶¨ ÌîΩÏÖÄÏù∏ÏßÄ ÌôïÏù∏
                        if (isEdgePixel(imageData, x, y, canvas.width, canvas.height)) {
                            edgePixels++;
                        }
                    }
                }
            }
            
            const fillRatio = filledPixels / totalPixels;
            const edgeRatio = edgePixels / Math.max(filledPixels, 1);
            
            // ÏÉâÏπ† Ìå®ÌÑ¥: Ï†ÑÏ≤¥ ÏòÅÏó≠Ïùò 15% Ïù¥ÏÉÅÏù¥ Ï±ÑÏõåÏßÄÍ≥† Í∞ÄÏû•ÏûêÎ¶¨ ÎπÑÏú®Ïù¥ ÎÇÆÏùå (Í∏∞Ï°¥ Ïú†ÏßÄ)
            if (fillRatio > 0.15 && edgeRatio < 0.20) {
                return true;
            }
            
            // ÌúòÍ∞àÍπÄ Ìå®ÌÑ¥: Ïó∞ÏÜçÏÑ±Ïù¥ ÏóÜÎäî Î¨¥ÏûëÏúÑ Ï†êÎì§ (Îçî ÏóÑÍ≤©ÌïòÍ≤å)
            if (fillRatio > 0.03 && hasRandomScribblePattern(imageData, canvas.width, canvas.height)) {
                return true;
            }
            
            // Í∞ÄÏù¥ÎìúÏÑ†Í≥º Ï†ÑÌòÄ ÏùºÏπòÌïòÏßÄ ÏïäÎäî Ìå®ÌÑ¥ Í∞êÏßÄ (Îçî ÏóÑÍ≤©ÌïòÍ≤å)
            const char = characterCanvases.find(c => c.canvas === canvas)?.char;
            if (char) {
                const guideMatchScore = calculateGuideLineMatchScore(canvas, char);
                if (guideMatchScore < 0.20) { // Í∞ÄÏù¥ÎìúÏÑ†Í≥º 20% ÎØ∏Îßå ÏùºÏπòÌïòÎ©¥ ÌúòÍ∞àÍπÄÏúºÎ°ú Í∞ÑÏ£º (Îçî ÏóÑÍ≤©ÌïòÍ≤å)
                    return true;
                }
            }
            
            // Ï∂îÍ∞Ä ÌúòÍ∞àÍπÄ Ìå®ÌÑ¥ Í∞êÏßÄ: ÎÑàÎ¨¥ ÎßéÏùÄ Î∞©Ìñ• Î≥ÄÌôî
            if (hasExcessiveDirectionChanges(imageData, canvas.width, canvas.height)) {
                return true;
            }
            
            // Ï∂îÍ∞Ä ÌúòÍ∞àÍπÄ Ìå®ÌÑ¥ Í∞êÏßÄ: Î∂àÍ∑úÏπôÌïú Î∞ÄÎèÑ Î∂ÑÌè¨
            if (hasIrregularDensityDistribution(imageData, canvas.width, canvas.height)) {
                return true;
            }
            
            return false;
        }
        
        // Í∞ÄÏû•ÏûêÎ¶¨ ÌîΩÏÖÄ ÌôïÏù∏
        function isEdgePixel(imageData, x, y, width, height) {
            const directions = [[-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]];
            
            for (let [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                    const index = (ny * width + nx) * 4;
                    if (imageData.data[index + 3] === 0) {
                        return true; // Ïù∏Ï†ëÌïú Îπà ÌîΩÏÖÄÏù¥ ÏûàÏúºÎ©¥ Í∞ÄÏû•ÏûêÎ¶¨
                    }
                }
            }
            return false;
        }
        
        // Î¨¥ÏûëÏúÑ ÌúòÍ∞àÍπÄ Ìå®ÌÑ¥ Í∞êÏßÄ (Îçî ÏóÑÍ≤©ÌïòÍ≤å)
        function hasRandomScribblePattern(imageData, width, height) {
            let isolatedPixelGroups = 0;
            let totalGroups = 0;
            const visited = new Array(width * height).fill(false);
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = (y * width + x) * 4;
                    const pixelIndex = y * width + x;
                    
                    if (imageData.data[index + 3] > 0 && !visited[pixelIndex]) {
                        const groupSize = floodFillCount(imageData, visited, x, y, width, height);
                        totalGroups++;
                        
                        if (groupSize < 15) { // ÏûëÏùÄ Í≥†Î¶ΩÎêú Í∑∏Î£π Í∏∞Ï§Ä Í∞ïÌôî
                            isolatedPixelGroups++;
                        }
                    }
                }
            }
            
            // Í≥†Î¶ΩÎêú ÏûëÏùÄ Í∑∏Î£πÏù¥ ÎßéÏúºÎ©¥ ÌúòÍ∞àÍπÄÏúºÎ°ú ÌåêÎã® (Îçî ÏóÑÍ≤©Ìïú Í∏∞Ï§Ä)
            const isolationRatio = totalGroups > 0 ? isolatedPixelGroups / totalGroups : 0;
            return isolatedPixelGroups > 3 || isolationRatio > 0.6;
        }
        
        // Ïó∞Í≤∞Îêú ÌîΩÏÖÄ Í∑∏Î£π ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
        function floodFillCount(imageData, visited, startX, startY, width, height) {
            const stack = [[startX, startY]];
            let count = 0;
            
            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const pixelIndex = y * width + x;
                
                if (x < 0 || x >= width || y < 0 || y >= height || visited[pixelIndex]) {
                    continue;
                }
                
                const index = (y * width + x) * 4;
                if (imageData.data[index + 3] === 0) {
                    continue;
                }
                
                visited[pixelIndex] = true;
                count++;
                
                // 8Î∞©Ìñ• ÌÉêÏÉâ
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx !== 0 || dy !== 0) {
                            stack.push([x + dx, y + dy]);
                        }
                    }
                }
            }
            
            return count;
        }

        // Í≥ºÎèÑÌïú Î∞©Ìñ• Î≥ÄÌôî Í∞êÏßÄ (ÏÉàÎ°úÏö¥ ÌúòÍ∞àÍπÄ Í∞êÏßÄ Í∏∞Ï§Ä)
        function hasExcessiveDirectionChanges(imageData, width, height) {
            const strokePoints = [];
            
            // Í∑∏Î†§ÏßÑ ÌîΩÏÖÄÎì§Ïùò Ï¢åÌëú ÏàòÏßë
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = (y * width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        strokePoints.push({x, y});
                    }
                }
            }
            
            if (strokePoints.length < 20) return false;
            
            // Ïó∞ÏÜçÎêú Ï†êÎì§ ÏÇ¨Ïù¥Ïùò Î∞©Ìñ• Î≥ÄÌôî Í≥ÑÏÇ∞
            let directionChanges = 0;
            let previousDirection = null;
            
            for (let i = 1; i < Math.min(strokePoints.length, 100); i += 2) {
                const current = strokePoints[i];
                const previous = strokePoints[i - 1];
                
                const dx = current.x - previous.x;
                const dy = current.y - previous.y;
                
                if (dx === 0 && dy === 0) continue;
                
                const currentDirection = Math.atan2(dy, dx);
                
                if (previousDirection !== null) {
                    let angleDiff = Math.abs(currentDirection - previousDirection);
                    if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                    
                    // 45ÎèÑ Ïù¥ÏÉÅÏùò Í∏âÍ≤©Ìïú Î∞©Ìñ• Î≥ÄÌôî
                    if (angleDiff > Math.PI / 4) {
                        directionChanges++;
                    }
                }
                
                previousDirection = currentDirection;
            }
            
            // Î∞©Ìñ• Î≥ÄÌôîÍ∞Ä ÎÑàÎ¨¥ ÎßéÏúºÎ©¥ ÌúòÍ∞àÍπÄÏúºÎ°ú ÌåêÎã®
            const changeRatio = directionChanges / Math.min(strokePoints.length / 2, 50);
            return changeRatio > 0.4;
        }

        // Î∂àÍ∑úÏπôÌïú Î∞ÄÎèÑ Î∂ÑÌè¨ Í∞êÏßÄ (ÏÉàÎ°úÏö¥ ÌúòÍ∞àÍπÄ Í∞êÏßÄ Í∏∞Ï§Ä)
        function hasIrregularDensityDistribution(imageData, width, height) {
            const gridSize = 20; // 20x20 ÌîΩÏÖÄ Îã®ÏúÑÎ°ú ÎÇòÎàÑÏñ¥ Í≤ÄÏÇ¨
            const gridWidth = Math.ceil(width / gridSize);
            const gridHeight = Math.ceil(height / gridSize);
            const densityGrid = new Array(gridWidth * gridHeight).fill(0);
            
            // Í∞Å Í∑∏Î¶¨Îìú ÏÖÄÏùò ÌîΩÏÖÄ Î∞ÄÎèÑ Í≥ÑÏÇ∞
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = (y * width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        const gridX = Math.floor(x / gridSize);
                        const gridY = Math.floor(y / gridSize);
                        const gridIndex = gridY * gridWidth + gridX;
                        densityGrid[gridIndex]++;
                    }
                }
            }
            
            // Î∞ÄÎèÑÍ∞Ä ÏûàÎäî ÏÖÄÎì§Îßå ÌïÑÌÑ∞ÎßÅ
            const nonEmptyCells = densityGrid.filter(density => density > 0);
            if (nonEmptyCells.length < 3) return false;
            
            // Î∞ÄÎèÑÏùò ÌëúÏ§ÄÌé∏Ï∞® Í≥ÑÏÇ∞
            const mean = nonEmptyCells.reduce((sum, density) => sum + density, 0) / nonEmptyCells.length;
            const variance = nonEmptyCells.reduce((sum, density) => sum + Math.pow(density - mean, 2), 0) / nonEmptyCells.length;
            const standardDeviation = Math.sqrt(variance);
            
            // ÌëúÏ§ÄÌé∏Ï∞®Í∞Ä ÌèâÍ∑†Ïùò 80% Ïù¥ÏÉÅÏù¥Î©¥ Î∂àÍ∑úÏπôÌïú Î∂ÑÌè¨Î°ú ÌåêÎã®
            const coefficientOfVariation = standardDeviation / mean;
            return coefficientOfVariation > 0.8;
        }

        // ÏûêÎ™® Íµ¨ÏÑ±ÏöîÏÜå Ï°¥Ïû¨ Ïó¨Î∂Ä ÌôïÏù∏ (Íµ¨Ï°∞Ï†Å ÌèâÍ∞Ä)
        function checkJamoComponentExists(canvas, fullChar, jamo, position) {
            const ctx = canvas.getContext('2d');
            
            // ÏûêÎ™® ÏòÅÏó≠ Ï†ïÏùò
            const jamoRegion = getJamoRegion(canvas.width, canvas.height, position);
            
            // ÏÇ¨Ïö©Ïûê Í∑∏Î¶º Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
            const userImageData = ctx.getImageData(jamoRegion.x, jamoRegion.y, jamoRegion.width, jamoRegion.height);
            
            // ÏûêÎ™®Î≥Ñ Íµ¨ÏÑ±ÏöîÏÜå Ï°¥Ïû¨ ÌôïÏù∏
            return checkJamoComponentsExist(userImageData, jamo, jamoRegion);
        }

        // ÏûêÎ™® Íµ¨Ï°∞Ï†Å ÌèâÍ∞Ä (0.0 ~ 1.0 Ï†êÏàò Î∞òÌôò)
        function evaluateJamoStructure(canvas, fullChar, jamo, position) {
            const ctx = canvas.getContext('2d');
            const jamoRegion = getJamoRegion(canvas.width, canvas.height, position);
            const userImageData = ctx.getImageData(jamoRegion.x, jamoRegion.y, jamoRegion.width, jamoRegion.height);
            
            // Í∏∞Î≥∏ Íµ¨Ï°∞ ÌôïÏù∏
            const hasBasicStructure = checkJamoBasicStructure(userImageData, jamo, jamoRegion);
            if (!hasBasicStructure) return 0.0;
            
            // ÌòïÌÉú Ï†ïÌôïÎèÑ ÌèâÍ∞Ä
            const shapeAccuracy = evaluateJamoShapeAccuracy(userImageData, jamo, jamoRegion);
            
            // ÏúÑÏπò Ï†ïÌôïÎèÑ ÌèâÍ∞Ä
            const positionAccuracy = evaluateJamoPositionAccuracy(userImageData, jamo, jamoRegion);
            
            // Ï¢ÖÌï© Ï†êÏàò (Íµ¨Ï°∞ 50%, ÌòïÌÉú 30%, ÏúÑÏπò 20%)
            return (hasBasicStructure ? 0.5 : 0) + (shapeAccuracy * 0.3) + (positionAccuracy * 0.2);
        }
        
        // ÏûêÎ™® Í∏∞Î≥∏ Íµ¨Ï°∞ ÌôïÏù∏
        function checkJamoBasicStructure(imageData, jamo, region) {
            switch (jamo) {
                case '„Ñ±': return checkAngleStructure(imageData, region);
                case '„Ñ¥': return checkLShapeStructure(imageData, region);
                case '„Ñ∑': return checkCapStructure(imageData, region);
                case '„Ñπ': return checkComplexStructure(imageData, region, 2);
                case '„ÖÅ': return checkRectangleStructure(imageData, region);
                case '„ÖÇ': return checkVerticalWithHorizontalsStructure(imageData, region);
                case '„ÖÖ': return checkVShapeStructure(imageData, region);
                case '„Öá': return checkCircleStructure(imageData, region);
                case '„Öà': return checkVWithHorizontalStructure(imageData, region);
                case '„Öä': return checkVWithHorizontalsStructure(imageData, region);
                case '„Öã': return checkVerticalWithRightStrokesStructure(imageData, region);
                case '„Öå': return checkCapWithVerticalStructure(imageData, region);
                case '„Öç': return checkRectangleWithVerticalStructure(imageData, region);
                case '„Öé': return checkCircleWithHorizontalStructure(imageData, region);
                
                case '„Öè': return checkVerticalWithRightHorizontalStructure(imageData, region);
                case '„Öì': return checkVerticalWithLeftHorizontalStructure(imageData, region);
                case '„Öó': return checkHorizontalWithDownVerticalStructure(imageData, region);
                case '„Öú': return checkHorizontalWithUpVerticalStructure(imageData, region);
                case '„Ö°': return checkHorizontalStructure(imageData, region);
                case '„Ö£': return checkVerticalStructure(imageData, region);
                case '„Öë': return checkVerticalWithTwoRightHorizontalsStructure(imageData, region);
                case '„Öï': return checkVerticalWithTwoLeftHorizontalsStructure(imageData, region);
                case '„Öõ': return checkHorizontalWithTwoDownVerticalsStructure(imageData, region);
                case '„Ö†': return checkHorizontalWithTwoUpVerticalsStructure(imageData, region);
                
                default:
                    return checkBasicStrokeStructure(imageData, region);
            }
        }
        
        // ÏûêÎ™® ÌòïÌÉú Ï†ïÌôïÎèÑ ÌèâÍ∞Ä
        function evaluateJamoShapeAccuracy(imageData, jamo, region) {
            // Í∏∞Ï§Ä ÌòïÌÉúÏôÄÏùò Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞
            const referenceShape = generateReferenceShape(jamo, region);
            return calculateShapeSimilarity(imageData, referenceShape, region);
        }
        
        // ÏûêÎ™® ÏúÑÏπò Ï†ïÌôïÎèÑ ÌèâÍ∞Ä
        function evaluateJamoPositionAccuracy(imageData, jamo, region) {
            const centerOfMass = calculateCenterOfMass(imageData, region);
            const expectedCenter = getExpectedJamoCenter(jamo, region);
            
            const distance = Math.sqrt(
                Math.pow(centerOfMass.x - expectedCenter.x, 2) + 
                Math.pow(centerOfMass.y - expectedCenter.y, 2)
            );
            
            const maxDistance = Math.sqrt(region.width * region.width + region.height * region.height) / 4;
            return Math.max(0, 1 - (distance / maxDistance));
        }
        
        // Ï†ÑÏ≤¥ Í∏ÄÏûê Íµ¨Ï°∞ ÌèâÍ∞Ä
        function evaluateOverallCharacterStructure(canvas, char) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // Í∏ÄÏûê Ï†ÑÏ≤¥ Ïú§Í≥Ω ÌèâÍ∞Ä
            const contourScore = evaluateCharacterContour(imageData, char, canvas.width, canvas.height);
            
            // Í∏ÄÏûê ÎπÑÏú® ÌèâÍ∞Ä
            const proportionScore = evaluateCharacterProportion(imageData, char, canvas.width, canvas.height);
            
            // Í∏ÄÏûê Ïó∞Í≤∞ÏÑ± ÌèâÍ∞Ä
            const connectivityScore = evaluateCharacterConnectivity(imageData, canvas.width, canvas.height);
            
            return (contourScore * 0.5) + (proportionScore * 0.3) + (connectivityScore * 0.2);
        }
        
        // ÌïúÍ∏ÄÏù¥ ÏïÑÎãå Î¨∏Ïûê Íµ¨Ï°∞ ÌèâÍ∞Ä
        function evaluateNonHangulStructure(canvas, char) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // Í∏∞Î≥∏ ÌòïÌÉú ÌôïÏù∏
            const hasBasicShape = checkNonHangulBasicShape(imageData, char, canvas.width, canvas.height);
            if (!hasBasicShape) return 'Îπ®Í∞ÑÎ∂à';
            
            // ÌòïÌÉú Ï†ïÌôïÎèÑ
            const shapeAccuracy = calculateNonHangulShapeAccuracy(imageData, char, canvas.width, canvas.height);
            
            if (shapeAccuracy >= 0.7) return 'Ï¥àÎ°ùÎ∂à';
            else if (shapeAccuracy >= 0.4) return 'ÎÖ∏ÎûÄÎ∂à';
            else return 'Îπ®Í∞ÑÎ∂à';
        }
        
        // ÌèâÍ∞Ä Í≤∞Í≥ºÏóê Îî∞Î•∏ ÌëúÏãúÎì± ÏÑ§Ï†ï
        function setIndicatorByEvaluation(indicator, characterData, evaluation) {
            switch (evaluation) {
                case 'Ï¥àÎ°ùÎ∂à':
                    characterData.completed = true;
                    indicator.className = 'status-indicator green';
                    break;
                case 'ÎÖ∏ÎûÄÎ∂à':
                    characterData.completed = false;
                    indicator.className = 'status-indicator yellow';
                    break;
                case 'Îπ®Í∞ÑÎ∂à':
                default:
                    characterData.completed = false;
                    indicator.className = 'status-indicator red';
                    break;
            }
        }

        // Î™®Îì† ÌöçÏù¥ ÏôÑÏ†ÑÌûà Í∑∏Î†§Ï°åÎäîÏßÄ ÌôïÏù∏ÌïòÎäî ÏóÑÍ≤©Ìïú Í≤ÄÏÇ¨
        function checkAllStrokesComplete(canvas, fullChar, jamo, position) {
            const ctx = canvas.getContext('2d');
            const jamoRegion = getJamoRegion(canvas.width, canvas.height, position);
            const userImageData = ctx.getImageData(jamoRegion.x, jamoRegion.y, jamoRegion.width, jamoRegion.height);
            
            switch (jamo) {
                case '„Ñ±': return checkAngleStrokeComplete(userImageData, jamoRegion);
                case '„Ñ¥': return checkLShapeStrokeComplete(userImageData, jamoRegion);
                case '„Ñ∑': return checkCapStrokeComplete(userImageData, jamoRegion);
                case '„Ñπ': return checkRieulStrokeComplete(userImageData, jamoRegion);
                case '„ÖÅ': return checkRectangleStrokeComplete(userImageData, jamoRegion);
                case '„ÖÇ': return checkBieupStrokeComplete(userImageData, jamoRegion);
                case '„ÖÖ': return checkSiotStrokeComplete(userImageData, jamoRegion);
                case '„Öá': return checkIeungStrokeComplete(userImageData, jamoRegion);
                case '„Öà': return checkJieupStrokeComplete(userImageData, jamoRegion);
                case '„Öä': return checkChieuchStrokeComplete(userImageData, jamoRegion);
                case '„Öã': return checkKieukStrokeComplete(userImageData, jamoRegion);
                case '„Öå': return checkTieutStrokeComplete(userImageData, jamoRegion);
                case '„Öç': return checkPieupStrokeComplete(userImageData, jamoRegion);
                case '„Öé': return checkHieuhStrokeComplete(userImageData, jamoRegion);
                
                case '„Öè': return checkAStrokeComplete(userImageData, jamoRegion);
                case '„Öì': return checkEoStrokeComplete(userImageData, jamoRegion);
                case '„Öó': return checkOStrokeComplete(userImageData, jamoRegion);
                case '„Öú': return checkUStrokeComplete(userImageData, jamoRegion);
                case '„Ö°': return checkEuStrokeComplete(userImageData, jamoRegion);
                case '„Ö£': return checkIStrokeComplete(userImageData, jamoRegion);
                case '„Öë': return checkYaStrokeComplete(userImageData, jamoRegion);
                case '„Öï': return checkYeoStrokeComplete(userImageData, jamoRegion);
                case '„Öõ': return checkYoStrokeComplete(userImageData, jamoRegion);
                case '„Ö†': return checkYuStrokeComplete(userImageData, jamoRegion);
                
                default:
                    return checkCompleteStrokeExists(userImageData, jamoRegion);
            }
        }

        // ÏôÑÏ†ÑÌïú Ìöç Ï°¥Ïû¨ ÌôïÏù∏ (ÏóÑÍ≤©Ìïú Í∏∞Ï§Ä)
        function checkCompleteStrokeExists(imageData, region) {
            let strokePixels = 0;
            const minStrokePixels = Math.max(20, region.width * region.height * 0.05); // ÏµúÏÜå 5%Ïùò ÌîΩÏÖÄ
            
            for (let i = 0; i < imageData.data.length; i += 4) {
                if (imageData.data[i + 3] > 0) {
                    strokePixels++;
                }
            }
            return strokePixels >= minStrokePixels;
        }

        // „Ñ±: Í∞ÄÎ°úÏÑ† + ÏÑ∏Î°úÏÑ† Î™®Îëê ÌïÑÏöî
        function checkAngleStrokeComplete(imageData, region) {
            return checkHorizontalStrokeStrict(imageData, region) && checkVerticalStrokeStrict(imageData, region);
        }

        // „Ñ¥: ÏÑ∏Î°úÏÑ† + Í∞ÄÎ°úÏÑ† Î™®Îëê ÌïÑÏöî
        function checkLShapeStrokeComplete(imageData, region) {
            return checkVerticalStrokeStrict(imageData, region) && checkHorizontalStrokeStrict(imageData, region);
        }

        // „Ñ∑: ÏúÑÏ™Ω Í∞ÄÎ°úÏÑ† + ÏñëÏ™Ω ÏÑ∏Î°úÏÑ† ÌïÑÏöî
        function checkCapStrokeComplete(imageData, region) {
            return checkHorizontalStrokeStrict(imageData, region) && 
                   checkVerticalInRegionStrict(imageData, region, 0.0, 0.3, 0.0, 0.7) &&
                   checkVerticalInRegionStrict(imageData, region, 0.7, 1.0, 0.0, 0.7);
        }

        // „Ñπ: Î≥µÏû°Ìïú ÌòïÌÉú - Ïó¨Îü¨ Ìöç ÌïÑÏöî
        function checkRieulStrokeComplete(imageData, region) {
            return checkHorizontalStrokeStrict(imageData, region) && 
                   checkVerticalStrokeStrict(imageData, region) &&
                   checkCompleteStrokeExists(imageData, region);
        }

        // „ÖÅ: ÏÇ¨Í∞ÅÌòï - 4Î©¥ Î™®Îëê ÌïÑÏöî
        function checkRectangleStrokeComplete(imageData, region) {
            return checkHorizontalInRegionStrict(imageData, region, 0.1, 0.9, 0.0, 0.2) && // ÏúÑ
                   checkHorizontalInRegionStrict(imageData, region, 0.1, 0.9, 0.8, 1.0) && // ÏïÑÎûò
                   checkVerticalInRegionStrict(imageData, region, 0.0, 0.2, 0.1, 0.9) &&   // ÏôºÏ™Ω
                   checkVerticalInRegionStrict(imageData, region, 0.8, 1.0, 0.1, 0.9);     // Ïò§Î•∏Ï™Ω
        }

        // „ÖÇ: ÏÑ∏Î°úÏÑ† + Îëê Í∞úÏùò Í∞ÄÎ°úÏÑ†
        function checkBieupStrokeComplete(imageData, region) {
            return checkVerticalStrokeStrict(imageData, region) &&
                   checkHorizontalInRegionStrict(imageData, region, 0.2, 0.8, 0.2, 0.4) &&
                   checkHorizontalInRegionStrict(imageData, region, 0.2, 0.8, 0.6, 0.8);
        }

        // „ÖÖ: Îëê Í∞úÏùò ÎåÄÍ∞ÅÏÑ†
        function checkSiotStrokeComplete(imageData, region) {
            return checkDiagonalStrokeExists(imageData, region, 'left') && 
                   checkDiagonalStrokeExists(imageData, region, 'right');
        }

        // „Öá: ÏõêÌòï
        function checkIeungStrokeComplete(imageData, region) {
            return checkCircularStrokeExists(imageData, region);
        }

        // „Öà: „ÖÖ + Í∞ÄÎ°úÏÑ†
        function checkJieupStrokeComplete(imageData, region) {
            return checkSiotStrokeComplete(imageData, region) && 
                   checkHorizontalInRegionStrict(imageData, region, 0.2, 0.8, 0.8, 1.0);
        }

        // „Öä: „Öà + Ï∂îÍ∞Ä Í∞ÄÎ°úÏÑ†
        function checkChieuchStrokeComplete(imageData, region) {
            return checkJieupStrokeComplete(imageData, region) && 
                   checkHorizontalInRegionStrict(imageData, region, 0.2, 0.8, 0.0, 0.2);
        }

        // „Öã: ÏÑ∏Î°úÏÑ† + Îëê Í∞úÏùò Ïò§Î•∏Ï™Ω Í∞ÄÎ°úÏÑ†
        function checkKieukStrokeComplete(imageData, region) {
            return checkVerticalStrokeStrict(imageData, region) &&
                   checkHorizontalInRegionStrict(imageData, region, 0.5, 0.9, 0.2, 0.4) &&
                   checkHorizontalInRegionStrict(imageData, region, 0.5, 0.9, 0.6, 0.8);
        }

        // „Öå: „Ñ∑ + ÏÑ∏Î°úÏÑ†
        function checkTieutStrokeComplete(imageData, region) {
            return checkCapStrokeComplete(imageData, region) && 
                   checkVerticalInRegionStrict(imageData, region, 0.4, 0.6, 0.3, 0.8);
        }

        // „Öç: „ÖÅ + ÏÑ∏Î°úÏÑ†
        function checkPieupStrokeComplete(imageData, region) {
            return checkRectangleStrokeComplete(imageData, region) && 
                   checkVerticalInRegionStrict(imageData, region, 0.4, 0.6, 0.3, 0.7);
        }

        // „Öé: „Öá + Í∞ÄÎ°úÏÑ†
        function checkHieuhStrokeComplete(imageData, region) {
            return checkIeungStrokeComplete(imageData, region) && 
                   checkHorizontalInRegionStrict(imageData, region, 0.2, 0.8, 0.4, 0.6);
        }

        // „Öè: ÏÑ∏Î°úÏÑ† + Ïò§Î•∏Ï™Ω Í∞ÄÎ°úÏÑ†
        function checkAStrokeComplete(imageData, region) {
            return checkVerticalStrokeStrict(imageData, region) && 
                   checkHorizontalInRegionStrict(imageData, region, 0.5, 0.9, 0.4, 0.6);
        }

        // „Öì: ÏÑ∏Î°úÏÑ† + ÏôºÏ™Ω Í∞ÄÎ°úÏÑ†
        function checkEoStrokeComplete(imageData, region) {
            return checkVerticalStrokeStrict(imageData, region) && 
                   checkHorizontalInRegionStrict(imageData, region, 0.1, 0.5, 0.4, 0.6);
        }

        // „Öó: Í∞ÄÎ°úÏÑ† + ÏïÑÎûò ÏÑ∏Î°úÏÑ†
        function checkOStrokeComplete(imageData, region) {
            return checkHorizontalStrokeStrict(imageData, region) && 
                   checkVerticalInRegionStrict(imageData, region, 0.4, 0.6, 0.5, 0.9);
        }

        // „Öú: Í∞ÄÎ°úÏÑ† + ÏúÑ ÏÑ∏Î°úÏÑ†
        function checkUStrokeComplete(imageData, region) {
            return checkHorizontalStrokeStrict(imageData, region) && 
                   checkVerticalInRegionStrict(imageData, region, 0.4, 0.6, 0.1, 0.5);
        }

        // „Ö°: Í∞ÄÎ°úÏÑ†
        function checkEuStrokeComplete(imageData, region) {
            return checkHorizontalStrokeStrict(imageData, region);
        }

        // „Ö£: ÏÑ∏Î°úÏÑ†
        function checkIStrokeComplete(imageData, region) {
            return checkVerticalStrokeStrict(imageData, region);
        }

        // „Öë: ÏÑ∏Î°úÏÑ† + Îëê Í∞úÏùò Ïò§Î•∏Ï™Ω Í∞ÄÎ°úÏÑ†
        function checkYaStrokeComplete(imageData, region) {
            return checkVerticalStrokeStrict(imageData, region) && 
                   checkHorizontalInRegionStrict(imageData, region, 0.5, 0.9, 0.3, 0.4) &&
                   checkHorizontalInRegionStrict(imageData, region, 0.5, 0.9, 0.6, 0.7);
        }

        // „Öï: ÏÑ∏Î°úÏÑ† + Îëê Í∞úÏùò ÏôºÏ™Ω Í∞ÄÎ°úÏÑ†
        function checkYeoStrokeComplete(imageData, region) {
            return checkVerticalStrokeStrict(imageData, region) && 
                   checkHorizontalInRegionStrict(imageData, region, 0.1, 0.5, 0.3, 0.4) &&
                   checkHorizontalInRegionStrict(imageData, region, 0.1, 0.5, 0.6, 0.7);
        }

        // „Öõ: Í∞ÄÎ°úÏÑ† + Îëê Í∞úÏùò ÏïÑÎûò ÏÑ∏Î°úÏÑ†
        function checkYoStrokeComplete(imageData, region) {
            return checkHorizontalStrokeStrict(imageData, region) && 
                   checkVerticalInRegionStrict(imageData, region, 0.3, 0.4, 0.5, 0.9) &&
                   checkVerticalInRegionStrict(imageData, region, 0.6, 0.7, 0.5, 0.9);
        }

        // „Ö†: Í∞ÄÎ°úÏÑ† + Îëê Í∞úÏùò ÏúÑ ÏÑ∏Î°úÏÑ†
        function checkYuStrokeComplete(imageData, region) {
            return checkHorizontalStrokeStrict(imageData, region) && 
                   checkVerticalInRegionStrict(imageData, region, 0.3, 0.4, 0.1, 0.5) &&
                   checkVerticalInRegionStrict(imageData, region, 0.6, 0.7, 0.1, 0.5);
        }

        // ÏóÑÍ≤©Ìïú ÏÑ∏Î°úÏÑ† ÌôïÏù∏ (Í∞ÄÏù¥ÎìúÏÑ† ÏòÅÏó≠ ÎÇ¥ Ïù∏Ïãù Í∞úÏÑ†)
        function checkVerticalStrokeStrict(imageData, region) {
            const centerX = Math.floor(region.width / 2);
            const tolerance = Math.max(10, Math.floor(region.width * 0.3)); // ÌóàÏö© Î≤îÏúÑ Îçî ÌôïÎåÄ
            let verticalPixels = 0;
            const minVerticalPixels = Math.floor(region.height * 0.25); // 25%Î°ú Îçî ÏôÑÌôî
            
            for (let y = 0; y < region.height; y++) {
                let foundInRow = false;
                for (let x = centerX - tolerance; x <= centerX + tolerance; x++) {
                    if (x >= 0 && x < region.width) {
                        const index = (y * region.width + x) * 4;
                        if (imageData.data[index + 3] > 0) {
                            foundInRow = true;
                            break;
                        }
                    }
                }
                if (foundInRow) verticalPixels++;
            }
            return verticalPixels >= minVerticalPixels;
        }

        // ÏóÑÍ≤©Ìïú Í∞ÄÎ°úÏÑ† ÌôïÏù∏ (Í∞ÄÏù¥ÎìúÏÑ† ÏòÅÏó≠ ÎÇ¥ Ïù∏Ïãù Í∞úÏÑ†)
        function checkHorizontalStrokeStrict(imageData, region) {
            const centerY = Math.floor(region.height / 2);
            const tolerance = Math.max(10, Math.floor(region.height * 0.3)); // ÌóàÏö© Î≤îÏúÑ Îçî ÌôïÎåÄ
            let horizontalPixels = 0;
            const minHorizontalPixels = Math.floor(region.width * 0.25); // 25%Î°ú Îçî ÏôÑÌôî
            
            for (let x = 0; x < region.width; x++) {
                let foundInCol = false;
                for (let y = centerY - tolerance; y <= centerY + tolerance; y++) {
                    if (y >= 0 && y < region.height) {
                        const index = (y * region.width + x) * 4;
                        if (imageData.data[index + 3] > 0) {
                            foundInCol = true;
                            break;
                        }
                    }
                }
                if (foundInCol) horizontalPixels++;
            }
            return horizontalPixels >= minHorizontalPixels;
        }

        // ÌäπÏ†ï ÏòÅÏó≠ÏóêÏÑú ÏóÑÍ≤©Ìïú Í∞ÄÎ°úÏÑ† ÌôïÏù∏ (Í∞ÄÏù¥ÎìúÏÑ† ÏòÅÏó≠ ÎÇ¥ Ïù∏Ïãù Í∞úÏÑ†)
        function checkHorizontalInRegionStrict(imageData, region, xStart, xEnd, yStart, yEnd) {
            const startX = Math.floor(region.width * xStart);
            const endX = Math.floor(region.width * xEnd);
            const startY = Math.floor(region.height * yStart);
            const endY = Math.floor(region.height * yEnd);
            
            let horizontalPixels = 0;
            const minPixels = Math.floor((endX - startX) * 0.3); // 30%Î°ú ÏôÑÌôî
            
            // Í∞Å ÌñâÏóêÏÑú ÌîΩÏÖÄÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
            for (let y = startY; y < endY; y++) {
                let foundInRow = false;
                for (let x = startX; x < endX; x++) {
                    const index = (y * region.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        foundInRow = true;
                        break;
                    }
                }
                if (foundInRow) horizontalPixels++;
            }
            
            // ÏµúÏÜå Ìñâ ÏàòÏóêÏÑú ÌîΩÏÖÄÏù¥ Î∞úÍ≤¨ÎêòÎ©¥ ÏÑ±Í≥µ
            const minRows = Math.max(1, Math.floor((endY - startY) * 0.2));
            return horizontalPixels >= minRows;
        }

        // ÌäπÏ†ï ÏòÅÏó≠ÏóêÏÑú ÏóÑÍ≤©Ìïú ÏÑ∏Î°úÏÑ† ÌôïÏù∏ (Í∞ÄÏù¥ÎìúÏÑ† ÏòÅÏó≠ ÎÇ¥ Ïù∏Ïãù Í∞úÏÑ†)
        function checkVerticalInRegionStrict(imageData, region, xStart, xEnd, yStart, yEnd) {
            const startX = Math.floor(region.width * xStart);
            const endX = Math.floor(region.width * xEnd);
            const startY = Math.floor(region.height * yStart);
            const endY = Math.floor(region.height * yEnd);
            
            let verticalPixels = 0;
            const minPixels = Math.floor((endY - startY) * 0.3); // 30%Î°ú ÏôÑÌôî
            
            // Í∞Å Ïó¥ÏóêÏÑú ÌîΩÏÖÄÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
            for (let x = startX; x < endX; x++) {
                let foundInCol = false;
                for (let y = startY; y < endY; y++) {
                    const index = (y * region.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        foundInCol = true;
                        break;
                    }
                }
                if (foundInCol) verticalPixels++;
            }
            
            // ÏµúÏÜå Ïó¥ ÏàòÏóêÏÑú ÌîΩÏÖÄÏù¥ Î∞úÍ≤¨ÎêòÎ©¥ ÏÑ±Í≥µ
            const minCols = Math.max(1, Math.floor((endX - startX) * 0.2));
            return verticalPixels >= minCols;
        }

        // ÎåÄÍ∞ÅÏÑ† ÌôïÏù∏ (Í∞ÄÏù¥ÎìúÏÑ† ÏòÅÏó≠ ÎÇ¥ Ïù∏Ïãù Í∞úÏÑ†)
        function checkDiagonalStrokeExists(imageData, region, direction) {
            let diagonalPixels = 0;
            const minPixels = Math.floor(Math.min(region.width, region.height) * 0.1); // 10%Î°ú ÏôÑÌôî
            const tolerance = 12; // ÌóàÏö© Î≤îÏúÑ Îçî ÌôïÎåÄ
            
            if (direction === 'left') {
                // ÏôºÏ™Ω ÏúÑÏóêÏÑú Ïò§Î•∏Ï™Ω ÏïÑÎûòÎ°ú
                for (let i = 0; i < Math.min(region.width, region.height); i++) {
                    const centerX = Math.floor(i * 0.7);
                    const centerY = Math.floor(i * 0.8);
                    
                    let foundInArea = false;
                    for (let dx = -tolerance; dx <= tolerance; dx++) {
                        for (let dy = -tolerance; dy <= tolerance; dy++) {
                            const x = centerX + dx;
                            const y = centerY + dy;
                            if (x >= 0 && x < region.width && y >= 0 && y < region.height) {
                                const index = (y * region.width + x) * 4;
                                if (imageData.data[index + 3] > 0) {
                                    foundInArea = true;
                                    break;
                                }
                            }
                        }
                        if (foundInArea) break;
                    }
                    if (foundInArea) diagonalPixels++;
                }
            } else {
                // Ïò§Î•∏Ï™Ω ÏúÑÏóêÏÑú ÏôºÏ™Ω ÏïÑÎûòÎ°ú
                for (let i = 0; i < Math.min(region.width, region.height); i++) {
                    const centerX = Math.floor(region.width - i * 0.7);
                    const centerY = Math.floor(i * 0.8);
                    
                    let foundInArea = false;
                    for (let dx = -tolerance; dx <= tolerance; dx++) {
                        for (let dy = -tolerance; dy <= tolerance; dy++) {
                            const x = centerX + dx;
                            const y = centerY + dy;
                            if (x >= 0 && x < region.width && y >= 0 && y < region.height) {
                                const index = (y * region.width + x) * 4;
                                if (imageData.data[index + 3] > 0) {
                                    foundInArea = true;
                                    break;
                                }
                            }
                        }
                        if (foundInArea) break;
                    }
                    if (foundInArea) diagonalPixels++;
                }
            }
            
            return diagonalPixels >= minPixels;
        }

        // ÏõêÌòï ÌôïÏù∏ (Í∞ÄÏù¥ÎìúÏÑ† ÏòÅÏó≠ ÎÇ¥ Ïù∏Ïãù Í∞úÏÑ†)
        function checkCircularStrokeExists(imageData, region) {
            const centerX = Math.floor(region.width / 2);
            const centerY = Math.floor(region.height / 2);
            const radius = Math.min(region.width, region.height) * 0.3;
            let circularPixels = 0;
            const minPixels = Math.floor(radius * 2 * Math.PI * 0.15); // ÏõêÎëòÎ†àÏùò 15%Î°ú ÏôÑÌôî
            const tolerance = 12; // ÌóàÏö© Î≤îÏúÑ Îçî ÌôïÎåÄ
            
            // Ïõê ÎëòÎ†àÎ•º Îî∞Îùº ÌîΩÏÖÄ ÌôïÏù∏
            for (let angle = 0; angle < 360; angle += 15) { // Í∞ÑÍ≤© Îçî ÌôïÎåÄ
                const radian = (angle * Math.PI) / 180;
                const centerPointX = Math.floor(centerX + radius * Math.cos(radian));
                const centerPointY = Math.floor(centerY + radius * Math.sin(radian));
                
                // Ï£ºÎ≥Ä ÏòÅÏó≠ÏóêÏÑú ÌîΩÏÖÄ ÌôïÏù∏
                let foundInArea = false;
                for (let dx = -tolerance; dx <= tolerance; dx++) {
                    for (let dy = -tolerance; dy <= tolerance; dy++) {
                        const checkX = centerPointX + dx;
                        const checkY = centerPointY + dy;
                        if (checkX >= 0 && checkX < region.width && checkY >= 0 && checkY < region.height) {
                            const index = (checkY * region.width + checkX) * 4;
                            if (imageData.data[index + 3] > 0) {
                                foundInArea = true;
                                break;
                            }
                        }
                    }
                    if (foundInArea) break;
                }
                if (foundInArea) circularPixels++;
            }
            
            return circularPixels >= minPixels;
        }

        // ÏûêÎ™®Ïùò Íµ¨ÏÑ±ÏöîÏÜå Ï°¥Ïû¨ Ïó¨Î∂Ä Í≤ÄÏÇ¨ (ÌöåÏÉâ Í∞ÄÏù¥ÎìúÏÑ† ÏòÅÏó≠ ÎÇ¥ÏóêÏÑúÎßå Ïù∏Ï†ï)
        function checkJamoComponentsExist(userImageData, jamo, region) {
            // Î®ºÏ†Ä ÌöåÏÉâ Í∞ÄÏù¥ÎìúÏÑ† ÏòÅÏó≠ ÎÇ¥Ïóê Ï∂©Î∂ÑÌïú ÌöçÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
            if (!checkStrokeInGuideArea(userImageData, region)) {
                return false;
            }
            
            switch (jamo) {
                case '„Ñ±': return checkAngleStrokeInGuide(userImageData, region);
                case '„Ñ¥': return checkLShapeStrokeInGuide(userImageData, region);
                case '„Ñ∑': return checkCapStrokeInGuide(userImageData, region);
                case '„Ñπ': return checkComplexStrokeInGuide(userImageData, region, 3);
                case '„ÖÅ': return checkRectangleStrokeInGuide(userImageData, region);
                case '„ÖÇ': return checkVerticalWithHorizontalsInGuide(userImageData, region);
                case '„ÖÖ': return checkVShapeStrokeInGuide(userImageData, region);
                case '„Öá': return checkCircleStrokeInGuide(userImageData, region);
                case '„Öà': return checkVWithHorizontalInGuide(userImageData, region);
                case '„Öä': return checkVWithHorizontalsInGuide(userImageData, region);
                case '„Öã': return checkVerticalWithRightStrokesInGuide(userImageData, region);
                case '„Öå': return checkCapWithVerticalInGuide(userImageData, region);
                case '„Öç': return checkRectangleWithVerticalInGuide(userImageData, region);
                case '„Öé': return checkCircleWithHorizontalInGuide(userImageData, region);
                
                case '„Öè': return checkVerticalWithRightHorizontalInGuide(userImageData, region);
                case '„Öì': return checkVerticalWithLeftHorizontalInGuide(userImageData, region);
                case '„Öó': return checkHorizontalWithDownVerticalInGuide(userImageData, region);
                case '„Öú': return checkHorizontalWithUpVerticalInGuide(userImageData, region);
                case '„Ö°': return checkHorizontalStrokeInGuide(userImageData, region);
                case '„Ö£': return checkVerticalStrokeInGuide(userImageData, region);
                case '„Öë': return checkVerticalWithTwoRightHorizontalsInGuide(userImageData, region);
                case '„Öï': return checkVerticalWithTwoLeftHorizontalsInGuide(userImageData, region);
                case '„Öõ': return checkHorizontalWithTwoDownVerticalsInGuide(userImageData, region);
                case '„Ö†': return checkHorizontalWithTwoUpVerticalsInGuide(userImageData, region);
                
                default:
                    return checkBasicStrokeInGuideArea(userImageData, region);
            }
        }

        // ÌöåÏÉâ Í∞ÄÏù¥ÎìúÏÑ† ÏòÅÏó≠ ÎÇ¥Ïóê ÌöçÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏
        function checkStrokeInGuideArea(imageData, region) {
            // Í∞ÄÏù¥ÎìúÏÑ† ÏòÅÏó≠ Ï†ïÏùò (Ï§ëÏïô 80% ÏòÅÏó≠)
            const guideMargin = 0.1; // 10% Ïó¨Î∞±
            const guideStartX = Math.floor(region.width * guideMargin);
            const guideEndX = Math.floor(region.width * (1 - guideMargin));
            const guideStartY = Math.floor(region.height * guideMargin);
            const guideEndY = Math.floor(region.height * (1 - guideMargin));
            
            let strokePixelsInGuide = 0;
            const minStrokePixels = Math.max(10, (guideEndX - guideStartX) * (guideEndY - guideStartY) * 0.02); // Í∞ÄÏù¥Îìú ÏòÅÏó≠Ïùò 2%Î°ú ÏôÑÌôî
            
            for (let y = guideStartY; y < guideEndY; y++) {
                for (let x = guideStartX; x < guideEndX; x++) {
                    const index = (y * region.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        strokePixelsInGuide++;
                        if (strokePixelsInGuide >= minStrokePixels) return true;
                    }
                }
            }
            return false;
        }

        // Í∏∞Î≥∏ Ìöç Ï°¥Ïû¨ ÌôïÏù∏ (Í∞ÄÏù¥Îìú ÏòÅÏó≠ ÎÇ¥ÏóêÏÑúÎßå)
        function checkBasicStrokeInGuideArea(imageData, region) {
            return checkStrokeInGuideArea(imageData, region);
        }

        // ÏÑ∏Î°úÏÑ† Ï°¥Ïû¨ ÌôïÏù∏ (Í∞ÄÏù¥Îìú ÏòÅÏó≠ ÎÇ¥ÏóêÏÑúÎßå)
        function checkVerticalStrokeInGuide(imageData, region) {
            // Í∞ÄÏù¥Îìú ÏòÅÏó≠ Ï†ïÏùò
            const guideMargin = 0.1;
            const guideStartX = Math.floor(region.width * guideMargin);
            const guideEndX = Math.floor(region.width * (1 - guideMargin));
            const guideStartY = Math.floor(region.height * guideMargin);
            const guideEndY = Math.floor(region.height * (1 - guideMargin));
            
            const centerX = Math.floor(region.width / 2);
            const tolerance = Math.floor(region.width * 0.2); // Í∞ÄÏù¥Îìú ÏòÅÏó≠ ÎÇ¥ÏóêÏÑúÎßå ÌóàÏö©
            let verticalPixels = 0;
            const minVerticalPixels = Math.floor((guideEndY - guideStartY) * 0.3); // Í∞ÄÏù¥Îìú ÏòÅÏó≠ ÎÜíÏù¥Ïùò 30%Î°ú ÏôÑÌôî
            
            for (let y = guideStartY; y < guideEndY; y++) {
                let foundInRow = false;
                for (let x = Math.max(guideStartX, centerX - tolerance); x <= Math.min(guideEndX, centerX + tolerance); x++) {
                    const index = (y * region.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        foundInRow = true;
                        break;
                    }
                }
                if (foundInRow) verticalPixels++;
            }
            return verticalPixels >= minVerticalPixels;
        }

        // Í∞ÄÎ°úÏÑ† Ï°¥Ïû¨ ÌôïÏù∏ (Í∞ÄÏù¥Îìú ÏòÅÏó≠ ÎÇ¥ÏóêÏÑúÎßå)
        function checkHorizontalStrokeInGuide(imageData, region) {
            // Í∞ÄÏù¥Îìú ÏòÅÏó≠ Ï†ïÏùò
            const guideMargin = 0.1;
            const guideStartX = Math.floor(region.width * guideMargin);
            const guideEndX = Math.floor(region.width * (1 - guideMargin));
            const guideStartY = Math.floor(region.height * guideMargin);
            const guideEndY = Math.floor(region.height * (1 - guideMargin));
            
            const centerY = Math.floor(region.height / 2);
            const tolerance = Math.floor(region.height * 0.2); // Í∞ÄÏù¥Îìú ÏòÅÏó≠ ÎÇ¥ÏóêÏÑúÎßå ÌóàÏö©
            let horizontalPixels = 0;
            const minHorizontalPixels = Math.floor((guideEndX - guideStartX) * 0.3); // Í∞ÄÏù¥Îìú ÏòÅÏó≠ ÎÑàÎπÑÏùò 30%Î°ú ÏôÑÌôî
            
            for (let x = guideStartX; x < guideEndX; x++) {
                let foundInCol = false;
                for (let y = Math.max(guideStartY, centerY - tolerance); y <= Math.min(guideEndY, centerY + tolerance); y++) {
                    const index = (y * region.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        foundInCol = true;
                        break;
                    }
                }
                if (foundInCol) horizontalPixels++;
            }
            return horizontalPixels >= minHorizontalPixels;
        }

        // Í∏∞Ï°¥ Ìï®ÏàòÎì§ÏùÑ Í∞ÄÏù¥Îìú ÏòÅÏó≠ Ï†úÌïú Î≤ÑÏ†ÑÏúºÎ°ú ÎåÄÏ≤¥
        function checkVerticalStroke(imageData, region) {
            return checkVerticalStrokeInGuide(imageData, region);
        }

        function checkHorizontalStroke(imageData, region) {
            return checkHorizontalStrokeInGuide(imageData, region);
        }

        // Í∞ÄÏù¥Îìú ÏòÅÏó≠ Ï†úÌïú Ìï®ÏàòÎì§ Ï∂îÍ∞Ä
        function checkVerticalWithRightHorizontalInGuide(imageData, region) {
            return checkVerticalStrokeInGuide(imageData, region) && 
                   checkHorizontalInGuideRegion(imageData, region, 0.6, 1.0, 0.3, 0.7);
        }

        function checkVerticalWithLeftHorizontalInGuide(imageData, region) {
            return checkVerticalStrokeInGuide(imageData, region) && 
                   checkHorizontalInGuideRegion(imageData, region, 0.0, 0.4, 0.3, 0.7);
        }

        function checkHorizontalWithDownVerticalInGuide(imageData, region) {
            return checkHorizontalStrokeInGuide(imageData, region) && 
                   checkVerticalInGuideRegion(imageData, region, 0.3, 0.7, 0.5, 1.0);
        }

        function checkHorizontalWithUpVerticalInGuide(imageData, region) {
            return checkHorizontalStrokeInGuide(imageData, region) && 
                   checkVerticalInGuideRegion(imageData, region, 0.3, 0.7, 0.0, 0.5);
        }

        // Î™®Îì† ÏûêÎ™® Ìï®ÏàòÎì§ÏùÑ Í∞ÄÏù¥Îìú ÏòÅÏó≠ Ï†úÌïú Î≤ÑÏ†ÑÏúºÎ°ú ÏÉùÏÑ±
        function checkAngleStrokeInGuide(imageData, region) {
            return checkHorizontalStrokeInGuide(imageData, region) || checkVerticalStrokeInGuide(imageData, region);
        }

        function checkLShapeStrokeInGuide(imageData, region) {
            return checkVerticalStrokeInGuide(imageData, region) || checkHorizontalStrokeInGuide(imageData, region);
        }

        function checkCapStrokeInGuide(imageData, region) {
            return checkHorizontalStrokeInGuide(imageData, region) || checkVerticalStrokeInGuide(imageData, region);
        }

        function checkComplexStrokeInGuide(imageData, region, minComponents) {
            let components = 0;
            if (checkHorizontalStrokeInGuide(imageData, region)) components++;
            if (checkVerticalStrokeInGuide(imageData, region)) components++;
            if (checkStrokeInGuideArea(imageData, region)) components++;
            return components >= Math.min(minComponents, 2);
        }

        function checkRectangleStrokeInGuide(imageData, region) {
            return checkHorizontalStrokeInGuide(imageData, region) && checkVerticalStrokeInGuide(imageData, region);
        }

        function checkVerticalWithHorizontalsInGuide(imageData, region) {
            return checkVerticalStrokeInGuide(imageData, region) || checkHorizontalStrokeInGuide(imageData, region);
        }

        function checkVShapeStrokeInGuide(imageData, region) {
            return checkStrokeInGuideArea(imageData, region);
        }

        function checkCircleStrokeInGuide(imageData, region) {
            return checkStrokeInGuideArea(imageData, region);
        }

        function checkVWithHorizontalInGuide(imageData, region) {
            return checkStrokeInGuideArea(imageData, region);
        }

        function checkVWithHorizontalsInGuide(imageData, region) {
            return checkStrokeInGuideArea(imageData, region);
        }

        function checkVerticalWithRightStrokesInGuide(imageData, region) {
            return checkVerticalStrokeInGuide(imageData, region) || checkStrokeInGuideArea(imageData, region);
        }

        function checkCapWithVerticalInGuide(imageData, region) {
            return checkHorizontalStrokeInGuide(imageData, region) || checkVerticalStrokeInGuide(imageData, region);
        }

        function checkRectangleWithVerticalInGuide(imageData, region) {
            return checkHorizontalStrokeInGuide(imageData, region) || checkVerticalStrokeInGuide(imageData, region);
        }

        function checkCircleWithHorizontalInGuide(imageData, region) {
            return checkStrokeInGuideArea(imageData, region);
        }

        function checkVerticalWithTwoRightHorizontalsInGuide(imageData, region) {
            return checkVerticalStrokeInGuide(imageData, region) || checkHorizontalStrokeInGuide(imageData, region);
        }

        function checkVerticalWithTwoLeftHorizontalsInGuide(imageData, region) {
            return checkVerticalStrokeInGuide(imageData, region) || checkHorizontalStrokeInGuide(imageData, region);
        }

        function checkHorizontalWithTwoDownVerticalsInGuide(imageData, region) {
            return checkHorizontalStrokeInGuide(imageData, region) || checkVerticalStrokeInGuide(imageData, region);
        }

        function checkHorizontalWithTwoUpVerticalsInGuide(imageData, region) {
            return checkHorizontalStrokeInGuide(imageData, region) || checkVerticalStrokeInGuide(imageData, region);
        }

        // Í∏∞Ï°¥ Ìï®ÏàòÎì§ÏùÑ Í∞ÄÏù¥Îìú ÏòÅÏó≠ Ï†úÌïú Î≤ÑÏ†ÑÏúºÎ°ú ÎåÄÏ≤¥
        function checkVerticalWithRightHorizontal(imageData, region) {
            return checkVerticalWithRightHorizontalInGuide(imageData, region);
        }

        function checkVerticalWithLeftHorizontal(imageData, region) {
            return checkVerticalWithLeftHorizontalInGuide(imageData, region);
        }

        function checkHorizontalWithDownVertical(imageData, region) {
            return checkHorizontalWithDownVerticalInGuide(imageData, region);
        }

        function checkHorizontalWithUpVertical(imageData, region) {
            return checkHorizontalWithUpVerticalInGuide(imageData, region);
        }

        // Í∞ÄÏù¥Îìú ÏòÅÏó≠ ÎÇ¥ ÌäπÏ†ï ÏòÅÏó≠ÏóêÏÑú Í∞ÄÎ°úÏÑ† ÌôïÏù∏
        function checkHorizontalInGuideRegion(imageData, region, xStart, xEnd, yStart, yEnd) {
            // Í∞ÄÏù¥Îìú ÏòÅÏó≠ Ï†ïÏùò
            const guideMargin = 0.1;
            const guideStartX = Math.floor(region.width * guideMargin);
            const guideEndX = Math.floor(region.width * (1 - guideMargin));
            const guideStartY = Math.floor(region.height * guideMargin);
            const guideEndY = Math.floor(region.height * (1 - guideMargin));
            
            // ÏöîÏ≤≠Îêú ÏòÅÏó≠ÏùÑ Í∞ÄÏù¥Îìú ÏòÅÏó≠ ÎÇ¥Î°ú Ï†úÌïú
            const startX = Math.max(guideStartX, Math.floor(region.width * xStart));
            const endX = Math.min(guideEndX, Math.floor(region.width * xEnd));
            const startY = Math.max(guideStartY, Math.floor(region.height * yStart));
            const endY = Math.min(guideEndY, Math.floor(region.height * yEnd));
            
            let horizontalPixels = 0;
            const minPixels = Math.floor((endX - startX) * 0.3); // 30%
            
            for (let y = startY; y < endY; y++) {
                let foundInRow = false;
                for (let x = startX; x < endX; x++) {
                    const index = (y * region.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        foundInRow = true;
                        break;
                    }
                }
                if (foundInRow) horizontalPixels++;
            }
            
            const minRows = Math.max(1, Math.floor((endY - startY) * 0.2));
            return horizontalPixels >= minRows;
        }

        // Í∞ÄÏù¥Îìú ÏòÅÏó≠ ÎÇ¥ ÌäπÏ†ï ÏòÅÏó≠ÏóêÏÑú ÏÑ∏Î°úÏÑ† ÌôïÏù∏
        function checkVerticalInGuideRegion(imageData, region, xStart, xEnd, yStart, yEnd) {
            // Í∞ÄÏù¥Îìú ÏòÅÏó≠ Ï†ïÏùò
            const guideMargin = 0.1;
            const guideStartX = Math.floor(region.width * guideMargin);
            const guideEndX = Math.floor(region.width * (1 - guideMargin));
            const guideStartY = Math.floor(region.height * guideMargin);
            const guideEndY = Math.floor(region.height * (1 - guideMargin));
            
            // ÏöîÏ≤≠Îêú ÏòÅÏó≠ÏùÑ Í∞ÄÏù¥Îìú ÏòÅÏó≠ ÎÇ¥Î°ú Ï†úÌïú
            const startX = Math.max(guideStartX, Math.floor(region.width * xStart));
            const endX = Math.min(guideEndX, Math.floor(region.width * xEnd));
            const startY = Math.max(guideStartY, Math.floor(region.height * yStart));
            const endY = Math.min(guideEndY, Math.floor(region.height * yEnd));
            
            let verticalPixels = 0;
            const minPixels = Math.floor((endY - startY) * 0.3); // 30%
            
            for (let x = startX; x < endX; x++) {
                let foundInCol = false;
                for (let y = startY; y < endY; y++) {
                    const index = (y * region.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        foundInCol = true;
                        break;
                    }
                }
                if (foundInCol) verticalPixels++;
            }
            
            const minCols = Math.max(1, Math.floor((endX - startX) * 0.2));
            return verticalPixels >= minCols;
        }

        // Í∏∞Ï°¥ Ìï®ÏàòÎì§ÏùÑ Í∞ÄÏù¥Îìú ÏòÅÏó≠ Ï†úÌïú Î≤ÑÏ†ÑÏúºÎ°ú ÎåÄÏ≤¥
        function checkHorizontalInRegion(imageData, region, xStart, xEnd, yStart, yEnd) {
            return checkHorizontalInGuideRegion(imageData, region, xStart, xEnd, yStart, yEnd);
        }

        function checkVerticalInRegion(imageData, region, xStart, xEnd, yStart, yEnd) {
            return checkVerticalInGuideRegion(imageData, region, xStart, xEnd, yStart, yEnd);
        }

        // Í∞ÅÎèÑ ÏûàÎäî Ìöç („Ñ±)
        function checkAngleStroke(imageData, region) {
            return checkHorizontalStroke(imageData, region) || checkVerticalStroke(imageData, region);
        }

        // LÏûê Î™®Ïñë („Ñ¥)
        function checkLShapeStroke(imageData, region) {
            return checkVerticalStroke(imageData, region) || checkHorizontalStroke(imageData, region);
        }

        // Î™®Ïûê Î™®Ïñë („Ñ∑)
        function checkCapStroke(imageData, region) {
            return checkHorizontalStroke(imageData, region) || checkVerticalStroke(imageData, region);
        }

        // Î≥µÏû°Ìïú Ìöç („Ñπ)
        function checkComplexStroke(imageData, region, minComponents) {
            let components = 0;
            if (checkHorizontalStroke(imageData, region)) components++;
            if (checkVerticalStroke(imageData, region)) components++;
            if (checkBasicStrokeExists(imageData, region)) components++;
            return components >= Math.min(minComponents, 2);
        }

        // ÏÇ¨Í∞ÅÌòï Î™®Ïñë („ÖÅ)
        function checkRectangleStroke(imageData, region) {
            return checkHorizontalStroke(imageData, region) && checkVerticalStroke(imageData, region);
        }

        // ÏÑ∏Î°úÏÑ† + Í∞ÄÎ°úÏÑ†Îì§ („ÖÇ)
        function checkVerticalWithHorizontals(imageData, region) {
            return checkVerticalStroke(imageData, region) || checkHorizontalStroke(imageData, region);
        }

        // VÏûê Î™®Ïñë („ÖÖ)
        function checkVShapeStroke(imageData, region) {
            return checkBasicStrokeExists(imageData, region);
        }

        // Ïõê Î™®Ïñë („Öá)
        function checkCircleStroke(imageData, region) {
            return checkBasicStrokeExists(imageData, region);
        }

        // VÏûê + Í∞ÄÎ°úÏÑ† („Öà)
        function checkVWithHorizontal(imageData, region) {
            return checkBasicStrokeExists(imageData, region);
        }

        // VÏûê + Í∞ÄÎ°úÏÑ†Îì§ („Öä)
        function checkVWithHorizontals(imageData, region) {
            return checkBasicStrokeExists(imageData, region);
        }

        // ÏÑ∏Î°úÏÑ† + Ïò§Î•∏Ï™Ω ÌöçÎì§ („Öã)
        function checkVerticalWithRightStrokes(imageData, region) {
            return checkVerticalStroke(imageData, region) || checkBasicStrokeExists(imageData, region);
        }

        // Î™®Ïûê + ÏÑ∏Î°úÏÑ† („Öå)
        function checkCapWithVertical(imageData, region) {
            return checkHorizontalStroke(imageData, region) || checkVerticalStroke(imageData, region);
        }

        // ÏÇ¨Í∞ÅÌòï + ÏÑ∏Î°úÏÑ† („Öç)
        function checkRectangleWithVertical(imageData, region) {
            return checkHorizontalStroke(imageData, region) || checkVerticalStroke(imageData, region);
        }

        // Ïõê + Í∞ÄÎ°úÏÑ† („Öé)
        function checkCircleWithHorizontal(imageData, region) {
            return checkBasicStrokeExists(imageData, region);
        }

        // ÏÑ∏Î°úÏÑ† + Îëê Í∞úÏùò Ïò§Î•∏Ï™Ω Í∞ÄÎ°úÏÑ† („Öë)
        function checkVerticalWithTwoRightHorizontals(imageData, region) {
            return checkVerticalStroke(imageData, region) || checkHorizontalStroke(imageData, region);
        }

        // ÏÑ∏Î°úÏÑ† + Îëê Í∞úÏùò ÏôºÏ™Ω Í∞ÄÎ°úÏÑ† („Öï)
        function checkVerticalWithTwoLeftHorizontals(imageData, region) {
            return checkVerticalStroke(imageData, region) || checkHorizontalStroke(imageData, region);
        }

        // Í∞ÄÎ°úÏÑ† + Îëê Í∞úÏùò ÏïÑÎûò ÏÑ∏Î°úÏÑ† („Öõ)
        function checkHorizontalWithTwoDownVerticals(imageData, region) {
            return checkHorizontalStroke(imageData, region) || checkVerticalStroke(imageData, region);
        }

        // Í∞ÄÎ°úÏÑ† + Îëê Í∞úÏùò ÏúÑ ÏÑ∏Î°úÏÑ† („Ö†)
        function checkHorizontalWithTwoUpVerticals(imageData, region) {
            return checkHorizontalStroke(imageData, region) || checkVerticalStroke(imageData, region);
        }

        // Íµ¨Ï°∞ ÌôïÏù∏ Ìó¨Ìçº Ìï®ÏàòÎì§
        function checkAngleStructure(imageData, region) {
            return checkVerticalStructure(imageData, region) && checkHorizontalStructure(imageData, region);
        }
        
        function checkLShapeStructure(imageData, region) {
            return checkVerticalStructure(imageData, region) && checkHorizontalStructure(imageData, region);
        }
        
        function checkCapStructure(imageData, region) {
            return checkHorizontalStructure(imageData, region) && 
                   (checkVerticalStructure(imageData, region) || checkBasicStrokeStructure(imageData, region));
        }
        
        function checkRectangleStructure(imageData, region) {
            return checkHorizontalStructure(imageData, region) && checkVerticalStructure(imageData, region);
        }
        
        function checkVerticalWithHorizontalsStructure(imageData, region) {
            return checkVerticalStructure(imageData, region) && checkHorizontalStructure(imageData, region);
        }
        
        function checkVShapeStructure(imageData, region) {
            return checkBasicStrokeStructure(imageData, region);
        }
        
        function checkCircleStructure(imageData, region) {
            return checkBasicStrokeStructure(imageData, region);
        }
        
        function checkVWithHorizontalStructure(imageData, region) {
            return checkBasicStrokeStructure(imageData, region);
        }
        
        function checkVWithHorizontalsStructure(imageData, region) {
            return checkBasicStrokeStructure(imageData, region);
        }
        
        function checkVerticalWithRightStrokesStructure(imageData, region) {
            return checkVerticalStructure(imageData, region);
        }
        
        function checkCapWithVerticalStructure(imageData, region) {
            return checkHorizontalStructure(imageData, region) && checkVerticalStructure(imageData, region);
        }
        
        function checkRectangleWithVerticalStructure(imageData, region) {
            return checkHorizontalStructure(imageData, region) && checkVerticalStructure(imageData, region);
        }
        
        function checkCircleWithHorizontalStructure(imageData, region) {
            return checkBasicStrokeStructure(imageData, region);
        }
        
        function checkVerticalWithRightHorizontalStructure(imageData, region) {
            return checkVerticalStructure(imageData, region) && checkHorizontalStructure(imageData, region);
        }
        
        function checkVerticalWithLeftHorizontalStructure(imageData, region) {
            return checkVerticalStructure(imageData, region) && checkHorizontalStructure(imageData, region);
        }
        
        function checkHorizontalWithDownVerticalStructure(imageData, region) {
            return checkHorizontalStructure(imageData, region) && checkVerticalStructure(imageData, region);
        }
        
        function checkHorizontalWithUpVerticalStructure(imageData, region) {
            return checkHorizontalStructure(imageData, region) && checkVerticalStructure(imageData, region);
        }
        
        function checkVerticalWithTwoRightHorizontalsStructure(imageData, region) {
            return checkVerticalStructure(imageData, region) && checkHorizontalStructure(imageData, region);
        }
        
        function checkVerticalWithTwoLeftHorizontalsStructure(imageData, region) {
            return checkVerticalStructure(imageData, region) && checkHorizontalStructure(imageData, region);
        }
        
        function checkHorizontalWithTwoDownVerticalsStructure(imageData, region) {
            return checkHorizontalStructure(imageData, region) && checkVerticalStructure(imageData, region);
        }
        
        function checkHorizontalWithTwoUpVerticalsStructure(imageData, region) {
            return checkHorizontalStructure(imageData, region) && checkVerticalStructure(imageData, region);
        }
        
        // Í∏∞Î≥∏ Íµ¨Ï°∞ ÌôïÏù∏ Ìï®ÏàòÎì§
        function checkVerticalStructure(imageData, region) {
            const centerX = Math.floor(region.width / 2);
            const tolerance = Math.floor(region.width * 0.25);
            let verticalPixels = 0;
            const minVerticalPixels = Math.floor(region.height * 0.4);
            
            for (let y = 0; y < region.height; y++) {
                let foundInRow = false;
                for (let x = Math.max(0, centerX - tolerance); x <= Math.min(region.width - 1, centerX + tolerance); x++) {
                    const index = (y * region.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        foundInRow = true;
                        break;
                    }
                }
                if (foundInRow) verticalPixels++;
            }
            return verticalPixels >= minVerticalPixels;
        }
        
        function checkHorizontalStructure(imageData, region) {
            const centerY = Math.floor(region.height / 2);
            const tolerance = Math.floor(region.height * 0.25);
            let horizontalPixels = 0;
            const minHorizontalPixels = Math.floor(region.width * 0.4);
            
            for (let x = 0; x < region.width; x++) {
                let foundInCol = false;
                for (let y = Math.max(0, centerY - tolerance); y <= Math.min(region.height - 1, centerY + tolerance); y++) {
                    const index = (y * region.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        foundInCol = true;
                        break;
                    }
                }
                if (foundInCol) horizontalPixels++;
            }
            return horizontalPixels >= minHorizontalPixels;
        }
        
        function checkBasicStrokeStructure(imageData, region) {
            let strokePixels = 0;
            const minStrokePixels = Math.max(20, region.width * region.height * 0.05);
            
            for (let i = 0; i < imageData.data.length; i += 4) {
                if (imageData.data[i + 3] > 0) {
                    strokePixels++;
                }
            }
            return strokePixels >= minStrokePixels;
        }
        
        // ÌòïÌÉú Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞ Ìï®ÏàòÎì§
        function generateReferenceShape(jamo, region) {
            // Í∞ÑÎã®Ìïú Í∏∞Ï§Ä ÌòïÌÉú ÏÉùÏÑ± (Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî Îçî Ï†ïÍµêÌïòÍ≤å)
            return new Array(region.width * region.height).fill(0);
        }
        
        function calculateShapeSimilarity(imageData, referenceShape, region) {
            // Í∏∞Î≥∏Ï†ÅÏù∏ ÌòïÌÉú Ïú†ÏÇ¨ÎèÑ Í≥ÑÏÇ∞
            return 0.8; // ÏûÑÏãúÍ∞í
        }
        
        function calculateCenterOfMass(imageData, region) {
            let totalX = 0, totalY = 0, totalPixels = 0;
            
            for (let y = 0; y < region.height; y++) {
                for (let x = 0; x < region.width; x++) {
                    const index = (y * region.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        totalX += x;
                        totalY += y;
                        totalPixels++;
                    }
                }
            }
            
            return totalPixels > 0 ? 
                { x: totalX / totalPixels, y: totalY / totalPixels } : 
                { x: region.width / 2, y: region.height / 2 };
        }
        
        function getExpectedJamoCenter(jamo, region) {
            // ÏûêÎ™®Î≥Ñ ÏòàÏÉÅ Ï§ëÏã¨Ï†ê (Í∞ÑÎã®Ìïú Íµ¨ÌòÑ)
            return { x: region.width / 2, y: region.height / 2 };
        }
        
        // Ï†ÑÏ≤¥ Í∏ÄÏûê ÌèâÍ∞Ä Ìï®ÏàòÎì§
        function evaluateCharacterContour(imageData, char, width, height) {
            // Í∏ÄÏûê Ïú§Í≥Ω ÌèâÍ∞Ä
            return 0.8; // ÏûÑÏãúÍ∞í
        }
        
        function evaluateCharacterProportion(imageData, char, width, height) {
            // Í∏ÄÏûê ÎπÑÏú® ÌèâÍ∞Ä
            return 0.8; // ÏûÑÏãúÍ∞í
        }
        
        function evaluateCharacterConnectivity(imageData, width, height) {
            // Í∏ÄÏûê Ïó∞Í≤∞ÏÑ± ÌèâÍ∞Ä
            return 0.8; // ÏûÑÏãúÍ∞í
        }
        
        // ÌïúÍ∏ÄÏù¥ ÏïÑÎãå Î¨∏Ïûê ÌèâÍ∞Ä Ìï®ÏàòÎì§
        function checkNonHangulBasicShape(imageData, char, width, height) {
            let strokePixels = 0;
            const minStrokePixels = Math.max(30, width * height * 0.03);
            
            for (let i = 0; i < imageData.data.length; i += 4) {
                if (imageData.data[i + 3] > 0) {
                    strokePixels++;
                }
            }
            return strokePixels >= minStrokePixels;
        }
        
        function calculateNonHangulShapeAccuracy(imageData, char, width, height) {
            // ÌïúÍ∏ÄÏù¥ ÏïÑÎãå Î¨∏ÏûêÏùò ÌòïÌÉú Ï†ïÌôïÎèÑ
            let strokePixels = 0;
            const totalPixels = width * height;
            
            for (let i = 0; i < imageData.data.length; i += 4) {
                if (imageData.data[i + 3] > 0) {
                    strokePixels++;
                }
            }
            
            const strokeRatio = strokePixels / totalPixels;
            
            // Ï†ÅÏ†àÌïú Ìöç Î∞ÄÎèÑ Î≤îÏúÑ
            if (strokeRatio >= 0.02 && strokeRatio <= 0.3) {
                return 0.8;
            } else if (strokeRatio >= 0.01 && strokeRatio <= 0.5) {
                return 0.5;
            } else {
                return 0.2;
            }
        }

        // ÌïúÍ∏ÄÏù¥ ÏïÑÎãå Í≤ΩÏö∞ Íµ¨ÏÑ±ÏöîÏÜå Îß§Ïπ≠ (Í∞ÄÏù¥Îìú ÏòÅÏó≠ ÎÇ¥ÏóêÏÑúÎßå)
        function calculateComponentMatch(canvas, char) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // Í∞ÄÏù¥Îìú ÏòÅÏó≠ Ï†ïÏùò
            const guideMargin = 0.1;
            const guideStartX = Math.floor(canvas.width * guideMargin);
            const guideEndX = Math.floor(canvas.width * (1 - guideMargin));
            const guideStartY = Math.floor(canvas.height * guideMargin);
            const guideEndY = Math.floor(canvas.height * (1 - guideMargin));
            
            // Í∞ÄÏù¥Îìú ÏòÅÏó≠ ÎÇ¥Ïùò ÌöçÎßå ÌôïÏù∏
            let strokePixelsInGuide = 0;
            const guideAreaPixels = (guideEndX - guideStartX) * (guideEndY - guideStartY);
            
            for (let y = guideStartY; y < guideEndY; y++) {
                for (let x = guideStartX; x < guideEndX; x++) {
                    const index = (y * canvas.width + x) * 4;
                    if (imageData.data[index + 3] > 0) {
                        strokePixelsInGuide++;
                    }
                }
            }
            
            const strokeRatio = strokePixelsInGuide / guideAreaPixels;
            
            // Í∞ÄÏù¥Îìú ÏòÅÏó≠ ÎÇ¥Ïóê Ï†ÅÏ†àÌïú ÏñëÏùò ÌöçÏù¥ ÏûàÏúºÎ©¥ ÏôÑÏÑ±ÏúºÎ°ú Í∞ÑÏ£º
            if (strokeRatio >= 0.02 && strokeRatio <= 0.4) {
                return 0.8; // ÎÜíÏùÄ Ï†êÏàò
            } else if (strokeRatio >= 0.01) {
                return 0.4; // Ï§ëÍ∞Ñ Ï†êÏàò
            } else {
                return 0.1; // ÎÇÆÏùÄ Ï†êÏàò
            }
        }

        // ÏûêÎ™®Î≥Ñ ÌîΩÏÖÄ ÏùºÏπòÏú® Í≥ÑÏÇ∞ (Í∑†ÌòïÏû°Ìûå ÏôÑÏÑ±ÎèÑ Í∏∞Ï§Ä) - Í∏∞Ï°¥ Ìï®Ïàò Ïú†ÏßÄ
        function calculateJamoPixelMatch(canvas, fullChar, jamo, position) {
            const ctx = canvas.getContext('2d');
            
            // Ï†ÑÏ≤¥ Í∏ÄÏûêÏùò Í∏∞Ï§Ä Ï∫îÎ≤ÑÏä§ ÏÉùÏÑ±
            const referenceCanvas = document.createElement('canvas');
            referenceCanvas.width = canvas.width;
            referenceCanvas.height = canvas.height;
            const refCtx = referenceCanvas.getContext('2d');
            
            // Í∏∞Ï§Ä Í∏ÄÏûê Í∑∏Î¶¨Í∏∞ (ÏñáÏùÄ ÏÑ†ÏúºÎ°ú)
            refCtx.font = '300 120px Arial';
            refCtx.fillStyle = '#000000';
            refCtx.textAlign = 'center';
            refCtx.textBaseline = 'middle';
            refCtx.fillText(fullChar, canvas.width / 2, canvas.height / 2);
            
            // Ìï¥Îãπ ÏûêÎ™® ÏòÅÏó≠Îßå Ï∂îÏ∂ú
            const jamoRegion = getJamoRegion(canvas.width, canvas.height, position);
            
            // ÏÇ¨Ïö©Ïûê Í∑∏Î¶ºÍ≥º Í∏∞Ï§Ä Í∏ÄÏûêÏùò ÌîΩÏÖÄ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
            const userImageData = ctx.getImageData(jamoRegion.x, jamoRegion.y, jamoRegion.width, jamoRegion.height);
            const refImageData = refCtx.getImageData(jamoRegion.x, jamoRegion.y, jamoRegion.width, jamoRegion.height);
            
            // ÏûêÎ™®Ïùò Ï£ºÏöî Íµ¨ÏÑ± ÏöîÏÜåÎ≥Ñ ÏôÑÏÑ±ÎèÑ Í≤ÄÏÇ¨
            const componentCompletionRates = checkJamoComponents(userImageData, refImageData, jamo, jamoRegion);
            
            // Î™®Îì† Íµ¨ÏÑ± ÏöîÏÜåÍ∞Ä Ï∂©Î∂ÑÌûà ÏôÑÏÑ±ÎêòÏóàÎäîÏßÄ ÌôïÏù∏
            let totalCompletionRate = 0;
            let componentCount = componentCompletionRates.length;
            
            for (let rate of componentCompletionRates) {
                totalCompletionRate += rate;
            }
            
            return componentCount > 0 ? totalCompletionRate / componentCount : 0;
        }

        // ÏûêÎ™®Ïùò Íµ¨ÏÑ± ÏöîÏÜåÎ≥Ñ ÏôÑÏÑ±ÎèÑ Í≤ÄÏÇ¨
        function checkJamoComponents(userImageData, refImageData, jamo, region) {
            const componentRates = [];
            
            // ÏûêÎ™®Î≥Ñ Íµ¨ÏÑ± ÏöîÏÜå Ï†ïÏùò Î∞è Í≤ÄÏÇ¨
            switch (jamo) {
                case '„Öè': // „Ö£ + „Ö° (Ïò§Î•∏Ï™Ω ÏÑ∏Î°úÏÑ† + Í∞ÄÎ°úÏÑ†)
                    componentRates.push(checkVerticalLine(userImageData, refImageData, region, 'right'));
                    componentRates.push(checkHorizontalLine(userImageData, refImageData, region, 'middle'));
                    break;
                case '„Öì': // „Ö£ + „Ö° (ÏôºÏ™Ω ÏÑ∏Î°úÏÑ† + Í∞ÄÎ°úÏÑ†)
                    componentRates.push(checkVerticalLine(userImageData, refImageData, region, 'right'));
                    componentRates.push(checkHorizontalLine(userImageData, refImageData, region, 'middle'));
                    break;
                case '„Öó': // „Ö° + „Ö£ (ÏúÑÏ™Ω Í∞ÄÎ°úÏÑ† + ÏÑ∏Î°úÏÑ†)
                    componentRates.push(checkHorizontalLine(userImageData, refImageData, region, 'upper'));
                    componentRates.push(checkVerticalLine(userImageData, refImageData, region, 'center'));
                    break;
                case '„Öú': // „Ö° + „Ö£ (ÏïÑÎûòÏ™Ω Í∞ÄÎ°úÏÑ† + ÏÑ∏Î°úÏÑ†)
                    componentRates.push(checkHorizontalLine(userImageData, refImageData, region, 'lower'));
                    componentRates.push(checkVerticalLine(userImageData, refImageData, region, 'center'));
                    break;
                case '„Öë': // „Ö£ + „Ö° + „Ö° (ÏÑ∏Î°úÏÑ† + Îëê Í∞úÏùò Í∞ÄÎ°úÏÑ†)
                    componentRates.push(checkVerticalLine(userImageData, refImageData, region, 'right'));
                    componentRates.push(checkHorizontalLine(userImageData, refImageData, region, 'upper'));
                    componentRates.push(checkHorizontalLine(userImageData, refImageData, region, 'lower'));
                    break;
                case '„Öï': // „Ö£ + „Ö° + „Ö° (ÏÑ∏Î°úÏÑ† + Îëê Í∞úÏùò Í∞ÄÎ°úÏÑ†)
                    componentRates.push(checkVerticalLine(userImageData, refImageData, region, 'right'));
                    componentRates.push(checkHorizontalLine(userImageData, refImageData, region, 'upper'));
                    componentRates.push(checkHorizontalLine(userImageData, refImageData, region, 'lower'));
                    break;
                case '„Öõ': // „Ö° + „Ö£ + „Ö£ (Í∞ÄÎ°úÏÑ† + Îëê Í∞úÏùò ÏÑ∏Î°úÏÑ†)
                    componentRates.push(checkHorizontalLine(userImageData, refImageData, region, 'upper'));
                    componentRates.push(checkVerticalLine(userImageData, refImageData, region, 'left'));
                    componentRates.push(checkVerticalLine(userImageData, refImageData, region, 'right'));
                    break;
                case '„Ö†': // „Ö° + „Ö£ + „Ö£ (Í∞ÄÎ°úÏÑ† + Îëê Í∞úÏùò ÏÑ∏Î°úÏÑ†)
                    componentRates.push(checkHorizontalLine(userImageData, refImageData, region, 'lower'));
                    componentRates.push(checkVerticalLine(userImageData, refImageData, region, 'left'));
                    componentRates.push(checkVerticalLine(userImageData, refImageData, region, 'right'));
                    break;
                default:
                    // Í∏∞Î≥∏Ï†ÅÏù∏ ÌîΩÏÖÄ Îß§Ïπ≠ Î∞©Ïãù ÏÇ¨Ïö©
                    let matchingPixels = 0;
                    let totalReferencePixels = 0;
                    
                    for (let i = 0; i < refImageData.data.length; i += 4) {
                        const refAlpha = refImageData.data[i + 3];
                        
                        if (refAlpha > 0) {
                            totalReferencePixels++;
                            
                            const pixelIndex = i / 4;
                            const x = pixelIndex % region.width;
                            const y = Math.floor(pixelIndex / region.width);
                            
                            if (isNearUserStrokeInRegion(userImageData, x, y, region.width, region.height, 5)) {
                                matchingPixels++;
                            }
                        }
                    }
                    
                    componentRates.push(totalReferencePixels > 0 ? matchingPixels / totalReferencePixels : 0);
                    break;
            }
            
            return componentRates;
        }

        // ÏÑ∏Î°úÏÑ† Í≤ÄÏÇ¨
        function checkVerticalLine(userImageData, refImageData, region, position) {
            let startX, endX;
            const tolerance = 15; // ÌóàÏö© Ïò§Ï∞®
            
            switch (position) {
                case 'left':
                    startX = 0;
                    endX = Math.floor(region.width * 0.4);
                    break;
                case 'center':
                    startX = Math.floor(region.width * 0.3);
                    endX = Math.floor(region.width * 0.7);
                    break;
                case 'right':
                    startX = Math.floor(region.width * 0.6);
                    endX = region.width;
                    break;
                default:
                    startX = 0;
                    endX = region.width;
            }
            
            let matchingPixels = 0;
            let totalReferencePixels = 0;
            
            for (let y = 0; y < region.height; y++) {
                for (let x = startX; x < endX; x++) {
                    const index = (y * region.width + x) * 4;
                    const refAlpha = refImageData.data[index + 3];
                    
                    if (refAlpha > 0) {
                        totalReferencePixels++;
                        
                        if (isNearUserStrokeInRegion(userImageData, x, y, region.width, region.height, tolerance)) {
                            matchingPixels++;
                        }
                    }
                }
            }
            
            return totalReferencePixels > 0 ? matchingPixels / totalReferencePixels : 0;
        }

        // Í∞ÄÎ°úÏÑ† Í≤ÄÏÇ¨
        function checkHorizontalLine(userImageData, refImageData, region, position) {
            let startY, endY;
            const tolerance = 15; // ÌóàÏö© Ïò§Ï∞®
            
            switch (position) {
                case 'upper':
                    startY = 0;
                    endY = Math.floor(region.height * 0.4);
                    break;
                case 'middle':
                    startY = Math.floor(region.height * 0.3);
                    endY = Math.floor(region.height * 0.7);
                    break;
                case 'lower':
                    startY = Math.floor(region.height * 0.6);
                    endY = region.height;
                    break;
                default:
                    startY = 0;
                    endY = region.height;
            }
            
            let matchingPixels = 0;
            let totalReferencePixels = 0;
            
            for (let y = startY; y < endY; y++) {
                for (let x = 0; x < region.width; x++) {
                    const index = (y * region.width + x) * 4;
                    const refAlpha = refImageData.data[index + 3];
                    
                    if (refAlpha > 0) {
                        totalReferencePixels++;
                        
                        if (isNearUserStrokeInRegion(userImageData, x, y, region.width, region.height, tolerance)) {
                            matchingPixels++;
                        }
                    }
                }
            }
            
            return totalReferencePixels > 0 ? matchingPixels / totalReferencePixels : 0;
        }

        // ÏûêÎ™® ÏúÑÏπòÎ≥Ñ ÏòÅÏó≠ Ï†ïÏùò
        function getJamoRegion(canvasWidth, canvasHeight, position) {
            const centerX = canvasWidth / 2;
            const centerY = canvasHeight / 2;
            const regionSize = Math.min(canvasWidth, canvasHeight) * 0.8;
            
            switch (position) {
                case 'chosung': // Ï¥àÏÑ± (ÏôºÏ™Ω ÎòêÎäî ÏúÑÏ™Ω)
                    return {
                        x: Math.max(0, centerX - regionSize * 0.6),
                        y: Math.max(0, centerY - regionSize * 0.4),
                        width: Math.min(canvasWidth, regionSize * 0.6),
                        height: Math.min(canvasHeight, regionSize * 0.8)
                    };
                case 'jungsung': // Ï§ëÏÑ± (Ïò§Î•∏Ï™Ω ÎòêÎäî ÏïÑÎûòÏ™Ω)
                    return {
                        x: Math.max(0, centerX - regionSize * 0.2),
                        y: Math.max(0, centerY - regionSize * 0.4),
                        width: Math.min(canvasWidth, regionSize * 0.6),
                        height: Math.min(canvasHeight, regionSize * 0.8)
                    };
                case 'jongsung': // Ï¢ÖÏÑ± (ÏïÑÎûòÏ™Ω)
                    return {
                        x: Math.max(0, centerX - regionSize * 0.4),
                        y: Math.max(0, centerY + regionSize * 0.1),
                        width: Math.min(canvasWidth, regionSize * 0.8),
                        height: Math.min(canvasHeight, regionSize * 0.4)
                    };
                default:
                    return {x: 0, y: 0, width: canvasWidth, height: canvasHeight};
            }
        }

        // ÏòÅÏó≠ ÎÇ¥ÏóêÏÑú ÏÇ¨Ïö©Ïûê Ìöç ÌôïÏù∏
        function isNearUserStrokeInRegion(imageData, x, y, width, height, tolerance) {
            for (let dx = -tolerance; dx <= tolerance; dx++) {
                for (let dy = -tolerance; dy <= tolerance; dy++) {
                    const checkX = x + dx;
                    const checkY = y + dy;
                    
                    if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height) {
                        const index = (checkY * width + checkX) * 4;
                        if (imageData.data[index + 3] > 0) { // ÏïåÌåå Ï±ÑÎÑêÏù¥ 0Î≥¥Îã§ ÌÅ¨Î©¥ Í∑∏Î†§ÏßÑ Î∂ÄÎ∂Ñ
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // Ï†ÑÏ≤¥ Í∏ÄÏûê ÏôÑÏÑ±ÎèÑ Í≥ÑÏÇ∞ (Ïù¥Ï§ë Í≤ÄÏ¶ùÏö©)
        function calculateOverallPixelMatch(canvas, char) {
            const ctx = canvas.getContext('2d');
            
            // Í∏∞Ï§Ä Í∏ÄÏûê Ï∫îÎ≤ÑÏä§ ÏÉùÏÑ±
            const referenceCanvas = document.createElement('canvas');
            referenceCanvas.width = canvas.width;
            referenceCanvas.height = canvas.height;
            const refCtx = referenceCanvas.getContext('2d');
            
            // Í∏∞Ï§Ä Í∏ÄÏûê Í∑∏Î¶¨Í∏∞ (Îçî ÍµµÏùÄ ÏÑ†ÏúºÎ°ú - Ï†ÑÏ≤¥ ÌòïÌÉú ÌôïÏù∏Ïö©)
            refCtx.font = 'bold 120px Arial';
            refCtx.fillStyle = '#000000';
            refCtx.textAlign = 'center';
            refCtx.textBaseline = 'middle';
            refCtx.fillText(char, canvas.width / 2, canvas.height / 2);
            
            // ÏÇ¨Ïö©Ïûê Í∑∏Î¶ºÍ≥º Í∏∞Ï§Ä Í∏ÄÏûêÏùò ÌîΩÏÖÄ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
            const userImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const refImageData = refCtx.getImageData(0, 0, canvas.width, canvas.height);
            
            let matchingPixels = 0;
            let totalReferencePixels = 0;
            let userPixels = 0;
            
            // ÏÇ¨Ïö©ÏûêÍ∞Ä Í∑∏Î¶∞ ÌîΩÏÖÄ Ïàò Í≥ÑÏÇ∞
            for (let i = 0; i < userImageData.data.length; i += 4) {
                if (userImageData.data[i + 3] > 0) {
                    userPixels++;
                }
            }
            
            // ÌîΩÏÖÄÎ≥ÑÎ°ú ÎπÑÍµê (ÏïåÌåå Ï±ÑÎÑê Í∏∞Ï§Ä)
            for (let i = 0; i < refImageData.data.length; i += 4) {
                const refAlpha = refImageData.data[i + 3];
                
                if (refAlpha > 0) { // Í∏∞Ï§Ä Í∏ÄÏûêÏóê ÌîΩÏÖÄÏù¥ ÏûàÎäî Í≤ΩÏö∞
                    totalReferencePixels++;
                    
                    // ÏÇ¨Ïö©ÏûêÍ∞Ä Í∑∏Î¶∞ Î∂ÄÎ∂ÑÍ≥º Í≤πÏπòÎäîÏßÄ ÌôïÏù∏ (ÌóàÏö© Ïò§Ï∞®)
                    const pixelIndex = i / 4;
                    const x = pixelIndex % canvas.width;
                    const y = Math.floor(pixelIndex / canvas.width);
                    
                    if (isNearUserStroke(userImageData, x, y, canvas.width, canvas.height, 8)) {
                        matchingPixels++;
                    }
                }
            }
            
            // Ï†ÑÏ≤¥ ÏôÑÏÑ±ÎèÑ = (ÏùºÏπòÌïòÎäî ÌîΩÏÖÄ / Í∏∞Ï§Ä ÌîΩÏÖÄ) * (Ï†ÅÏ†àÌïú Í∑∏Î¶¨Í∏∞ Ïñë Î≥¥Ï†ï)
            const baseMatchRate = totalReferencePixels > 0 ? matchingPixels / totalReferencePixels : 0;
            
            // ÎÑàÎ¨¥ Ï†ÅÍ≤å Í∑∏Î†∏Í±∞ÎÇò ÎÑàÎ¨¥ ÎßéÏù¥ Í∑∏Î¶∞ Í≤ΩÏö∞ ÌéòÎÑêÌã∞
            const expectedPixels = totalReferencePixels * 1.2; // Í∏∞Ï§ÄÎ≥¥Îã§ 20% Ï†ïÎèÑ Îçî Í∑∏Î¶¨Îäî Í≤ÉÏùÄ ÌóàÏö©
            const drawingAmountRatio = Math.min(1, userPixels / expectedPixels);
            
            return baseMatchRate * drawingAmountRatio;
        }

        // ÌîΩÏÖÄ ÏùºÏπòÏú® Í≥ÑÏÇ∞ (ÌïúÍ∏ÄÏù¥ ÏïÑÎãå Í≤ΩÏö∞)
        function calculatePixelMatchRate(canvas, char) {
            const ctx = canvas.getContext('2d');
            
            // Í∏∞Ï§Ä Í∏ÄÏûê Ï∫îÎ≤ÑÏä§ ÏÉùÏÑ±
            const referenceCanvas = document.createElement('canvas');
            referenceCanvas.width = canvas.width;
            referenceCanvas.height = canvas.height;
            const refCtx = referenceCanvas.getContext('2d');
            
            // Í∏∞Ï§Ä Í∏ÄÏûê Í∑∏Î¶¨Í∏∞ (ÏñáÏùÄ ÏÑ†ÏúºÎ°ú)
            refCtx.font = '300 120px Arial';
            refCtx.fillStyle = '#000000';
            refCtx.textAlign = 'center';
            refCtx.textBaseline = 'middle';
            refCtx.fillText(char, canvas.width / 2, canvas.height / 2);
            
            // ÏÇ¨Ïö©Ïûê Í∑∏Î¶ºÍ≥º Í∏∞Ï§Ä Í∏ÄÏûêÏùò ÌîΩÏÖÄ Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
            const userImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const refImageData = refCtx.getImageData(0, 0, canvas.width, canvas.height);
            
            let matchingPixels = 0;
            let totalReferencePixels = 0;
            
            // ÌîΩÏÖÄÎ≥ÑÎ°ú ÎπÑÍµê (ÏïåÌåå Ï±ÑÎÑê Í∏∞Ï§Ä)
            for (let i = 0; i < refImageData.data.length; i += 4) {
                const refAlpha = refImageData.data[i + 3];
                
                if (refAlpha > 0) { // Í∏∞Ï§Ä Í∏ÄÏûêÏóê ÌîΩÏÖÄÏù¥ ÏûàÎäî Í≤ΩÏö∞
                    totalReferencePixels++;
                    
                    // ÏÇ¨Ïö©ÏûêÍ∞Ä Í∑∏Î¶∞ Î∂ÄÎ∂ÑÍ≥º Í≤πÏπòÎäîÏßÄ ÌôïÏù∏ (Ï£ºÎ≥Ä ÌîΩÏÖÄÎèÑ Í≥†Î†§)
                    const pixelIndex = i / 4;
                    const x = pixelIndex % canvas.width;
                    const y = Math.floor(pixelIndex / canvas.width);
                    
                    if (isNearUserStroke(userImageData, x, y, canvas.width, canvas.height, 8)) {
                        matchingPixels++;
                    }
                }
            }
            
            return totalReferencePixels > 0 ? matchingPixels / totalReferencePixels : 0;
        }

        // Ï£ºÎ≥ÄÏóê ÏÇ¨Ïö©Ïûê ÌöçÏù¥ ÏûàÎäîÏßÄ ÌôïÏù∏ (ÌóàÏö© Ïò§Ï∞® Î≤îÏúÑ ÎÇ¥)
        function isNearUserStroke(imageData, x, y, width, height, tolerance) {
            for (let dx = -tolerance; dx <= tolerance; dx++) {
                for (let dy = -tolerance; dy <= tolerance; dy++) {
                    const checkX = x + dx;
                    const checkY = y + dy;
                    
                    if (checkX >= 0 && checkX < width && checkY >= 0 && checkY < height) {
                        const index = (checkY * width + checkX) * 4;
                        if (imageData.data[index + 3] > 0) { // ÏïåÌåå Ï±ÑÎÑêÏù¥ 0Î≥¥Îã§ ÌÅ¨Î©¥ Í∑∏Î†§ÏßÑ Î∂ÄÎ∂Ñ
                            return true;
                        }
                    }
                }
            }
            return false;
        }











        // URLÏóêÏÑú Í≥ºÏ†ú Î°úÎìú
        function loadAssignmentFromURL() {
            const urlParams = new URLSearchParams(window.location.search);
            const assignmentData = urlParams.get('assignment');
            
            if (assignmentData) {
                try {
                    const text = decodeURIComponent(atob(assignmentData));
                    currentAssignment = text;
                    const displayElement = document.getElementById('studentDisplayText');
                    displayElement.textContent = text;
                    adjustStudentDisplayFontSize(displayElement);
                    createCharacterBoxes(text);
                } catch (e) {
                    document.getElementById('studentDisplayText').textContent = 'Í≥ºÏ†úÎ•º Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§.';
                }
            } else {
                document.getElementById('studentDisplayText').textContent = 'Í≥ºÏ†ú ÎßÅÌÅ¨Î°ú Ï†ëÏÜçÌï¥Ï£ºÏÑ∏Ïöî.';
            }
        }

        // ÌïôÏÉù ÌôîÎ©¥ Î™©Ìëú Í∏ÄÏî® Ìè∞Ìä∏ ÌÅ¨Í∏∞ ÏûêÎèô Ï°∞Ï†ï (Í∞úÏÑ†Îêú Î≤ÑÏ†Ñ)
        function adjustStudentDisplayFontSize(element) {
            const text = element.textContent;
            const textLength = text.length;
            
            // Ïª®ÌÖåÏù¥ÎÑà ÌÅ¨Í∏∞ ÌôïÏù∏
            const container = element.closest('.student-header');
            const containerStyle = window.getComputedStyle(element);
            const paddingLeft = parseFloat(containerStyle.paddingLeft);
            const paddingRight = parseFloat(containerStyle.paddingRight);
            const availableWidth = container.offsetWidth - paddingLeft - paddingRight - 20; // Ï∂îÍ∞Ä Ïó¨Î∞±
            
            // ÏûÑÏãú Ï∏°Ï†ïÏö© ÏöîÏÜå ÏÉùÏÑ±
            const measurer = document.createElement('span');
            measurer.style.visibility = 'hidden';
            measurer.style.position = 'absolute';
            measurer.style.whiteSpace = 'nowrap';
            measurer.style.fontFamily = containerStyle.fontFamily;
            measurer.style.fontWeight = containerStyle.fontWeight;
            measurer.textContent = text;
            document.body.appendChild(measurer);
            
            // Ï†ÅÏ†àÌïú Ìè∞Ìä∏ ÌÅ¨Í∏∞ Ï∞æÍ∏∞
            let fontSize = Math.min(35, availableWidth / textLength * 2.2); // Ï¥àÍ∏∞ Ï∂îÏ†ïÍ∞í
            let maxFontSize = 35;
            let minFontSize = 14;
            
            // Ïù¥ÏßÑ ÌÉêÏÉâÏúºÎ°ú ÏµúÏ†Å Ìè∞Ìä∏ ÌÅ¨Í∏∞ Ï∞æÍ∏∞
            for (let i = 0; i < 15; i++) {
                measurer.style.fontSize = fontSize + 'px';
                const textWidth = measurer.offsetWidth;
                
                if (textWidth > availableWidth) {
                    maxFontSize = fontSize;
                    fontSize = (minFontSize + fontSize) / 2;
                } else {
                    minFontSize = fontSize;
                    fontSize = (fontSize + maxFontSize) / 2;
                }
                
                // Ï∂©Î∂ÑÌûà Ï†ïÌôïÌïòÎ©¥ Ï¢ÖÎ£å
                if (Math.abs(textWidth - availableWidth) < 15) {
                    break;
                }
            }
            
            // ÏïàÏ†Ñ Ïó¨Î∞± Ï†ÅÏö© (92% ÌÅ¨Í∏∞Î°ú)
            fontSize = fontSize * 0.92;
            
            // ÏµúÏÜå/ÏµúÎåÄ ÌÅ¨Í∏∞ Ï†úÌïú
            fontSize = Math.max(14, Math.min(35, fontSize));
            
            // Ï∏°Ï†ïÏö© ÏöîÏÜå Ï†úÍ±∞
            document.body.removeChild(measurer);
            
            // Ìè∞Ìä∏ ÌÅ¨Í∏∞ Ï†ÅÏö©
            element.style.fontSize = fontSize + 'px';
            
            // Î†àÏù¥ÏïÑÏõÉ ÏÑ§Ï†ï
            if (textLength > 20 || fontSize < 18) {
                element.style.whiteSpace = 'pre-wrap';
                element.style.wordBreak = 'break-word';
                element.style.overflowWrap = 'break-word';
                element.style.lineHeight = '1.3';
                
                // Ïª®ÌÖåÏù¥ÎÑà ÎÜíÏù¥ ÏûêÎèô Ï°∞Ï†ï
                container.style.minHeight = 'auto';
                container.style.height = 'auto';
            } else {
                element.style.whiteSpace = 'nowrap';
                element.style.wordBreak = 'normal';
                element.style.overflowWrap = 'normal';
                element.style.lineHeight = '1.2';
            }
            
            // ÏµúÏ¢Ö Í≤ÄÏ¶ù - Ïó¨Ï†ÑÌûà ÎÑòÏñ¥Í∞ÄÎ©¥ Ï§ÑÎ∞îÍøà Í∞ïÏ†ú Ï†ÅÏö©
            setTimeout(() => {
                if (element.scrollWidth > availableWidth + 20) {
                    element.style.whiteSpace = 'pre-wrap';
                    element.style.wordBreak = 'break-word';
                    element.style.overflowWrap = 'break-word';
                    element.style.lineHeight = '1.3';
                    container.style.minHeight = 'auto';
                    container.style.height = 'auto';
                }
            }, 10);
        }



        // Î™®Îì† Ï∫îÎ≤ÑÏä§ ÏßÄÏö∞Í∏∞
        function clearAllCanvas() {
            characterCanvases.forEach((canvasData, index) => {
                // Ï∫îÎ≤ÑÏä§ ÏßÄÏö∞Í∏∞
                canvasData.ctx.clearRect(0, 0, canvasData.canvas.width, canvasData.canvas.height);
                
                // Í∑∏Î¶¨Í∏∞ Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
                canvasData.drawingData = [];
                
                // ÏÉÅÌÉú ÌëúÏãúÎì±ÏùÑ Îπ®Í∞ÑÏÉâÏúºÎ°ú Ï¥àÍ∏∞Ìôî
                canvasData.indicator.className = 'status-indicator red';
                canvasData.indicator.textContent = evaluationMessages.red[0]; // '‚úèÔ∏èÏûëÏÑ± Ï§ë'ÏúºÎ°ú Ï¥àÍ∏∞Ìôî
                
                // Ï∫êÎ¶≠ÌÑ∞ Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
                characterData[index].completed = false;
            });
            console.log('Î™®Îì† Ï∫îÎ≤ÑÏä§ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');
        }





        // ÌôîÎ©¥ Ï∫°Ï≤ò Î∞è Ï†ÄÏû• Í∏∞Îä•
        function saveResult() {
            // html2canvas ÎùºÏù¥Î∏åÎü¨Î¶¨Î•º ÎèôÏ†ÅÏúºÎ°ú Î°úÎìú
            if (!window.html2canvas) {
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js';
                script.onload = function() {
                    captureAndSave();
                };
                document.head.appendChild(script);
            } else {
                captureAndSave();
            }
        }

        function captureAndSave() {
            const characterGrid = document.getElementById('characterGrid');
            
            html2canvas(characterGrid, {
                backgroundColor: '#ffffff',
                scale: 2,
                useCORS: true,
                allowTaint: true,
                width: characterGrid.scrollWidth,
                height: characterGrid.scrollHeight
            }).then(function(canvas) {
                // Ï∫îÎ≤ÑÏä§Î•º Ïù¥ÎØ∏ÏßÄÎ°ú Î≥ÄÌôò
                const link = document.createElement('a');
                link.download = `Í∏ÄÏî®Ïó∞Ïäµ_${currentAssignment}_${new Date().toLocaleDateString('ko-KR')}.png`;
                link.href = canvas.toDataURL('image/png');
                
                // ÏûêÎèôÏúºÎ°ú Îã§Ïö¥Î°úÎìú Ïã§Ìñâ
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // ÏôÑÏÑ± ÏÉÅÌÉú ÏïåÎ¶º
                let completedCount = 0;
                characterData.forEach(data => {
                    if (data.completed) completedCount++;
                });
                
                alert(`Í≤∞Í≥ºÍ∞Ä Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!\nÏôÑÏÑ±Îêú Í∏ÄÏûê: ${completedCount}/${characterData.length}Í∞ú`);
            }).catch(function(error) {
                console.error('Ï∫°Ï≤ò Ïã§Ìå®:', error);
                alert('Ïù¥ÎØ∏ÏßÄ Ï†ÄÏû•Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
            });
        }

        // ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú URL ÌôïÏù∏
        window.addEventListener('load', () => {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('assignment')) {
                switchMode('student');
            } else {
                // ÍµêÏÇ¨ ÌôîÎ©¥ÏóêÏÑúÎèÑ ÎèôÏùºÌïú Ï†úÎ™© ÏÑ§Ï†ï
                document.title = 'Í∏ÄÏî® ÏöîÏ†ï - Î∞îÎ•∏ Í∏ÄÏî® Ïó∞Ïäµ';
            }
        });

        // Ï∞Ω ÌÅ¨Í∏∞ Î≥ÄÍ≤Ω Ïãú Ìè∞Ìä∏ ÌÅ¨Í∏∞ Ïû¨Ï°∞Ï†ï
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // ÍµêÏÇ¨ ÌôîÎ©¥ ÌÖçÏä§Ìä∏ Ïû¨Ï°∞Ï†ï
                const teacherDisplayText = document.getElementById('teacherDisplayText');
                if (teacherDisplayText && teacherDisplayText.textContent !== 'ÏûÖÎ†•Îêú Í∏ÄÏî®Í∞Ä Ïó¨Í∏∞Ïóê ÌëúÏãúÎê©ÎãàÎã§') {
                    adjustFontSize(teacherDisplayText);
                }
                
                // ÌïôÏÉù ÌôîÎ©¥ ÌÖçÏä§Ìä∏ Ïû¨Ï°∞Ï†ï
                const studentDisplayText = document.getElementById('studentDisplayText');
                if (studentDisplayText && studentDisplayText.textContent !== 'Í≥ºÏ†úÎ•º Î∂àÎü¨Ïò§Îäî Ï§ë...' && studentDisplayText.textContent !== 'Í≥ºÏ†ú ÎßÅÌÅ¨Î°ú Ï†ëÏÜçÌï¥Ï£ºÏÑ∏Ïöî.') {
                    adjustStudentDisplayFontSize(studentDisplayText);
                }
            }, 300); // 300ms ÎîîÎ∞îÏö¥Ïä§
        });

        // ÏóîÌÑ∞ÌÇ§ Ïù¥Î≤§Ìä∏ Î∞è Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
        document.getElementById('teacherTextInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                createAssignment();
            }
        });
        
        // Ïã§ÏãúÍ∞Ñ ÌÖçÏä§Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏ Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà
        document.getElementById('teacherTextInput').addEventListener('input', updateDisplayText);
        
        // ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú Ï¥àÍ∏∞ ÌÖçÏä§Ìä∏ ÏÑ§Ï†ï
        document.addEventListener('DOMContentLoaded', function() {
            updateDisplayText();
        });

        // ÎùºÏù¥Î∏å ÌèâÍ∞Ä Î¨∏Íµ¨ Î∞∞Ïó¥
        const evaluationMessages = {
            red: ['‚úèÔ∏èÏûëÏÑ± Ï§ë'],
            yellow: ['üòäÏ¢ãÏïÑÏöî'],
            green: ['üíöÌõåÎ•≠Ìï¥Ïöî']
        };

        // ÌèâÍ∞Ä Í≤∞Í≥ºÏóê Îî∞Î•∏ ÌëúÏãúÎì± ÏÑ§Ï†ï (ÎùºÏù¥Î∏å ÌèâÍ∞Ä Î¨∏Íµ¨ Ï†ÅÏö©)
        function setIndicatorByEvaluation(indicator, characterData, evaluation) {
            let message;
            switch (evaluation) {
                case 'Ï¥àÎ°ùÎ∂à':
                    characterData.completed = true;
                    indicator.className = 'status-indicator green';
                    message = evaluationMessages.green[0];
                    break;
                case 'ÎÖ∏ÎûÄÎ∂à':
                    characterData.completed = false;
                    indicator.className = 'status-indicator yellow';
                    message = evaluationMessages.yellow[0];
                    break;
                case 'Îπ®Í∞ÑÎ∂à':
                default:
                    characterData.completed = false;
                    indicator.className = 'status-indicator red';
                    message = evaluationMessages.red[0];
                    break;
            }
            indicator.textContent = message;
        }

        // Í∏ÄÏî® ÌèâÍ∞Ä Ìï®Ïàò
        function evaluateHandwriting() {
            // Î™®Îì† Í∏ÄÏûê Ïπ∏Ïù¥ Ï±ÑÏõåÏ°åÎäîÏßÄ ÌôïÏù∏
            let emptyCount = 0;
            characterCanvases.forEach((canvasData) => {
                if (canvasData.drawingData.length < 1) {
                    emptyCount++;
                }
            });

            // Îπà Í∏ÄÏûê Ïπ∏Ïù¥ ÏûàÏúºÎ©¥ ÏïàÎÇ¥Ï∞Ω ÌëúÏãú
            if (emptyCount > 0) {
                showIncompleteAlert();
                return;
            }

            let totalScore = 0;
            let evaluatedCount = 0;

            // Í∞Å Í∏ÄÏûê Ïπ∏Ïùò Ï†êÏàò Í≥ÑÏÇ∞
            characterCanvases.forEach((canvasData, index) => {
                const char = canvasData.char;
                
                // ÏÉâÏπ†/ÌúòÍ∞àÍπÄ Ìå®ÌÑ¥ Í∞êÏßÄ
                if (isScribbleOrFillPattern(canvasData.canvas)) {
                    // Ï†êÏàò: 0Ï†ê
                    totalScore += 0;
                    evaluatedCount++;
                    return;
                }
                
                // ÌöåÏÉâ Í∞ÄÏù¥ÎìúÏÑ†Í≥ºÏùò ÌòïÌÉú ÏùºÏπòÎèÑ ÌèâÍ∞Ä
                const guideMatchScore = calculateGuideLineMatchScore(canvasData.canvas, char);
                
                let characterScore = 0;
                if (guideMatchScore >= 0.75) {
                    characterScore = 100; // Ï¥àÎ°ùÎ∂à -> 100Ï†ê
                } else if (guideMatchScore >= 0.55) {
                    characterScore = 60;  // ÎÖ∏ÎûÄÎ∂à -> 60Ï†ê
                } else {
                    characterScore = 0;   // Îπ®Í∞ÑÎ∂à -> 0Ï†ê
                }
                
                totalScore += characterScore;
                evaluatedCount++;
            });

            // ÌèâÍ∑† Ï†êÏàò Í≥ÑÏÇ∞
            const averageScore = evaluatedCount > 0 ? Math.round(totalScore / evaluatedCount) : 0;
            
            // ÌèâÍ∞Ä Îì±Í∏âÍ≥º Î©îÏãúÏßÄ Í≤∞Ï†ï
            let grade, message;
            if (averageScore >= 80) {
                grade = 'üåüÏ†ïÎßê ÌõåÎ•≠Ìï¥Ïöî!';
                message = 'Í∏ÄÏî®Í∞Ä Î∞îÎ•¥Í≤å Ïûò Ïç®Ï°åÏñ¥Ïöî! ÏïÑÏ£º Î©ãÏßÑ Ïã§Î†•Ïù¥ÏóêÏöî.';
            } else if (averageScore >= 50) {
                grade = 'üå∏ÏûòÌñàÏñ¥Ïöî!';
                message = 'Í±∞Ïùò Îã§ Î∞òÎìØÌïòÍ≤å Ïûò ÏçºÏñ¥Ïöî! Ï°∞Í∏à Îçî Îã§Îì¨ÏúºÎ©¥ ÏôÑÎ≤ΩÌï¥Ïöî.';
            } else if (averageScore >= 25) {
                grade = 'üå±Ï°∞Í∏à Îçî Ïó∞ÏäµÌï¥Ïöî!';
                message = 'Î™á Í∏ÄÏûêÎäî Ïûò ÏçºÏñ¥Ïöî! Ï≤úÏ≤úÌûà Î∞òÎ≥µÌïòÎ©¥ Îçî Ï¢ãÏïÑÏßà Í±∞ÏòàÏöî.';
            } else {
                grade = 'üêæÏ≤òÏùåÎ∂ÄÌÑ∞ Ï∞®Í∑ºÏ∞®Í∑º';
                message = 'Ïù¥Ï†ú ÏãúÏûëÏù¥ÏóêÏöî! ÌïòÎÇòÏî© Ïç®Î≥¥Î©¥ Í∏àÎ∞© ÎÇòÏïÑÏßà Í±∞ÏòàÏöî.';
            }

            // ÌåùÏóÖ ÌëúÏãú
            showEvaluationPopup(grade, averageScore, message);
        }

        // ÎØ∏ÏôÑÏÑ± ÏïàÎÇ¥Ï∞Ω ÌëúÏãú
        function showIncompleteAlert() {
            const popup = document.createElement('div');
            popup.className = 'evaluation-popup';
            
                                popup.innerHTML = `
                        <div class="evaluation-content">
                            <div class="evaluation-title">Ïû†Íπê!</div>
                            <div class="evaluation-message" style="margin: 30px 0; word-break: keep-all; line-height: 1.4; text-align: center;">Î™®Îì† Í∏ÄÏî®Î•º Îã§ ÏôÑÏÑ±Ìï¥Ïïº<br>ÌèâÍ∞Ä Î∞õÏùÑ Ïàò ÏûàÏñ¥Ïöîüí°</div>
                            <button class="popup-close-btn" onclick="closeIncompleteAlert()">ÌôïÏù∏</button>
                        </div>
                    `;

            document.body.appendChild(popup);

            // ÌåùÏóÖ ÌÅ¥Î¶≠ÏúºÎ°ú Îã´Í∏∞ (Î∞∞Í≤Ω ÌÅ¥Î¶≠Ïãú)
            popup.addEventListener('click', function(e) {
                if (e.target === popup) {
                    closeIncompleteAlert();
                }
            });
        }

        // ÎØ∏ÏôÑÏÑ± ÏïàÎÇ¥Ï∞Ω Îã´Í∏∞
        function closeIncompleteAlert() {
            const popup = document.querySelector('.evaluation-popup');
            if (popup) {
                popup.style.animation = 'popupFadeOut 0.3s ease-out forwards';
                setTimeout(() => {
                    popup.remove();
                }, 300);
            }
        }

        // ÌèâÍ∞Ä ÌåùÏóÖ ÌëúÏãú
        function showEvaluationPopup(grade, score, message) {
            // Í∏∞Ï°¥ ÌåùÏóÖÏù¥ ÏûàÏúºÎ©¥ Ï†úÍ±∞
            const existingPopup = document.querySelector('.evaluation-popup');
            if (existingPopup) {
                existingPopup.remove();
            }

            // ÌåùÏóÖ ÏÉùÏÑ±
            const popup = document.createElement('div');
            popup.className = 'evaluation-popup';
            
            popup.innerHTML = `
                <div class="evaluation-content">
                    <div class="evaluation-title">${grade}</div>
                    <div class="evaluation-score" style="color: ${getScoreColor(score)}">${score}Ï†ê</div>
                    <div class="evaluation-message">${message}</div>
                    <button class="popup-close-btn" onclick="closeEvaluationPopup()">Îã´Í∏∞</button>
                </div>
            `;

            document.body.appendChild(popup);

            // ÌåùÏóÖ ÌÅ¥Î¶≠ÏúºÎ°ú Îã´Í∏∞ (Î∞∞Í≤Ω ÌÅ¥Î¶≠Ïãú)
            popup.addEventListener('click', function(e) {
                if (e.target === popup) {
                    closeEvaluationPopup();
                }
            });
        }

        // Ï†êÏàòÏóê Îî∞Î•∏ ÏÉâÏÉÅ Î∞òÌôò
        function getScoreColor(score) {
            if (score >= 80) return '#48bb78';      // Ï¥àÎ°ùÏÉâ
            else if (score >= 50) return '#ed8936'; // Ï£ºÌô©ÏÉâ
            else if (score >= 25) return '#ecc94b'; // ÎÖ∏ÎûÄÏÉâ
            else return '#f56565';                  // Îπ®Í∞ÑÏÉâ
        }

        // ÌèâÍ∞Ä ÌåùÏóÖ Îã´Í∏∞
        function closeEvaluationPopup() {
            const popup = document.querySelector('.evaluation-popup');
            if (popup) {
                popup.style.animation = 'popupFadeOut 0.3s ease-out forwards';
                setTimeout(() => {
                    popup.remove();
                }, 300);
            }
        }

        // ÌåùÏóÖ ÌéòÏù¥ÎìúÏïÑÏõÉ Ïï†ÎãàÎ©îÏù¥ÏÖò Ï∂îÍ∞Ä
        const style = document.createElement('style');
        style.textContent = `
            @keyframes popupFadeOut {
                from { opacity: 1; }
                to { opacity: 0; }
            }
        `;
        document.head.appendChild(style);
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'965d4859c6ad3176',t:'MTc1MzYzMTMyMy4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
